{"pages":[{"title":"404 Not Found：该页无法显示","text":"","link":"/404.html"},{"title":"关于","text":"爱折腾的老码农！ Github: https://github.com/gaoyoubo","link":"/about/index.html"},{"title":"书单","text":"","link":"/books/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"HexoClient","text":"介绍 TODO 更新记录 TODO 最佳实践安装和使用hexo TODO 使用Github Pages托管 TODO 使用Travis-CI自动发布 TODO 使用HexoClient管理你的文章 TODO 常见问题 出现莫名其妙的未知错误怎么办 Hexo中有文章，但是打开之后却显示空白HexoClient的数据加载是完全依赖于Hexo的，所以在打开HexoClient之前要确保你的Hexo是install成功的。 发布失败HexoClient的发布操作其实也是先调用hexo generate再调用hexo deploy。如果要想能够发布成功，那么首先要确保自己在命令行能够成功调用这两个命令。另外如果你的deployer是git，请使用ssh协议，不要使用http(s)协议。","link":"/hexo-client/index.html"},{"title":"友情链接","text":"IAN博客 Change the world 鸟窝 大道至简 创造狮 为创意工作者而设计 腾讯设计导航 网罗全网高逼格的设计站点","link":"/links/index.html"},{"title":"Repositories","text":"","link":"/repository/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"微博","text":"","link":"/weibo/index.html"}],"posts":[{"title":"2013年总结","text":"2013年02月16日2013年第一天班明天开始。 2013年03月宝宝的B超单，宝宝已经足月了，一切发育正常。 2013年03月清明节看房，购房开始只是个想法，我带着挺个大肚子怀孕足月了的小方，坐两个多个小时的车去看房。本来已经准备了排号费准备买房子的，后来还是被劝下来了，原因是太远上班不方便。 2013年4月18日，农历三月初九宝宝出生了，高艺涵，身高：五十公分，体重：3142克。名字是小方取的，第一眼印象还是很重要的，在宝宝出生前我们就想了很多名字，最后还是选了最最开始想出的这个名字。 2013年07月末离开了大智慧，因为被裁员了，整个北京研发中心都撤了。这是唯一一个在我走的时候我还会舍不得公司，虽然我总共也没在几家公司呆过。不过还好走的时候赔偿了三个月的工资。 2013年08月中旬在拿到大智慧赔偿的三个月工资之后，休息了半个月。然后开始琢磨找工作了。同一天面试了两个公司，一个是木仓科技一个是尚德嗨学网，两家公司都面试通过了。后来我来了木仓科技，原因是这里住的地方比较近。 2013年09月21日 小方带着小朋友去嘉兴了，北京的天气也开始慢慢转凉，她们准备去南方过冬了。 2013年10月01日 我也奔赴嘉兴看小朋友了，还好离开小朋友的时间不长，去了之后还认得我。 2013年10月13日，农历九月初九小朋友半岁了，这天正好重阳节。 2013年12月20日，农历十一月十八结婚两周年时间过的真快！ 2014年01月02日买到了过年回家的车票，G2503，农历十二月廿五到家。已经有三个多月没见到小朋友了，人家肯定已经不认识我了。","link":"/2014/01/10/2013%E5%B9%B4%E6%80%BB%E7%BB%93/"},{"title":"2014年新目标","text":"1、买一套260平米的房子 （完成） 2、换一辆路虎极光 （完成） 3、开一家咖啡馆 （完成） 4、有两次说走就走的旅行 （完成） 5、股市逆市盈利300% （完成） 6、养个小三 （完成） 7、和喜欢明星共进一次晚餐 （完成） 8、养一只阿拉斯加雪橇犬 （完成） 9、改掉爱吹牛逼的毛病 （未完成","link":"/2014/03/18/2014%E5%B9%B4%E6%96%B0%E7%9B%AE%E6%A0%87/"},{"title":"2015年终总结","text":"2015上半年挺平淡，普通的工作生活。 6月份收房，有了自己的新房子。 9月份小方来转战武汉，为我们打前站。 十一来武汉装修新房子，为转战武汉做准备。 11月13号呆着老段和高烦烦出发转战武汉14号到达，离开了奋斗很多年的北京。现在想想还甚是怀念。 11月末老段查出了患有冠脉肌桥，从此她就告别体力劳动了，只能看看孩子烧烧饭，人开始健健康康最重要。 2015年可以还清买房时所欠的外债了，从此不欠钱了，无债一身轻。 2016计划：努力工作、好好奋斗；减肥；买一辆车。","link":"/2016/02/04/2015%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"title":"2017年最后一天班","text":"2017年最后一天班，写两个字纪念一下。","link":"/2018/02/22/2017%E5%B9%B4%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%E7%8F%AD/"},{"title":"2018年最后一天","text":"先占个坑，回头写总结。","link":"/2018/12/31/2018%E5%B9%B4%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/"},{"title":"2019年开工大吉","text":"先拜祖师爷，祖师爷保佑🙏代码无BUG。努力让我所负责的产品日活越来越高。 惊喜的开年红包。 新年希望能够通过提高效率来节省更多的时间，利用节省的时间做一些自己喜欢的事情。","link":"/2019/02/11/2019%E5%B9%B4%E5%BC%80%E5%B7%A5%E5%A4%A7%E5%90%89/"},{"title":"26周岁，拍照留念","text":"26周岁，拍照留念，明年的今天会是什么样呢？","link":"/2015/04/23/26%E5%91%A8%E5%B2%81%EF%BC%8C%E6%8B%8D%E7%85%A7%E7%95%99%E5%BF%B5/"},{"title":"Android studio terminal 中文乱码解决","text":"Android studio terminal中文乱码，如下图： 解决办法打开~/.zshrc找到如下： 12# You may need to manually set your language environment# export LANG=en_US.UTF-8 将 export LANG=en_US.UTF-8 这一行解注。","link":"/2018/03/10/Android-studio-terminal-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/"},{"title":"AndroidStudio连接mumu模拟器方法","text":"启动mumu模拟器之后在设备列表中找不到模拟器，于是在网上搜索了下教程。 有个教程提供一下方法： 1adb connect 127.0.0.1:7555 附模拟器端口： 123456夜神模拟器：adb connect 127.0.0.1:62001逍遥安卓模拟器：adb connect 127.0.0.1:21503天天模拟器：adb connect 127.0.0.1:6555 海马玩模拟器：adb connect 127.0.0.1:53001网易MUMU模拟器：adb connect 127.0.0.1:7555原生模拟器：adb connect (你的IP地址)：5555 但是这个方法在mac下好像不还用，于是又找到另外一种方法： 1adb kill-server &amp;&amp; adb server &amp;&amp; adb shell 这个方法终于生效。","link":"/2020/03/07/AndroidStudio%E8%BF%9E%E6%8E%A5mumu%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%96%B9%E6%B3%95/"},{"title":"Baidu Ping","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2015-04-09 13:24:50# @Author : Weizhong Tu (mail@tuweizhong.com)# @Link : http://www.tuweizhong.com# @Version : 0.0.1from __future__ import unicode_literalsimport requestsdef main(): site_title = '自强学堂'# 网站名称 host_url = 'http://www.ziqiangxuetang.com'# 网站网址 # 更新的文章链接 update_url = 'http://www.ziqiangxuetang.com/django/django-queryset-api.html' # 网站rss地址 rss_url = 'http://www.ziqiangxuetang.com/latest_feed/' xml = '''&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;methodCall&gt; &lt;methodName&gt;weblogUpdates.extendedPing&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;string&gt;%s&lt;/string&gt;&lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;value&gt;&lt;string&gt;%s&lt;/string&gt;&lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;value&gt;&lt;string&gt;%s&lt;/string&gt;&lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;value&gt;&lt;string&gt;%s&lt;/string&gt;&lt;/value&gt; &lt;/param&gt; &lt;/params&gt;&lt;/methodCall&gt;''' % (site_title, host_url, update_url, rss_url) xml = xml.encode('utf-8') headers={ 'Content-Type': 'text/xml', 'User-Agent': 'request', 'Content-Length': len(xml) } return requests.post('http://ping.baidu.com/ping/RPC2', data=xml, headers=headers)if __name__ == '__main__': print main().content","link":"/2019/04/01/Baidu-Ping/"},{"title":"Centos7初始化安装mariadb","text":"安装MariaDB安装命令 1yum -y install mariadb mariadb-server 安装完成MariaDB，首先启动MariaDB 1systemctl start mariadb 设置开机启动 1systemctl enable mariadb 接下来进行MariaDB的相关简单配置 1mysql_secure_installation 首先是设置密码，会提示先输入密码 1Enter current password for root (enter for none):&lt;–初次运行直接回车 设置密码 123Set root password? [Y/n] &lt;– 是否设置root用户密码，输入y并回车或直接回车New password: &lt;– 设置root用户的密码Re-enter new password: &lt;– 再输入一次你设置的密码 其他配置 1234567Remove anonymous users? [Y/n] &lt;– 是否删除匿名用户，回车Disallow root login remotely? [Y/n] &lt;–是否禁止root远程登录,回车,Remove test database and access to it? [Y/n] &lt;– 是否删除test数据库，回车Reload privilege tables now? [Y/n] &lt;– 是否重新加载权限表，回车 初始化MariaDB完成，接下来测试登录 1mysql -uroot -ppassword 完成。","link":"/2019/06/05/Centos7%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%89%E8%A3%85mariadb/"},{"title":"Centos安装mariadb-server","text":"安装1yum install mariadb-server 注意：安装之后初始密码为空 常用命令123systemctl start mariadb #启动服务systemctl enable mariadb #设置开机启动systemctl restart mariadb #重新启动 初始化执行命令mysql_secure_installation进行初始化，过程中会让你设置root密码等信息，自己按照提示一步步来即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061[root@iZj6chtv8h63huh6sbynuiZ ~]# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we'll need the currentpassword for the root user. If you've just installed MariaDB, andyou haven't set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none):OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] YNew password:Re-enter new password:Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] Y ... Success!Normally, root should only be allowed to connect from 'localhost'. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] Y ... Success!By default, MariaDB comes with a database named 'test' that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] Y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] Y ... Success!Cleaning up...All done! If you've completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB!","link":"/2019/12/25/Centos%E5%AE%89%E8%A3%85mariadb-server/"},{"title":"DelayQueue使用","text":"DelayQueue特性 队列中的元素都必须实现Delayed，元素可以指定延迟消费时长。 实现了BlockingQueue接口，所以他是一个阻塞队列。 本质上是基于PriorityQueue实现的。 贴一段我在实际生产环境中使用到代码队列管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.concurrent.DelayQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;/** * @author Gao Youbo * @since 2018-07-26 19:53 */public class DelayQueueManager { private static final Logger LOG = LoggerFactory.getLogger(DelayQueueManager.class); private String name; private ExecutorService executor; private Thread monitorThread; private DelayQueue&lt;DelayTask&lt;?&gt;&gt; delayQueue; // 延时队列 public DelayQueueManager(String name, int poolSize) { this.name = name; this.executor = Executors.newFixedThreadPool(poolSize); this.delayQueue = new DelayQueue&lt;&gt;(); init(); } /** * 初始化 */ private void init() { monitorThread = new Thread(() -&gt; { execute(); }, &quot;DelayQueueMonitor-&quot; + name); monitorThread.start(); } private void execute() { while (true) { LOG.info(&quot;当前延时任务数量:&quot; + delayQueue.size()); try { // 从延时队列中获取任务 DelayTask&lt;?&gt; delayTask = delayQueue.take(); if (delayTask != null) { Runnable task = delayTask.getTask(); if (task != null) { // 提交到线程池执行task executor.execute(task); } } } catch (Exception e) { LOG.error(null, e); } } } /** * 添加任务 * * @param id 任务编号 * @param task 任务 * @param time 延时时间 * @param unit 时间单位 */ public void put(String id, Runnable task, long time, TimeUnit unit) { long timeout = TimeUnit.MILLISECONDS.convert(time, unit); long delayTimeMillis = System.currentTimeMillis() + timeout; delayQueue.put(new DelayTask&lt;&gt;(id, delayTimeMillis, task)); } /** * 添加任务 * * @param id 任务编号 * @param task 任务 * @param delayTimeMillis 延迟到什么时间点 */ public void putAt(String id, Runnable task, long delayTimeMillis) { delayQueue.put(new DelayTask&lt;&gt;(id, delayTimeMillis, task)); } /** * 根据任务编号删除任务 * * @param id * @return */ public boolean removeTaskById(String id) { DelayTask task = new DelayTask(id, 0, null); return delayQueue.remove(task); } /** * 删除任务 * * @param task * @return */ public boolean removeTask(DelayTask task) { return delayQueue.remove(task); }} 延迟任务对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Objects;import java.util.concurrent.Delayed;import java.util.concurrent.TimeUnit;/** * @author Gao Youbo * @since 2018-07-26 19:54 */public class DelayTask&lt;T extends Runnable&gt; implements Delayed { private final String id; private final long delayTimeMillis; // 延迟到什么时间点执行 private final T task; // 任务 public DelayTask(String id, long delayTimeMillis, T task) { this.id = id; this.delayTimeMillis = delayTimeMillis; this.task = task; } public T getTask() { return task; } @Override public int compareTo(Delayed o) { DelayTask other = (DelayTask) o; long diff = delayTimeMillis - other.delayTimeMillis; if (diff &gt; 0) { return 1; } else if (diff &lt; 0) { return -1; } else { return 0; } } @Override public long getDelay(TimeUnit unit) { return unit.convert(this.delayTimeMillis - System.currentTimeMillis(), TimeUnit.MILLISECONDS); } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; DelayTask&lt;?&gt; delayTask = (DelayTask&lt;?&gt;) o; return Objects.equals(id, delayTask.id); } @Override public int hashCode() { return Objects.hash(id); }}","link":"/2018/08/09/DelayQueue%E4%BD%BF%E7%94%A8/"},{"title":"FULL GC分析过程分享","text":"转载-原文地址：http://www.taobaotest.com/blogs/2294 在性能测试过程中,FULL GC频繁是比较常见的问题，FULL GC 产生的原因有很多，这里主要针对meta压测过程中分析FULL GC问题的一些思路进行分享，供大家参考 1.如何发现是否发生FULL GC和FULL GC是否频繁 使用JDK自带的轻量级小工具jstat 语法结构： Usage: jstat -help|-options jstat - [-t] [-h] [ []] 参数解释： Options — 选项，我们一般使用 -gcutil 查看gc情况 vmid — VM的进程号，即当前运行的java进程号 interval– 间隔时间，单位为秒或者毫秒 count — 打印次数，如果缺省则打印无数次 比如 /opt/taobao/java/bin/jstat –gcutil pid 5000 输出结果： S0 S1 E O P YGC YGCT FGC FGCT GCT 0.00 90.63 100.00 58.82 3.51 183 2.059 0 0.000 2.059 0.00 15.48 7.80 60.99 3.51 185 2.092 1 0.305 2.397 0.00 15.48 18.10 47.90 3.51 185 2.092 2 0.348 2.440 S0 — Heap上的 Survivor space 0 区已使用空间的百分比 S1 — Heap上的 Survivor space 1 区已使用空间的百分比 E — Heap上的 Eden space 区已使用空间的百分比 O — Heap上的 Old space 区已使用空间的百分比 P — Perm space 区已使用空间的百分比 YGC — 从应用程序启动到采样时发生 Young GC 的次数 YGCT– 从应用程序启动到采样时 Young GC 所用的时间(单位秒) FGC — 从应用程序启动到采样时发生 Full GC 的次数 FGCT– 从应用程序启动到采样时 Full GC 所用的时间(单位秒) GCT — 从应用程序启动到采样时用于垃圾回收的总时间(单位秒) 通过FGC我们可以发现系统是否发生FULL GC和FULL GC的频率 2. FULL GC分析和问题定位 a. GC log收集和分析 (1)在JVM启动参数增加：”-verbose:gc -Xloggc:&lt;file_name&gt; -XX:+PrintGCDetails -XX:+PrintGCDateStamps” PrintGCTimeStamp只能获得相对时间，建议使用PrintGCDateStamps获得full gc 发生的绝对时间 (2)如果采用CMS GC,仔细分析jstat FGC输出和GC 日志会发现， CMS的每个并发GC周期则有两个stop-the-world阶段——initial mark与final re-mark，使得CMS的每个并发GC周期总共会更新full GC计数器两次，initial mark与final re-mark各一次 b. Dump JVM 内存快照 /opt/taobao/java/bin/jmap -dump:format=b,file=dump.bin pid 这里有一个问题是什么时候进行dump? 一种方法是前面提到的用jstat工具观察，当OLD区到达比较高的比例如60%，一般会很快触发一次FULL GC,可以进行一次DUMP,在FULL GC发生以后再DUMP一次，这样比较就可以发现到底是哪些对象导致不停的FULL GC 另外一种方法是通过配置JVM参数 -XX:+HeapDumpBeforeFullGC -XX:+HeapDumpAfterFullGC分别用于指定在full GC之前与之后生成heap dump c. 利用MAT((Memory Analyzer Tool)工具分析dump文件 关于MAT具体使用方法网上有很多介绍，这里不做详细展开，这里需要注意的是： (1) MAT缺省只分析reachable的对象，unreachable的对象（将被收集掉的对象）被忽略，而分析FULL GC频繁原因时unreachable object也应该同时被重点关注。如果要显示unreachable的对象细节必须用mat 1.1以上版本并且打开选项“keep unreachable object” (2) 通常dump文件会好几个G，无法在windows上直接进行分析，我们可以先把dump文件在linux上进行分析，再把分析好的文件拷贝到windows上，在windows上用MAT打开分析文件。 下面是Meta2.0压测曾遇到的FULL GC频繁问题的分析结果，比较明显，DispatchRequest对象有4千多万个，一共超过2G，并最终导致OOM","link":"/2015/03/02/FULL-GC%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/"},{"title":"Git仓库初始化","text":"Create a new repository123456git clone git@github.com:gaoyoubo/hexo-client.gitcd user-center-transfertouch README.mdgit add README.mdgit commit -m &quot;add README&quot;git push -u origin master Existing folder123456cd existing_foldergit initgit remote add origin git@github.com:gaoyoubo/hexo-client.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin master Existing Git repository12345cd existing_repogit remote rename origin old-origingit remote add origin git@github.com:gaoyoubo/hexo-client.gitgit push -u origin --allgit push -u origin --tags","link":"/2019/01/15/Git%E4%BB%93%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"title":"Git修改默认编辑器为VIM","text":"重做系统了，新安装的Git默认编辑器为nano，各种不习惯，可以通过一下方式将默认编辑器修改为Vim 1git config --global core.editor vim","link":"/2017/09/05/Git%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%BAVIM/"},{"title":"Git删除远程tag","text":"删除本地tag很简单，直接：git tag -d tagname 但是我们这样删除之后远程标签其实并未删除，通过以下方式可以删除远程标签。 12345678# 假设标签名称为：v1.0.0# 删除本地标签git tag -d v1.0.0# 删除远程标签git push origin :refs/tags/v1.0.0","link":"/2019/07/02/Git%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8Btag/"},{"title":"Git清理历史提交记录","text":"123456789101112131415161718192021222324# 1. Checkout git checkout --orphan latest_branch# 2. Add all the files git add -A# 3. Commit the changes git commit -am &quot;commit message&quot;# 4. Delete the branch git branch -D master# 5. Rename the current branch to master git branch -m master# 6. Finally, force update your repository git push -f origin master","link":"/2019/09/03/Git%E6%B8%85%E7%90%86%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95/"},{"title":"Git清空所有commit记录方法","text":"说明：例如将代码提交到git仓库，将一些敏感信息提交，所以需要删除提交记录以彻底清除提交信息，以得到一个干净的仓库且代码不变 Checkout 1git checkout –orphan latest_branch Add all the files 1git add -A Commit the changes 1git commit -am &quot;commit message&quot; Delete the branch 1git branch -D master Rename the current branch to master 1git branch -m master Finally, force update your repository 1git push -f origin master","link":"/2019/04/25/Git%E6%B8%85%E7%A9%BA%E6%89%80%E6%9C%89commit%E8%AE%B0%E5%BD%95%E6%96%B9%E6%B3%95/"},{"title":"Golang transaction 事务使用的正确姿势","text":"第一种写法这种写法非常朴实，程序流程也非常明确，但是事务处理与程序流程嵌入太深，容易遗漏，造成严重的问题 1234567891011121314151617181920212223242526272829func DoSomething() (err error) { tx, err := db.Begin() if err != nil { return } defer func() { if p := recover(); p != nil { tx.Rollback() panic(p) // re-throw panic after Rollback } }() if _, err = tx.Exec(...); err != nil { tx.Rollback() return } if _, err = tx.Exec(...); err != nil { tx.Rollback() return } // ... err = tx.Commit() return} 第二种写法下面这种写法把事务处理从程序流程抽离了出来，不容易遗漏，但是作用域是整个函数，程序流程不是很清晰 12345678910111213141516171819202122232425262728func DoSomething() (err error) { tx, err := db.Begin() if err != nil { return } defer func() { if p := recover(); p != nil { tx.Rollback() panic(p) // re-throw panic after Rollback } else if err != nil { tx.Rollback() } else { err = tx.Commit() } }() if _, err = tx.Exec(...); err != nil { return } if _, err = tx.Exec(...); err != nil { return } // ... return} 第三种写法写法三是对写法二的进一步封装，写法高级一点，缺点同上 12345678910111213141516171819202122232425262728293031323334func Transact(db *sql.DB, txFunc func(*sql.Tx) error) (err error) { tx, err := db.Begin() if err != nil { return } defer func() { if p := recover(); p != nil { tx.Rollback() panic(p) // re-throw panic after Rollback } else if err != nil { tx.Rollback() } else { err = tx.Commit() } }() err = txFunc(tx) return err}func DoSomething() error { return Transact(db, func (tx *sql.Tx) error { if _, err := tx.Exec(...); err != nil { return err } if _, err := tx.Exec(...); err != nil { return err } })} 我的写法经过总结和实验，我采用了下面这种写法，defer tx.Rollback() 使得事务回滚始终得到执行。 当 tx.Commit() 执行后，tx.Rollback() 起到关闭事务的作用， 当程序因为某个错误中止，tx.Rollback() 起到回滚事务，同事关闭事务的作用。 普通场景12345678910111213141516func DoSomething() (err error) { tx, _ := db.Begin() defer tx.Rollback() if _, err = tx.Exec(...); err != nil { return } if _, err = tx.Exec(...); err != nil { return } // ... err = tx.Commit() return} 循环场景(1) 小事务 每次循环提交一次 在循环内部使用这种写法的时候，defer 不能使用，所以要把事务部分抽离到独立的函数当中 1234567891011121314151617181920212223func DoSomething() (err error) { tx, _ := db.Begin() defer tx.Rollback() if _, err = tx.Exec(...); err != nil { return } if _, err = tx.Exec(...); err != nil { return } // ... err = tx.Commit() return}for { if err := DoSomething(); err != nil{ // ... }} (2) 大事务 批量提交 大事务的场景和普通场景是一样的，没有任何区别 1234567891011121314151617func DoSomething() (err error) { tx, _ := db.Begin() defer tx.Rollback() for{ if _, err = tx.Exec(...); err != nil { return } if _, err = tx.Exec(...); err != nil { return } // ... } err = tx.Commit() return} 参考链接:https://stackoverflow.com/questions/16184238/database-sql-tx-detecting-commit-or-rollback原文地址：http://hopehook.com/2017/08/21/golang_transaction/","link":"/2019/03/18/Golang-transaction-%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"},{"title":"Golang和Java构建工具调查","text":"Github：https://github.com/blindpirate/report-of-build-tools-for-java-and-golang A Survey on Build Tools of Golang and JavaJavaConclusionIn January 2017, the usage of build tools in Github’s top 1000 Java repositories is as follows: Tool Name Reference Count Gradle 627 Maven 264 Ant 52 Npm 4 Bazel 3 Make 1 And the trending over the past 8 years is: Algorithm Clone top 1000 Java repositories to local disk Analyze the repositories by identity files: Tool Name Identity Files Gradle build.gradle Maven pom.xml Ant build.xml Npm package.json Bazel BUILD Make Makefile/makefile How Make sure Git/Groovy 2.4+/JDK 1.7+ are installed. Run groovy GithubTopRankCrawler.groovy -l java -d &lt;path to store the 1000 repos&gt; to clone all repositories locally. Run groovy JavaBuildToolScanner.groovy -d &lt;path to store the 1000 repos&gt; to analyze these repos. GolangConclusionThere are various package management tools for golang as listed here. But which one is the most popular? The usage of package manage tools in Github’s top 1000 Go repositories is as follows: Tool Name Url Reference Count (Feb 2017) Reference Count (Nov 2017) Makefile Makefile 199 181 dep dep N/A 94 godep godep 119 90 govendor govendor 65 84 glide glide 64 77 gvt gvt 25 16 trash trash 7 13 submodule submodule 8 6 gpm/johnny-deps gpm johnny-deps 7 6 glock glock 5 4 gom gom 4 2 gopack gopack 3 2 gopm gopm 3 1 goop goop 1 1 gvend gvend 2 0 dep had a first release in May 2017, did not exist for first stats. Technically, make is not a package management tool, here it is just for comparison. Submodule refers to a set of tools which use git submodule to manage dependencies such as manul and Vendetta and so on. Algorithm Clone top 1000 Go repositories to local disk Analyze the repositories by identity files: Tool Name Identity Files godep Godeps/Godeps.json govendor vendor/vendor.json gopm .gopmfile gvt vendor/manifest gvend vendor.yml glide glide.yaml or glide.lock trash vendor.conf gom Gomfile bunch bunchfile goop Goopfile goat .go.yaml glock GLOCKFILE gobs goproject.json gopack gopack.config nut Nut.toml gpm/johnny-deps Godeps Makefile makefile or Makefile submodule .gitmodules How Make sure Git/Groovy 2.4+/JDK 1.7+ are installed. Run groovy GithubTopRankCrawler.groovy -l go -d &lt;path to store the 1000 repos&gt; to clone all repositories locally. You can use -s to do the shallow clone and decrease disk usage. Run groovy GoBuildToolScanner.groovy &lt;path to store the 1000 repos&gt; to analyze these repos.","link":"/2019/03/11/Golang%E5%92%8CJava%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E8%B0%83%E6%9F%A5/"},{"title":"Golang并发编程","text":"Go语言的并发是基于 goroutine 的，goroutine 类似于线程，但并非线程。可以将 goroutine 理解为一种虚拟线程。Go语言运行时会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用CPU性能。 Go 程序从 main 包的 main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine。 下面我们来看一个例子，在线演示：https://play.golang.org/p/U9U-qjuY0t1 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { // 创建一个goroutine go runing() // 创建一个匿名的goroutine go func() { fmt.Println(&quot;喜特:&quot; + time.Now().String()) }() // 这里sleep一下是因为main方法如果执行完了，main该程序创建的所有goroutine都会退出 time.Sleep(5 * time.Second)}func runing() { fmt.Println(&quot;法克:&quot; + time.Now().String()) time.Sleep(3 * time.Second)}输出：法克:2009-11-10 23:00:00 +0000 UTC m=+0.000000001喜特:2009-11-10 23:00:00 +0000 UTC m=+0.000000001 执行结果说明fuck函数中的sleep三秒并没有影响喜特的输出。 如果说 goroutine 是Go语言程序的并发体的话，那么 channel 就是它们之间的通信机制。一个 channel 是一个通信机制，它可以让一个 goroutine 通过它给另一个 goroutine 发送值信息。每个 channel 都有一个特殊的类型，也就是 channel 可发送数据的类型。一个可以发送 int 类型数据的 channel 一般写为 chan int。 下面我们利用goroutine+channel来实现一个生产消费者模型，示例代码如下，在线执行：https://play.golang.org/p/lqUBugLdU-I 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { // 创建一个通道 channel := make(chan int64) // 异步去生产 go producer(channel) // 数据消费 consumer(channel)}// 生产者func producer(channel chan&lt;- int64) { for { // 将数据写入通道 channel &lt;- time.Now().Unix() // 睡1秒钟 time.Sleep(time.Second) }}// 消费者func consumer(channel &lt;-chan int64) { for { timestamp := &lt;-channel fmt.Println(timestamp) }}输出为如下：(每秒钟打印一次)1257894000125789400112578940021257894003","link":"/2019/07/15/Golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"title":"Golang指针类型和值类型","text":"Java中值类型和引用类型都是定死的，int、double、float、long、byte、short、char、boolean为值类型，其他的都是引用类型，而Go语言中却不是这样。 在Go语言中： &amp;表示取地址，例如你有一个变量a那么&amp;a就是变量a在内存中的地址，对于Golang指针也是有类型的，比如a是一个string那么&amp;a是一个string的指针类型，在Go里面叫&amp;string。 *表示取值，接上面的例子，假设你定义b := &amp;a 如果你打印b，那么输出的是&amp;a的内存地址，如果要取值，那么需要使用：*b 下面我们来看下例子，在线运行：https://play.golang.org/p/jxAKyVMjnoy 12345678910111213141516171819package mainimport ( &quot;fmt&quot;)func main() { a := &quot;123&quot; b := &amp;a fmt.Println(a) fmt.Println(b) fmt.Println(*b)}输出结果为：1230x40c128123","link":"/2019/07/15/Golang%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B/"},{"title":"Go生成csv文件","text":"123456789101112131415161718192021package mainimport ( &quot;encoding/csv&quot; &quot;os&quot;)func main() { f, err := os.Create(&quot;test.csv&quot;) if err != nil { panic(err) } defer f.Close() w := csv.NewWriter(f) data := [][]string{ {&quot;1&quot;, &quot;11&quot;, &quot;11&quot;}, {&quot;2&quot;, &quot;22&quot;, &quot;22&quot;} } w.WriteAll(data) w.Flush()}","link":"/2017/11/28/Go%E7%94%9F%E6%88%90csv%E6%96%87%E4%BB%B6/"},{"title":"Go语言在mac下编译Linux可执行文件","text":"进入源码目录，执行如下命令： 1CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build","link":"/2017/06/02/Go%E8%AF%AD%E8%A8%80%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"},{"title":"Go语言的第一次实战应用","text":"最近开始在熟悉Go语言，正巧产品同学需要分析一些数据，数据是放在ElasticSearch中的，打算使用Go语言来进行分析。Go语言的优势就是对linux兼容很好，可以直接成linux上的可执行文件，无需其他任何环境的支持。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package mainimport ( &quot;encoding/json&quot; &quot;log&quot; &quot;os&quot; elastic &quot;gopkg.in/olivere/elastic.v3&quot; &quot;strings&quot; &quot;fmt&quot; &quot;strconv&quot;)const ( url = &quot;http://xxx.xxx.xxx.xxx:9200&quot;)type Message struct { Id int MucangId string Message string CreateTime string}func main() { errorLog := log.New(os.Stdout, &quot;es &quot;, log.LstdFlags) client, err := elastic.NewClient(elastic.SetURL(url), elastic.SetErrorLog(errorLog)) if err != nil { panic(err) } var cursor int for { fmt.Println(strconv.Itoa(cursor)) boolQuery := elastic.NewBoolQuery().Filter( elastic.NewTermQuery(&quot;appinfoId&quot;, 1), elastic.NewRangeQuery(&quot;createTime&quot;).Gt(&quot;2017-05-22 00:00:00 +0800&quot;), elastic.NewMatchPhraseQuery(&quot;message&quot;, &quot;向你求助&quot;)) if cursor &gt; 0 { boolQuery.Filter(elastic.NewRangeQuery(&quot;id&quot;).Gt(cursor)) } searchResult, err := client.Search(). Index(&quot;push-record&quot;). Type(&quot;message&quot;). Query(boolQuery). Sort(&quot;id&quot;, true). From(0).Size(100). Pretty(true). Do() if err != nil { panic(err) } if searchResult.Hits.TotalHits &gt; 0 { for _, hit := range searchResult.Hits.Hits { var msg Message json.Unmarshal(*hit.Source, &amp;msg) cursor = msg.Id b, _ := json.Marshal(hit.Source) append(&quot;/home/gaoyoubo/push.log&quot;, string(b)) } } else { break } }}// 追加文件func append(path string, content string) { file, _ := os.OpenFile(path, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644) content = strings.Join([]string{content, &quot;\\n&quot;}, &quot;&quot;) buf := []byte(content) defer file.Close() file.Write(buf)}","link":"/2017/06/03/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"},{"title":"Go语言第二次实战应用","text":"使用场景，由于历史原因造成redis计数不准确，需要将数据从数据库中count一次，然后同步到redis。 使用到的包 github.com/go-sql-driver/mysql github.com/go-redis/redis 具体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package mainimport ( &quot;database/sql&quot; &quot;fmt&quot; &quot;strconv&quot; &quot;github.com/go-redis/redis&quot; _ &quot;github.com/go-sql-driver/mysql&quot;)// redis 客户端var client *redis.Clientvar db *sql.DBconst ( dbUrl = &quot;username:password@tcp(localhost:3306)/dianping_new_db?charset=utf8&quot;)func init() { // 初始化redis客户端 client = redis.NewClient(&amp;redis.Options{ Addr: &quot;localhost:6379&quot;, Password: &quot;&quot;, // no password set DB: 0, // use default DB }) db, _ = sql.Open(&quot;mysql&quot;, dbUrl)}func main() { var dianpingMap map[string]string dianpingMap = make(map[string]string) listById(func(id string, dianpingId string) { _, ok := dianpingMap[dianpingId] if ok { return } count := getCount(dianpingId) redisKey := &quot;dianping-count-&quot; + dianpingId client.HSet(redisKey, &quot;replyCount&quot;, count) dianpingMap[dianpingId] = dianpingId fmt.Println(&quot;id&quot;, id, &quot;dianpingId&quot;, dianpingId, &quot;count&quot;, count) }) client.Close() db.Close()}type Handler func(id string, dianpingId string)func listById(handler Handler) { var cursor = 0 for { sql := &quot;select id, dianping_id from t_dianping_reply &quot; if cursor &gt; 0 { sql += &quot; where id &gt; &quot; + strconv.Itoa(cursor) } sql += &quot; order by id asc limit 10 &quot; rows, err := db.Query(sql) if err != nil { panic(err) } else { for rows.Next() { var id, dianpingId string rows.Scan(&amp;id, &amp;dianpingId) handler(id, dianpingId) cursor, _ = strconv.Atoi(id) } } rows.Close() }}func getCount(dianpingId string) int { rows, err := db.Query(&quot;select count(*) from t_dianping_reply where dianping_id = ? and status = 0&quot;, dianpingId) count := 0 if err != nil { panic(err) return count } if rows.Next() { rows.Scan(&amp;count) } rows.Close() return count}","link":"/2017/06/14/Go%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"},{"title":"Guava Range使用方法","text":"概念 表示范围 guava对应功能方法 (a..b) {x | a &lt; x &lt; b} open(C, C) [a..b] {x | a &lt;= x &lt;= b} closed(C, C) [a..b) {x | a &lt;= x &lt; b} closedOpen(C, C) (a..b] {x | a &lt; x &lt;= b} openClosed(C, C) (a..+∞) {x | x &gt; a} greaterThan(C) [a..+∞) {x | x &gt;= a} atLeast(C) (-∞..b) {x | x &lt; b} lessThan(C) (-∞..b] {x | x &lt;= b} atMost(C) (-∞..+∞) all values all()","link":"/2018/05/09/Guava-Range%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"Hadoop系列好文","text":"今天看到一份很不错的hadoop文章，标注下抽空学习。http://blog.fens.me/series-hadoop-family/","link":"/2018/06/28/Hadoop%E7%B3%BB%E5%88%97%E5%A5%BD%E6%96%87/"},{"title":"Hexo1.2.0发布，全新的UI布局","text":"Hexo1.2.0发布，全新的UI布局。 之前一直觉得HexoClient的ui太不像一个原生应用，一眼就能看出是网页做的。同样是基于electron，vscode、atom等应用的ui看起来就特别正规、好看，所以这次周末抽一天时间调整一下UI。 本次更新内容 MacOS下无边框样式 调整菜单栏布局 修改UI配色和界面细节 修复初始化时选择hexo目录失败的问题 升级electron版本到3.x 其他细节修改 下载地址Mac版：https://pan.baidu.com/s/1E-5KrusoBuFGRTunTBqPJQ 提取码：2v2qWindows版本：请自行源码编译。Linux版本：请自行源码编译。 项目地址Github: https://github.com/gaoyoubo/hexo-client码云：https://gitee.com/gaoyoubo/hexo-client TODO 自动初始化hexo 文章筛选、搜索","link":"/2018/11/10/Hexo1-2-0%E5%8F%91%E5%B8%83%EF%BC%8C%E5%85%A8%E6%96%B0%E7%9A%84UI%E5%B8%83%E5%B1%80/"},{"title":"HexoClient 1.1.0版本发布","text":"升级说明 优化页面配色。 优化文章预览、详情页面展示样式。 文章内容修改后离开页面进行友好提示。 支持hexo generate 和 hexo deploy。 下载地址 Mac版本：https://pan.baidu.com/s/1s5czGqWk0JAkrvrEpYk4wQ Windows版本：请源码编译 Linux版本：请源码编译 最新截图","link":"/2018/03/19/HexoClient-1-1-0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"},{"title":"HexoClient 1.2.7版本发布","text":"本次更新内容 bugfix：修复保存快捷键失效的问题 https://github.com/gaoyoubo/hexo-client/issues/44 bugfix：修复https://sm.ms图床设置不生效的问题 支持常用快捷键操作 升级markdown编辑器版本 功能预览 相关链接 下载地址：https://github.com/gaoyoubo/hexo-client/releases/tag/v1.2.7 使用帮助：https://www.mspring.org/2018/11/29/HexoClient%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/ 提交问题：https://github.com/gaoyoubo/hexo-client/issues/new Github: https://github.com/gaoyoubo/hexo-client Gitee: https://gitee.com/gaoyoubo/hexo-client","link":"/2019/05/15/HexoClient-1-2-7%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"},{"title":"HexoClient 1.2.8版本发布","text":"本次更新内容 feature：新增阿里云oss图床支持 https://github.com/gaoyoubo/hexo-client/issues/50 feature：新增Google Analytics支持，只会搜集用户页面点击数据，请放心使用。代码更改详见：https://github.com/gaoyoubo/hexo-client/commit/2679449ab20fd04d094f238f0b6053bffdebdb3e 功能预览 相关链接 下载地址：https://github.com/gaoyoubo/hexo-client/releases/tag/v1.2.8 使用帮助：https://www.mspring.org/2018/11/29/HexoClient%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/ 提交问题：https://github.com/gaoyoubo/hexo-client/issues/new Github: https://github.com/gaoyoubo/hexo-client Gitee: https://gitee.com/gaoyoubo/hexo-client","link":"/2019/07/16/HexoClient-1-2-8%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"},{"title":"HexoClient1.2.1版本发布","text":"更新内容 支持文章搜索 优化新建、编辑文章页布局 优化调整发布功能按钮 issues 支持新建文章、发布快捷键操作 其他页面细节优化 发布地址https://github.com/gaoyoubo/hexo-client/releases 之前版本都只编译了Macos版本安装包，这次特意安装了一个虚拟机将Windows版本也编译了一份。 Mac版本下载地址：https://github.com/gaoyoubo/hexo-client/releases/download/v1.2.1/HexoClient-1.2.1.dmg Windows版本下载地址：https://github.com/gaoyoubo/hexo-client/releases/download/v1.2.1/HexoClient-1.2.1.exe 功能预览","link":"/2018/11/23/HexoClient1-2-1%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"},{"title":"HexoClient1.2.3版本发布","text":"发布地址https://github.com/gaoyoubo/hexo-client/releases/tag/v1.2.3 本次更新内容 支持i18n 新增sm.ms图床 支持上传粘贴板图片 优化设置页面布局 修复发布时仅支持master分支的问题","link":"/2019/01/02/HexoClient1-2-3%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"},{"title":"HexoClient1.2.5版本发布","text":"发布地址https://github.com/gaoyoubo/hexo-client/releases/tag/v1.2.5 功能预览","link":"/2019/01/29/HexoClient1-2-5%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"},{"title":"HexoClient1.2.6版本发布","text":"本次更新内容 feature：支持hexo特性front-matter #32 #38 bugfix：修复一处RCE(任意代码执行)漏洞 #35 升级electron 到最新版本 升级webpack到最新版本，解决老版本漏洞问题 功能预览 相关链接 Github: https://github.com/gaoyoubo/hexo-client Gitee: https://gitee.com/gaoyoubo/hexo-client 下载地址：https://github.com/gaoyoubo/hexo-client/releases/tag/v1.2.6 使用帮助：https://www.mspring.org/tags/HexoClient/ 提交问题：https://github.com/gaoyoubo/hexo-client/issues/new","link":"/2019/03/15/HexoClient1-2-6%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"},{"title":"HexoClient1.2.9版本发布","text":"本次更新内容 支持草稿功能 支持检查更新功能 修复创建文章时ctrl+s多次保存会生成多篇文章的问题 修复选中分类、标签展示之后从其他页面切换回来选中状态丢失的问题 功能预览 相关链接 下载地址：https://github.com/gaoyoubo/hexo-client/releases/tag/v1.2.9 使用帮助：https://www.mspring.org/2018/11/29/HexoClient%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/ 提交问题：https://github.com/gaoyoubo/hexo-client/issues/new Github: https://github.com/gaoyoubo/hexo-client Gitee: https://gitee.com/gaoyoubo/hexo-client","link":"/2019/07/22/HexoClient1-2-9%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"},{"title":"HexoClient1.3.0版本发布","text":"更新内容 修复阿里云oss图片上传后url不正确的问题。#60 支持一键调用hexo generate -d命令发布文章，thanks EVINK 功能预览 相关链接 下载地址：https://github.com/gaoyoubo/hexo-client/releases/tag/v1.3.0 使用帮助：https://www.mspring.org/2018/11/29/HexoClient%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/ 提交问题：https://github.com/gaoyoubo/hexo-client/issues/new Github: https://github.com/gaoyoubo/hexo-client Gitee: https://gitee.com/gaoyoubo/hexo-client","link":"/2019/08/02/HexoClient1-3-0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"},{"title":"HexoClient1.3.1版本发布","text":"更新内容 修复检查更新提示错误。#64 修复Windows系统下的一个样式错误。#65 功能预览 相关链接 下载地址：https://github.com/gaoyoubo/hexo-client/releases/tag/v1.3.1 使用帮助：https://www.mspring.org/2018/11/29/HexoClient%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/ 提交问题：https://github.com/gaoyoubo/hexo-client/issues/new Github: https://github.com/gaoyoubo/hexo-client Gitee: https://gitee.com/gaoyoubo/hexo-client","link":"/2019/08/12/HexoClient1-3-1%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"},{"title":"HexoClient1.3.2版本发布","text":"更新内容 新增好博客导航功能，搜集和推荐优质技术博客（欢迎自荐和推荐优质博客） 添加QQ交流群（QQ群：618213781） 扫码进群交流 功能预览 相关链接 下载地址：https://github.com/gaoyoubo/hexo-client/releases/tag/v1.3.1 使用帮助：https://www.mspring.org/2018/11/29/HexoClient%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/ 提交问题：https://github.com/gaoyoubo/hexo-client/issues/new Github: https://github.com/gaoyoubo/hexo-client Gitee: https://gitee.com/gaoyoubo/hexo-client","link":"/2019/08/26/HexoClient1-3-2%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"},{"title":"HexoClient1.3.3版本发布","text":"更新内容 加上一个启动失败的错误引导。 修复好博客导航数据没有分页的问题。 修改好博客导航页面布局，页面更美观。 扫码进群交流 功能预览 相关链接 下载地址：https://github.com/gaoyoubo/hexo-client/releases/tag/v1.3.1 使用帮助：https://www.mspring.org/2018/11/29/HexoClient%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/ 提交问题：https://github.com/gaoyoubo/hexo-client/issues/new Github: https://github.com/gaoyoubo/hexo-client Gitee: https://gitee.com/gaoyoubo/hexo-client","link":"/2019/09/03/HexoClient1-3-3%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"},{"title":"HexoClient使用帮助","text":"简介HexoClient是一款跨平台的Hexo管理工具。 项目地址：https://github.com/gaoyoubo/hexo-client QQ群欢迎加入HexoClient用户群交流。 QQ群号：618213781 QQ群二维码 项目背景我是从2011年开始写博客，在早期的时候wordpress、zblog、emlog等开源的博客程序都是用过。但是本着生命在于则疼的原则，后来我自己使用Java写了个简单的Blog程序( https://gitee.com/gaoyoubo/mlog ) 将其托管在阿里云服务器上。但是后面觉得为了一个博客单独买一台服务器成本比较高，所以后来改用Hexo+Github Pages，这样每年基本只需要几十块钱的域名费用即可。开始使用Hexo的时候也只是按照常规方式使用，后来了解到了electron框架，所以决定利用electron来为hexo写一个客户端。开始完全是为了自用，开源出去之后反响还不错，收到很多hexo博客党的反馈。 使用帮助阅读前提 本文不会讲解如何安装、配置、使用Hexo，所以阅读前请确保掌握以下技能。 能独立安装使用Hexo 能够正确的将Hexo部署到GitHub Pages 熟练掌握markdown语法 了解基本的Git用法 安装第一步首先安装hexo 12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 第二步去Hexo的产品发布页( https://github.com/gaoyoubo/hexo-client/releases )下载你对应平台的安装包进行安装。 第三部成功安装后打开程序会要求弹窗要求填写Hexo项目路径，该路径就是第一步通过hexo init blog创建的博客路径。正确配置路径之后即可愉快的使用HexoClient。 利用Travis-CI实现自动部署原理概述我在Github上创建以下两个项目： blog.mspring.org 该项目开启GitHub Pages用来存放hexo deploy之后的静态网页 blog-source 该项目用来存放我的hexo原始项目（也就是你通过hexo init创建的工程）然后我们利用Trvais-ci，进行自动构建和发布。当Travis-ci监控到blog-source有新的提交记录，那么会自动执行脚本将更新发布到blog.mspring.org。 使用Travis-CI自动发布第一步：生成access token进入Github个人主页，找到：Settings -&gt; Developer settings -&gt; Personal access tokens，然后取Generate new token，参照下图配置即可。这里生成的Token，接下来会用到，请先妥善保存好。 第二步：注册并开启Travis-CI项目构建使用 GitHub账户登录 Travis-CI官网 ，进去后能看到已经自动关联了 GitHub 上的仓库。这里我们选择需要启用的项目，即 blog-source。然后点击后面的Settings进入设置界面。 第三步：配置Travis-CI自动构建进入设置界面后可以参考我的配置： 配置主要注意一下两点即可： Build pushed branches 当分支收到新的push之后构建 Environment Variables -&gt; GH_TOKEN GH_TOKEN，是我们第一步在github中生成的access token，因为要从github上将代码拉到travis-ci机器上进行构建，所以需要该token授权。 第四步：配置hexo的_config.yml因为我们的博客托管在github pages，所以我们是以git的方式进行deploy的，hexo如何配置使用git方式进行deploy，请自行Google。下面截取了我的_config.yml文件中关于git deploy配置的片段。 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git # 下方的GH_TOKEN会被.travis.yml中sed命令替换 repo: https://GH_TOKEN@github.com/gaoyoubo/blog.mspring.org.git branch: master 第五步：配置构建脚本.travis.yml在hexo项目的根目录创建.travis.yml文件，该文件就是travis的构建脚本，下面是我的脚本配置，我会在脚本中详细注释每一步的作用。 1234567891011121314151617181920212223242526272829303132333435# 指定语言为node_js，nodejs版本stablelanguage: node_jsnode_js: stable# 指定构建的分支branches: only: - master# 指定node_modules缓存cache: directories: - node_modules# 构建之前安装hexo-cli，因为接下来会用到before_install: - npm install -g hexo-cli# 安装依赖install: - npm install# 执行脚本，先hexo clean 再 hexo generate，会使用hexo的同学应该不陌生。script: - hexo clean - hexo generate# 上面的脚本执行成功之后执行以下脚本进行deployafter_success: - git init - git config --global user.name &quot;GaoYoubo&quot; - git config --global user.email &quot;gaoyoubo@foxmail.com&quot; # 替换同目录下的_config.yml文件中GH_TOKEN字符串为travis后台配置的变量 - sed -i &quot;s/GH_TOKEN/${GH_TOKEN}/g&quot; ./_config.yml - hexo deploy 使用HexoClient管理你的文章 HexoClient在启动之后选择好hexo安装的目录，会自动读取Hexo目录中的文章。 HexoClient中支持新建、修改文章，新建修改文章之后点击发布按钮能够将文章更改提交到git，并自动通过travis自动发布。（前提是按照上面步骤配置好） HexoClient支持七牛图片上传，七牛10G存储空间，每月10G流量免费，可以自行注册配置七牛，配置好后将七牛的ak、sk、bucket、域名配置到HexoClient中 常见问题 出现莫名其妙的未知错误怎么办 在菜单栏中找到：查看 -&gt; 切换开发者工具，将开发者工具打开，然后看控制台是否有错误，如果有错误将错误信息copy出来，点击这里提交问题：https://github.com/gaoyoubo/hexo-client/issues/new Hexo中有文章，但是打开之后却显示空白 HexoClient的数据加载是完全依赖于Hexo的，所以在打开HexoClient之前要确保你的Hexo是install成功的。 HexoClient更新记录v1.3.2 (2019-08-26) 新增好博客导航功能，搜集和推荐优质技术博客（欢迎自荐和推荐优质博客） 添加QQ交流群（QQ群：618213781） v1.3.1 (2019-08-12) 修复检查更新提示错误。#64 修复Windows系统下的一个样式错误。#65 v1.3.0 (2019-08-02) 修复阿里云oss图片上传后url不正确的问题。#60 支持一键调用hexo generate -d命令发布文章，thanks EVINK v1.2.9 (2019-07-19) 支持草稿功能 支持检查更新功能 修复创建文章时ctrl+s多次保存会生成多篇文章的问题 修复选中分类、标签展示之后从其他页面切换回来选中状态丢失的问题 v1.2.8 (2019-07-16) feature：新增阿里云oss图床支持 https://github.com/gaoyoubo/hexo-client/issues/50 feature：新增Google Analytics支持，只会搜集用户页面点击数据，请放心使用。代码更改详见：https://github.com/gaoyoubo/hexo-client/commit/2679449ab20fd04d094f238f0b6053bffdebdb3e v1.2.7 (2019-05-15) bugfix：修复保存快捷键失效的问题 https://github.com/gaoyoubo/hexo-client/issues/44 支持常用快捷键操作 升级markdown编辑器版本 v1.2.6 (2019-03-15) feature：支持hexo特性front-matter #32 #38 bugfix：修复一处RCE(任意代码执行)漏洞 #35 升级electron 到最新版本 升级webpack到最新版本，解决老版本漏洞问题 v1.2.5 (2019-01-29) bugfix v1.2.4 (2019-01-24) 新增分类标签导航 支持自定义文章路径 修复若干BUG v1.2.3 (2019-01-02) 支持i18n 新增sm.ms图床 支持上传粘贴板图片 优化设置页面布局 修复发布时仅支持master分支的问题 v1.2.2 (2018-12-04) 支持文章搜索 优化新建、编辑文章页布局 优化调整发布功能按钮 支持新建文章、发布快捷键操作 其他页面细节优化 v1.2.1 MacOS下无边框样式 调整菜单栏布局 修改UI配色和界面细节 修复初始化时选择hexo目录失败的问题 升级electron版本到3.x 其他细节修改 v1.1.3 升级markdown编辑器，使用mavonEditor编辑器（https://github.com/hinesboy/mavonEditor）。 修复图片文章列表过长是，切换页面滚动位置丢失的问题。 重构代码，优化调用逻辑和布局层级关系。 升级electron版本到2.0.6。 v1.1.0 优化页面配色。 优化文章预览、详情页面展示样式。 文章内容修改后离开页面进行友好提示。 支持hexo generate 和 hexo deploy。","link":"/2018/11/29/HexoClient%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/"},{"title":"HexoClient被Electron应用中心收录","text":"今天打开electron的app中心发现HexoClient已经被收录了，纪念一下。地址：https://electronjs.org/apps/hexo-client","link":"/2018/11/17/HexoClient%E8%A2%ABElectron%E5%BA%94%E7%94%A8%E4%B8%AD%E5%BF%83%E6%94%B6%E5%BD%95/"},{"title":"HexoClient被开源中国推荐","text":"留图纪念一下，没想到自己胡乱折腾的东西还能上推荐。","link":"/2018/02/25/HexoClient%E8%A2%AB%E5%BC%80%E6%BA%90%E4%B8%AD%E5%9B%BD%E6%8E%A8%E8%8D%90/"},{"title":"HexoClient说明","text":"Hexo桌面客户端 联系我：http://www.mspring.org 功能简介 文章添加 文章修改 文章删除 文章支持七牛图片上传 截屏预览 TODO 文章详情页优化 图片查看优化 自动Generate 自动Deploy Build Setup12345678910111213# install dependenciesnpm install# serve with hot reload at localhost:9080npm run dev# build electron application for productionnpm run build# lint all JS/Vue component files in `src/`npm run lint This project was generated with electron-vue using vue-cli. Documentation about the original structure can be found here.","link":"/2018/02/24/HexoClient%E8%AF%B4%E6%98%8E/"},{"title":"How to build tesseract 4 beta on macOS","text":"转载这篇文章之后找到了官方的文档，建议官方文档，官方文档描述更全面。官方文档地址：https://github.com/tesseract-ocr/tesseract/wiki/Compiling 1234brew info tesseracttesseract: stable 3.05.01 (bottled), HEADOCR (Optical Character Recognition) engine The result of recognition on Chinese - Simplified is a little bit terrifying. I noticed that it added a new neural network system based on LSTMs after 4.0.0+ But it need to be build from source code on macOS. Thankfully, the manul is quit specify on their README.md Install dependencies12345brew install automake autoconf autoconf-archive libtoolbrew install pkgconfigbrew install icu4cbrew install leptonicabrew install gcc Compile123456git clone https://github.com/tesseract-ocr/tesseract/cd tesseract./autogen.sh./configure CC=gcc CXX=g++ CPPFLAGS=-I/usr/local/opt/icu4c/include LDFLAGS=-L/usr/local/opt/icu4c/libmake -jmake install Their best trained modes, download the language chi_sim.traineddata and put it under tesseract/4.0.0.1/tessdata/ Usage12tesseract image.png image -l chi_simcat image.txt OK, it is still terrible under the Song typeface font. It need to be trained a new model by myself. 文章转载自：http://artwalk.github.io/2018/05/06/How-to-build-tesseract-4-beta-on-macOS/","link":"/2018/09/28/How-to-build-tesseract-4-beta-on-macOS/"},{"title":"IDE Goland DEBUG报错","text":"在升级GO版本到1.11后发现Goland的Debug报错，错误信息如下： 1could not launch process: decoding dwarf section info at offset 0x0: too short 原因是Goland的dlv不是新版本，导致不能debug调试。 解决办法： 更新dlv：go get -u github.com/derekparker/delve/cmd/dlv 修改goland配置，Help-&gt;Edit Custom Properties中增加新版dlv的路径配置：dlv.path=$GOPATH/bin/dlv 重启Goland，再次使用debug调试工具，就没有问题了。 参考：https://stackoverflow.com/questions/43014884/mac-osx-jetbrains-gogland-delve-debugging-meet-could-not-launch-process-could/43014980#43014980","link":"/2018/12/21/IDE-Goland-DEBUG%E6%8A%A5%E9%94%99/"},{"title":"JWT介绍","text":"JWT全称为：JSON Web Token是目前最流行的跨域认证的解决方案。 跨域认证的问题互联网服务离不开用户认证。一般流程是下面这样。 用户向服务器发送用户名和密码。 服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。 服务器向用户返回一个 session_id，写入用户的 Cookie。 用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。 服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 这种模式的问题在于，扩展性不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。 举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？ 一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。 另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。 JWT的原理JWT的原则是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，如下所示。 12345{ &quot;username&quot;: &quot;admin&quot;, &quot;role&quot;: &quot;admin&quot;, &quot;expire&quot;: &quot;2018-12-24 20:15:56&quot;} 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。 服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。 JWT的数据结构实际的 JWT 大概就像下面这样。 它是一个很长的字符串，中间用点.分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。 JWT 的三个部分依次如下。 Header (头) Payload (负载) Signature (签名)写成一行，就是下面的样子：1Header.Payload.Signature 下面依次介绍这三个部分。 HeaderHeader 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。 1234{ &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;} 上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT令牌统一写为JWT。最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。 JWT里验证和签名使用的算法，可选择下面的: JWS 算法名称 描述 HS256 HMAC256 HMAC with SHA-256 HS384 HMAC384 HMAC with SHA-384 HS512 HMAC512 HMAC with SHA-512 RS256 RSA256 RSASSA-PKCS1-v1_5 with SHA-256 RS384 RSA384 RSASSA-PKCS1-v1_5 with SHA-384 RS512 RSA512 RSASSA-PKCS1-v1_5 with SHA-512 ES256 ECDSA256 ECDSA with curve P-256 and SHA-256 ES384 ECDSA384 ECDSA with curve P-384 and SHA-384 ES512 ECDSA512 ECDSA with curve P-521 and SHA-512 PayloadPayload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。12345{ &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true} 注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。这个 JSON 对象也要使用 Base64URL 算法转成字符串。 SignatureSignature 部分是对前两部分的签名，防止数据篡改。 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用.分隔，就可以返回给用户。 Base64URL前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。 JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略，+替换成-，/替换成_。这就是Base64URL 算法。 JWT的使用方式客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。 此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。 1Authorization: Bearer &lt;token&gt; 另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。 JWT 的几个特点 JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。 JWT 不加密的情况下，不能将秘密数据写入 JWT。 JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 参考 官方介绍页：https://jwt.io/introduction/","link":"/2018/12/24/JWT%E4%BB%8B%E7%BB%8D/"},{"title":"JavaCV分享","text":"JavaCV是什么 JavaCV 是一款开源的视觉处理库，基于GPLv2协议，对各种常用计算机视觉库封装后的一组jar包，封装了OpenCV、ffmpeg、videoInput…等计算机视觉编程人员常用库的接口。 maven引用1234567891011121314151617181920212223242526272829303132333435&lt;properties&gt; &lt;javacpp.version&gt;1.4.2&lt;/javacpp.version&gt; &lt;!-- 这里要根据自己的平台选择不同的依赖 --&gt; &lt;!--&lt;javacpp.platform.dependencies&gt;linux-x86_64&lt;/javacpp.platform.dependencies&gt;--&gt; &lt;javacpp.platform.dependencies&gt;macosx-x86_64&lt;/javacpp.platform.dependencies&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.bytedeco&lt;/groupId&gt; &lt;artifactId&gt;javacv&lt;/artifactId&gt; &lt;version&gt;${javacpp.version}&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.bytedeco.javacpp-presets&lt;/groupId&gt; &lt;artifactId&gt;*&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.bytedeco.javacpp-presets&lt;/groupId&gt; &lt;artifactId&gt;opencv&lt;/artifactId&gt; &lt;version&gt;3.4.2-${javacpp.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.bytedeco.javacpp-presets&lt;/groupId&gt; &lt;artifactId&gt;ffmpeg&lt;/artifactId&gt; &lt;version&gt;4.0.1-${javacpp.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.bytedeco.javacpp-presets&lt;/groupId&gt; &lt;artifactId&gt;ffmpeg&lt;/artifactId&gt; &lt;version&gt;4.0.1-${javacpp.version}&lt;/version&gt; &lt;classifier&gt;${javacpp.platform.dependencies}&lt;/classifier&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 提取视频中的图片12345678910111213141516171819/** * 从视频中将每一帧的图片提取出来 * * @param video * @return * @throws FrameGrabber.Exception */public static List&lt;BufferedImage&gt; grab(File video) throws Exception { try (FFmpegFrameGrabber grabber = FFmpegFrameGrabber.createDefault(video.getPath())) { grabber.start(); List&lt;BufferedImage&gt; images = Lists.newArrayList(); Frame frame; while ((frame = grabber.grabImage()) != null) { images.add(Java2DFrameUtils.toBufferedImage(frame)); } return images; }} 图片合成视频12345678910111213141516171819202122232425262728293031323334353637private static class VideoRecorder implements Closeable { private FFmpegFrameRecorder recorder; public VideoRecorder(String output, int width, int height) throws FrameRecorder.Exception { recorder = new FFmpegFrameRecorder(output, width, height); recorder.setVideoCodec(avcodec.AV_CODEC_ID_H264); recorder.setFormat(&quot;mp4&quot;); recorder.setFrameRate(FPS); recorder.setAudioBitrate(192000); recorder.setSampleRate(44100); recorder.setAudioChannels(2); recorder.start(); } public void addFrame(BufferedImage image) throws FrameRecorder.Exception { Frame frame = Java2DFrameUtils.toFrame(image); recorder.record(frame, avutil.AV_PIX_FMT_ARGB); } public void addAudio(File audioFile) throws FrameGrabber.Exception, FrameRecorder.Exception { if (audioFile == null || !audioFile.exists()) { return; } try (FFmpegFrameGrabber grabber = FFmpegFrameGrabber.createDefault(audioFile)) { grabber.start(); Frame frame; while ((frame = grabber.grabSamples()) != null) { recorder.recordSamples(frame.sampleRate, frame.audioChannels, frame.samples); } } } @Override public void close() throws IOException { recorder.close(); } }","link":"/2018/09/06/JavaCV%E5%88%86%E4%BA%AB/"},{"title":"Java主线程等待子线程完成","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import static java.lang.Thread.sleep;/** * * @author Gao Youbo * @since 2014-05-16 10:20:08 */public class Test { public static void main(String[] args) { SubThread thread = new SubThread(); thread.start(); //子线程开始 mainThreadWorking();//主线程干活 System.out.println(&quot;main:等待子线程完成&quot;); try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;所有线程都完成！&quot;); } private static void mainThreadWorking() { System.out.println(&quot;main:主线程开始干活...&quot;); try { Thread.sleep(2000L); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;main:主线程干完了!&quot;); }}class SubThread extends Thread { @Override public void run() { try { System.out.println(&quot;sub:子线程开始干活...&quot;); sleep(6000L); //子线程花6秒钟时间干活 System.out.println(&quot;sub:子线程干完了!&quot;); } catch (InterruptedException ex) { ex.printStackTrace(); } }}","link":"/2014/05/16/Java%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%AE%8C%E6%88%90/"},{"title":"Java分隔、合并大文件","text":"今天网百度网盘上上传文件提示单个文件大小超限，让我升级VIP。作为一个有逼格的程序猿怎么可能被这点小事难倒呢。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import com.google.common.collect.Lists;import org.apache.commons.io.FilenameUtils;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import java.util.List;/** * @author Gao Youbo * @since 2017-07-07 18:18 */public class Files { public static void main(String[] args) { int num = 10; // 分割 cut(new File(&quot;/Users/gaoyoubo/360sync/数据迁移/document/a.zip&quot;), num); // 合并 List&lt;File&gt; files = Lists.newArrayList(); for (int i = 0; i &lt; num; i++) { files.add(new File(&quot;/Users/gaoyoubo/360sync/数据迁移/document/a-&quot; + i + &quot;.zip&quot;)); } File outFile = new File(&quot;/Users/gaoyoubo/360sync/数据迁移/document/b.zip&quot;); merge(files, outFile); } /** * 分文件 * * @param sourceFile * @param num 分隔文件数量 */ public static void cut(File sourceFile, int num) { long signMaxSize = sourceFile.length() / num + 1; // 单个文件最大长度 try (RandomAccessFile source = new RandomAccessFile(sourceFile, &quot;r&quot;)) { byte[] bytes = new byte[1024]; int len; for (int i = 0; i &lt; num; i++) { File targetFile = new File(sourceFile.getParent(), FilenameUtils.getBaseName(sourceFile.getName()) + &quot;-&quot; + i + &quot;.&quot; + FilenameUtils.getExtension(sourceFile.getName())); try (RandomAccessFile target = new RandomAccessFile(targetFile, &quot;rw&quot;)) { while ((len = source.read(bytes)) != -1) {//读到文件末尾时，len返回-1，结束循环 target.write(bytes, 0, len); if (target.length() &gt; signMaxSize) { break; } } } } } catch (IOException e) { e.printStackTrace(); } } /** * 合并文件 */ public static void merge(List&lt;File&gt; files, File outFile) { try (RandomAccessFile out = new RandomAccessFile(outFile, &quot;rw&quot;)) { for (File file : files) { try (RandomAccessFile src = new RandomAccessFile(file, &quot;r&quot;)) { byte[] bytes = new byte[1024];//每次读取字节数 int len; while ((len = src.read(bytes)) != -1) { out.write(bytes, 0, len);//循环赋值 } } } } catch (IOException e) { e.printStackTrace(); } }}","link":"/2017/07/07/Java%E5%88%86%E9%9A%94%E3%80%81%E5%90%88%E5%B9%B6%E5%A4%A7%E6%96%87%E4%BB%B6/"},{"title":"Java四舍五入","text":"之前写的，总结成代码片段，留备后用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.math.BigDecimal;/** * @author Gao Youbo * @since 2014-08-28 13:55:12 */public class NumberUtils { /** * 四舍五入取整数 * * @param n * @return */ public static int roundHalfUp(float n) { return new BigDecimal(n).setScale(0, BigDecimal.ROUND_HALF_UP).intValue(); } /** * 四舍五入 * * @param n 数字 * @param precision 精度(保留几位小数) * @return */ public static float roundHalfUp(float n, int precision) { return new BigDecimal(n).setScale(precision, BigDecimal.ROUND_HALF_UP).floatValue(); } /** * 4.11 -&gt; 4.2 * &lt;p/&gt; * 4.19 -&gt; 4.2 * * @param n 数字 * @param precision 精度(保留几位小数) * @return */ public static float roundUp(float n, int precision) { return new BigDecimal(n).setScale(precision, BigDecimal.ROUND_UP).floatValue(); }}","link":"/2018/03/09/Java%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5/"},{"title":"Java学习资料","text":"前几天突然有个姑娘加我的QQ（不知道哪儿来的我的QQ），让我参加他们免费的公开课，然后给我分享Java学习资料，我以为是会给我发几本书，就参加了，没想到是一个txt文件😂，内容如下： Allen-架构师必备技能-分库分表应对数据量过大链接：https://pan.baidu.com/s/1OF4RUHvRk98pBRdUiifH2g 密码：n4ev Allen-互联网安全话题-使用https保障你的敏感数据不再裸奔链接：https://pan.baidu.com/s/1qz23y-3ahaGua4YH02KTyw 密码：fgh0 Tony-多线程Future模式-写出支撑海量并发连接的服务端代码链接：https://pan.baidu.com/s/1NwzNRxUB0_DPNQo2IW_Xhg 密码：0fpw Tony-前后端分离架构分析与实现链接：https://pan.baidu.com/s/1b7XnTibtqW26YCHfuAXkyA 密码：ah24 Tony-高并发系统架构之负载均衡全方位解析链接：https://pan.baidu.com/s/1a87EH1Xe20O4XYZaNRo-hw 密码：p52e Tony-学会举一反三-从Redis看RPC原理链接：https://pan.baidu.com/s/1disSAbJo-01ESCu6_rTHYQ 密码：ih47 -Mike-分布式系统架构技能—zookeeper实现分布式锁链接：https://pan.baidu.com/s/1adhFuoUsz1sMQTnWNGoKPA 密码：gjzh Tony-数据库连接池原理源码分析链接：https://pan.baidu.com/s/1uBiBBt-tJVSz_5t5p4jG3A 密码：jqo6 Allen-深入SpringMVC原理老司机带你手写自己的MVC框架链接：https://pan.baidu.com/s/1rlhZCSqXaZpXWM_V5CA7EQ 密码：vysj Tony-JVM类加载机制之JAVA热部署实战开发链接：https://pan.baidu.com/s/1JSLGrG0k44um7weQcq5rvg 密码：twn3 Tony-实战高并发系统缓存雪崩场景重现及解决方案链接：https://pan.baidu.com/s/1i8Q7sPNEcUIPYBuqFerRwQ 密码：lwgj Mike-解密spring-boot-starter链接：https://pan.baidu.com/s/12-1N3RTb68l3QfUOxSG1jQ 密码：sodb Tony-细说springcloud微服务架构之客户端负载均衡链接：https://pan.baidu.com/s/1VK3mMTkKYzRU4G9YXwlOLg 密码：achq","link":"/2018/10/30/Java%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"title":"Java程序员Go语言入门简介","text":"为什么是Go语言 类C的语法，这意味着Java、C#、JavaScript程序员能很快的上手 有自己的垃圾回收机制 跨平台、编译即可执行无需安装依赖环境 支持反射 Go语言简介Go 语言（或 Golang）起源于 2007 年，并在 2009 年正式对外发布。Go 是非常年轻的一门语言，它的主要目标是“兼具Python等动态语言的开发速度和 C/C++ 等编译型语言的性能与安全性”。 数据类型 数据类型 说明 bool 布尔 string 字符串 int uint8,uint16,uint32,uint64,int8,int16,int32,int64 float float32,float64 byte byte 参考：https://www.runoob.com/go/go-data-types.html 基本语法HelloWorld在线运行示例：https://play.golang.org/p/-4RylAqUV36 12345678910111213package mainimport &quot;fmt&quot;var name stringfunc init() { name = &quot;world&quot;}func main() { fmt.Println(&quot;hello &quot; + name)} 我们来执行一下： 12$ go run main.go # main.go 为刚刚创建的那个文件的名称$ hello world 变量变量声明在线运行示例：https://play.golang.org/p/zPqCkRZgrgp 1234567891011121314package mainimport ( &quot;fmt&quot;)func main() { var name string // 声明 name = &quot;gaoyoubo&quot; // 赋值 fmt.Println(name) var age int = 18 // 声明并赋值 fmt.Println(age)} 类型推断在线运行示例：https://play.golang.org/p/0My8veBvtJ8 12345678910111213package mainimport ( &quot;fmt&quot;)func main() { name := &quot;gaoyoubo&quot; fmt.Println(name) age := 18 fmt.Println(age)} 函数 函数可以有多个返回值 隐式的指定函数是private还是public，函数首字母大写的为public、小写的为private 没有类似Java中的try cache、throw，Go语言是通过将error作为返回值来处理异常。 不支持重载 下面我们通过一个示例来了解一下，在线运行示例：https://play.golang.org/p/PYy3ueuPFS6 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( &quot;errors&quot; &quot;fmt&quot; &quot;strconv&quot;)func main() { log1() log2(&quot;hello world&quot;) ret1 := add1(1, 1) fmt.Println(&quot;add1 result:&quot; + strconv.Itoa(ret1)) ret2, err := Add2(0, 1) if err == nil { fmt.Println(&quot;Add2 result:&quot; + strconv.Itoa(ret2)) } else { fmt.Println(&quot;Add2 error&quot;, err) }}// 私有、无入参、无返回值func log1() { fmt.Println(&quot;execute func log1&quot;)}// 私有、入参、无返回值func log2(msg string) { fmt.Println(&quot;execute func log2:&quot; + msg)}// 私有、两个入参、一个返回值func add1(count1, count2 int) int { total := count1 + count2 fmt.Println(&quot;execute func add3, result=&quot; + strconv.Itoa(total)) return total}// Public、两个入参、多个返回值func Add2(count1, count2 int) (int, error) { if count1 &lt; 1 || count2 &lt; 1 { return 0, errors.New(&quot;数量不能小于1&quot;) } total := count1 + count2 return total, nil} 该示例输出结果为： 12345execute func log1execute func log2:hello worldexecute func add3, result=2add1 result:2Add2 error 数量不能小于1 但函数有多个返回值的时候，有时你只关注其中一个返回值，这种情况下你可以将其他的返回值赋值给空白符：_，如下： 1234_, err := Add2(1, 2)if err != nil { fmt.Println(err)} 空白符特殊在于实际上返回值并没有赋值，所以你可以随意将不同类型的值赋值给他，而不会由于类型不同而报错。 结构体Go语言不是像Java那样的面向对象的语言，他没有对象和继承的概念。也没有class的概念。在Go语言中有个概念叫做结构体（struct），结构体和Java中的class比较类似。下面我们定义一个结构体： 12345type User struct { Name string Gender string Age int} 上面我们定义了一个结构体User，并为该结构体分别设置了三个公有属性：Name/Gender/Age，下面我们来创建一个User对象。 12345user := User{ Name: &quot;hahaha&quot;, Gender: &quot;男&quot;, Age: 18, // 值得一提的是，最后的逗号是必须的，否则编译器会报错，这就是go的设计哲学之一，要求强一致性。} 结构体的属性可以在结构体内直接声明，那么如何为结构体声明函数（即Java中的方法）呢，我们来看下下面的示例：在线运行示例：https://play.golang.org/p/01_cTu0RzdH 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;type User struct { Name string Gender string Age int}// 定义User的成员方法func (u *User) addAge() { u.Age = u.Age + 1}func main() { user := User{ Name: &quot;哈&quot;, // 名称 Gender: &quot;男&quot;, // 性别 Age: 18, // 值得一提的是，最后的逗号是必须的，否则编译器会报错，这就是go的设计哲学之一，要求强一致性。 } user.addAge() fmt.Println(user.Age)} 指针类型和值类型Java中值类型和引用类型都是定死的，int、double、float、long、byte、short、char、boolean为值类型，其他的都是引用类型，而Go语言中却不是这样。 在Go语言中： &amp;表示取地址，例如你有一个变量a那么&amp;a就是变量a在内存中的地址，对于Golang指针也是有类型的，比如a是一个string那么&amp;a是一个string的指针类型，在Go里面叫&amp;string。 *表示取值，接上面的例子，假设你定义b := &amp;a 如果你打印b，那么输出的是&amp;a的内存地址，如果要取值，那么需要使用：*b 下面我们来看下例子，在线运行：https://play.golang.org/p/jxAKyVMjnoy 12345678910111213141516171819package mainimport ( &quot;fmt&quot;)func main() { a := &quot;123&quot; b := &amp;a fmt.Println(a) fmt.Println(b) fmt.Println(*b)}输出结果为：1230x40c128123 并发编程Go语言的并发是基于 goroutine 的，goroutine 类似于线程，但并非线程。可以将 goroutine 理解为一种虚拟线程。Go语言运行时会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用CPU性能。 Go 程序从 main 包的 main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine。 下面我们来看一个例子（在线演示：https://play.golang.org/p/U9U-qjuY0t1） 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { // 创建一个goroutine go runing() // 创建一个匿名的goroutine go func() { fmt.Println(&quot;喜特:&quot; + time.Now().String()) }() // 这里sleep一下是因为main方法如果执行完了，main该程序创建的所有goroutine都会退出 time.Sleep(5 * time.Second)}func runing() { fmt.Println(&quot;法克:&quot; + time.Now().String()) time.Sleep(3 * time.Second)}输出：法克:2009-11-10 23:00:00 +0000 UTC m=+0.000000001喜特:2009-11-10 23:00:00 +0000 UTC m=+0.000000001 执行结果说明fuck函数中的sleep三秒并没有影响喜特的输出。 如果说 goroutine 是Go语言程序的并发体的话，那么 channel 就是它们之间的通信机制。一个 channel 是一个通信机制，它可以让一个 goroutine 通过它给另一个 goroutine 发送值信息。每个 channel 都有一个特殊的类型，也就是 channel 可发送数据的类型。一个可以发送 int 类型数据的 channel 一般写为 chan int。 下面我们利用goroutine+channel来实现一个生产消费者模型，示例代码如下：（在线执行：https://play.golang.org/p/lqUBugLdU-I） 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { // 创建一个通道 channel := make(chan int64) // 异步去生产 go producer(channel) // 数据消费 consumer(channel)}// 生产者func producer(channel chan&lt;- int64) { for { // 将数据写入通道 channel &lt;- time.Now().Unix() // 睡1秒钟 time.Sleep(time.Second) }}// 消费者func consumer(channel &lt;-chan int64) { for { timestamp := &lt;-channel fmt.Println(timestamp) }}输出为如下：(每秒钟打印一次)1257894000125789400112578940021257894003 Java程序员觉得不好用的地方 异常处理 没有泛型 不支持多态、重载 不支持注解（但是他的struct中的属性支持tag） 参考 https://www.runoob.com/go/go-tutorial.html https://books.studygolang.com/the-little-go-book_ZH_CN/","link":"/2019/07/15/Java%E7%A8%8B%E5%BA%8F%E5%91%98Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/"},{"title":"Java解析搜狗输入法词库","text":"解析算法摘自：http://qindongliang.iteye.com/blog/2088416 最近在优化社区搜索结果，之前使用的词库比较老旧很多次都收录不全，所以想到了搜狗输入法词库。但是搜索输入法词库文件是加密之后的，去网上找了一个Java版的解析程序，经测试可用，这里搜藏一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271package cn.mucang.saturn.common;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import java.nio.file.Files;import java.nio.file.LinkOption;import java.nio.file.Paths;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Set;/** * 解析sogou词库工具类 **/public class SogouDictParser { public static void main(String[] args) throws Exception { sogou(&quot;/Users/gaoyoubo/Downloads/sougou.scel&quot;, &quot;/Users/gaoyoubo/Downloads/sougou.txt&quot;, false); } /** * 读取scel的词库文件 * 生成txt格式的文件 * * @param inputPath 输入路径 * @param outputPath 输出路径 * @param isAppend 是否拼接追加词库内容 * true 代表追加,false代表重建 **/ private static void sogou(String inputPath, String outputPath, boolean isAppend) throws IOException { File file = new File(inputPath); if (!isAppend) { if (Files.exists(Paths.get(outputPath), LinkOption.values())) { System.out.println(&quot;存储此文件已经删除&quot;); Files.deleteIfExists(Paths.get(outputPath)); } } try (RandomAccessFile raf = new RandomAccessFile(outputPath, &quot;rw&quot;)) { int count = 0; SogouScelMdel model = new SogouScelReader().read(file); Map&lt;String, List&lt;String&gt;&gt; words = model.getWordMap(); //词&lt;拼音,词&gt; Set&lt;Entry&lt;String, List&lt;String&gt;&gt;&gt; set = words.entrySet(); Iterator&lt;Entry&lt;String, List&lt;String&gt;&gt;&gt; it = set.iterator(); while (it.hasNext()) { Entry&lt;String, List&lt;String&gt;&gt; entry = it.next(); List&lt;String&gt; list = entry.getValue(); int size = list.size(); for (int i = 0; i &lt; size; i++) { String word = list.get(i); System.out.println(word); raf.seek(raf.getFilePointer()); raf.write((word + &quot;\\n&quot;).getBytes());//写入txt文件 count++; } } System.out.println(&quot;生成txt成功！,总计写入: &quot; + count + &quot; 条数据！&quot;); } }}package cn.mucang.saturn.common;import java.io.ByteArrayOutputStream;import java.io.DataInputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;/** * @author Gao Youbo * @since 2017-03-07 19:26 */public class SogouScelReader { protected static String encoding = &quot;UTF-16LE&quot;; public SogouScelMdel read(File file) throws IOException { return read(new FileInputStream(file)); } protected ByteArrayOutputStream output = new ByteArrayOutputStream(); protected String readString(DataInputStream input, int pos, int[] reads) throws IOException { int read = reads[0]; input.skip(pos - read); read = pos; output.reset(); while (true) { int c1 = input.read(); int c2 = input.read(); read += 2; if (c1 == 0 &amp;&amp; c2 == 0) { break; } else { output.write(c1); output.write(c2); } } reads[0] = read; return new String(output.toByteArray(), encoding); } public SogouScelMdel read(InputStream in) throws IOException { SogouScelMdel model = new SogouScelMdel(); DataInputStream input = new DataInputStream(in); int read; try { byte[] bytes = new byte[4]; input.readFully(bytes); assert (bytes[0] == 0x40 &amp;&amp; bytes[1] == 0x15 &amp;&amp; bytes[2] == 0 &amp;&amp; bytes[3] == 0); input.readFully(bytes); int flag1 = bytes[0]; assert (bytes[1] == 0x43 &amp;&amp; bytes[2] == 0x53 &amp;&amp; bytes[3] == 0x01); int[] reads = new int[]{8}; model.setName(readString(input, 0x130, reads)); model.setType(readString(input, 0x338, reads)); model.setDescription(readString(input, 0x540, reads)); model.setSample(readString(input, 0xd40, reads)); read = reads[0]; input.skip(0x1540 - read); read = 0x1540; input.readFully(bytes); read += 4; assert (bytes[0] == (byte) 0x9D &amp;&amp; bytes[1] == 0x01 &amp;&amp; bytes[2] == 0 &amp;&amp; bytes[3] == 0); bytes = new byte[128]; Map&lt;Integer, String&gt; pyMap = new LinkedHashMap&lt;Integer, String&gt;(); while (true) { int mark = readUnsignedShort(input); int size = input.readUnsignedByte(); input.skip(1); read += 4; assert (size &gt; 0 &amp;&amp; (size % 2) == 0); input.readFully(bytes, 0, size); read += size; String py = new String(bytes, 0, size, encoding); //System.out.println(py); pyMap.put(mark, py); if (&quot;zuo&quot;.equals(py)) { break; } } if (flag1 == 0x44) { input.skip(0x2628 - read); } else if (flag1 == 0x45) { input.skip(0x26C4 - read); } else { throw new RuntimeException(&quot;出现意外，联系作者&quot;); } StringBuffer buffer = new StringBuffer(); Map&lt;String, List&lt;String&gt;&gt; wordMap = new LinkedHashMap&lt;String, List&lt;String&gt;&gt;(); while (true) { int size = readUnsignedShort(input); if (size &lt; 0) { break; } int count = readUnsignedShort(input); int len = count / 2; assert (len * 2 == count); buffer.setLength(0); for (int i = 0; i &lt; len; i++) { int key = readUnsignedShort(input); buffer.append(pyMap.get(key)).append(&quot;'&quot;); } buffer.setLength(buffer.length() - 1); String py = buffer.toString(); List&lt;String&gt; list = wordMap.get(py); if (list == null) { list = new ArrayList&lt;String&gt;(); wordMap.put(py, list); } for (int i = 0; i &lt; size; i++) { count = readUnsignedShort(input); if (count &gt; bytes.length) { bytes = new byte[count]; } input.readFully(bytes, 0, count); String word = new String(bytes, 0, count, encoding); //接下来12个字节可能是词频或者类似信息 input.skip(12); list.add(word); } } //System.out.println(wordMap.size()); model.setWordMap(wordMap); return model; } finally { in.close(); } } protected final int readUnsignedShort(InputStream in) throws IOException { int ch1 = in.read(); int ch2 = in.read(); if ((ch1 | ch2) &lt; 0) { return Integer.MIN_VALUE; } return (ch2 &lt;&lt; 8) + (ch1 &lt;&lt; 0); }}package cn.mucang.saturn.common;import java.util.List;import java.util.Map;/** * @author Gao Youbo * @since 2017-03-07 19:26 */public class SogouScelMdel { private Map&lt;String, List&lt;String&gt;&gt; wordMap; private String name; private String type; private String description; private String sample; public Map&lt;String, List&lt;String&gt;&gt; getWordMap() { return wordMap; } void setWordMap(Map&lt;String, List&lt;String&gt;&gt; wordMap) { this.wordMap = wordMap; } public String getType() { return type; } public void setType(String type) { this.type = type; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getSample() { return sample; } public void setSample(String sample) { this.sample = sample; } public String getName() { return name; } public void setName(String name) { this.name = name; }}","link":"/2017/03/07/Java%E8%A7%A3%E6%9E%90%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E8%AF%8D%E5%BA%93/"},{"title":"MacOS安装PHP","text":"偶然的机会需要用一下PHP，记录下安装方式。本身mac系统是自带php的，但是自带的修改起来及其不方便，不好安装扩展。所以直接使用brew安装。 brew安装php1234brew search php 使用此命令搜索可用的PHP版本brew install php@7.3.21 使用此命令安装指定版本的phpbrew install brew-php-switcher 安装php多版本切换工具brew-php-switcher 7.3.21 切换PHP版本到7.3.21（需要brew安装多个版本） 安装PHP扩展12345pecl version 查看版本信息pecl help 可以查看命令帮助pecl search redis 搜索可以安装的扩展信息pecl install redis 安装扩展pecl install http://pecl.php.net/get/redis-4.2.0.tgz 安装指定版本扩展","link":"/2021/03/22/MacOS%E5%AE%89%E8%A3%85PHP/"},{"title":"Mac使用过程中的问题汇总","text":"Touchbarbu不显示音量这应该是一个BUG，在终端执行以下命令可以恢复正常： 1killall ControlStrip 清理dns缓存1sudo killall -HUP mDNSResponder iterm2 lzrz 功能配置解决办法：https://www.mspring.org/2021/01/19/mac-iterm2-rz%E4%B8%8Esz%E7%9A%84%E5%8A%9F%E8%83%BD/","link":"/2020/11/25/Mac%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"},{"title":"MySql导出指定列的数据","text":"MySql导出整库或者指定表的数据使用mysqldump命令即可，但是导出表中指定列的数据就需要用到下面命令了，如下： 1mysql -uroot -p123456 database_name -e &quot;SELECT name from t_xxx where type = 3 INTO OUTFILE'/data/xxx.sql'&quot;","link":"/2019/12/16/MySql%E5%AF%BC%E5%87%BA%E6%8C%87%E5%AE%9A%E5%88%97%E7%9A%84%E6%95%B0%E6%8D%AE/"},{"title":"SpringBoot中统一包装响应","text":"SpringBoot 中可以基于 ControllerAdvice 和 HttpMessageConverter 实现对数据返回的包装。 实现如下，先来写一个 POJO 来定义一下返回格式： 12345678910111213141516171819202122232425262728293031323334353637383940import com.example.demo.common.exception.base.ErrorCode;import lombok.AllArgsConstructor;import lombok.Getter;import org.springframework.http.HttpStatus;@Getter@AllArgsConstructorpublic class Response&lt;T&gt; { private int code = HttpStatus.OK.value(); private String msg = &quot;success&quot;; private T data; public Response(T data) { this.data = data; } public Response(int code, String msg) { this.code = code; this.msg = msg; } public Response(int code, T data) { this.code = code; this.data = data; } public Response(ErrorCode errorCode) { this.code = errorCode.getCode(); this.msg = errorCode.getMessage(); } public Response(ErrorCode errorCode, T data) { this.code = errorCode.getCode(); this.msg = errorCode.getMessage(); this.data = data; }} 这里用到了lombok，lombok的使用介绍不在本文范围内。 用一个 ResponseBodyAdvice 类的实现包装 Controller 的返回值： 以下是我以前的实现方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import com.example.demo.common.RequestContextHolder;import com.fasterxml.jackson.databind.ObjectMapper;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.MethodParameter;import org.springframework.core.annotation.Order;import org.springframework.http.MediaType;import org.springframework.http.server.ServerHttpRequest;import org.springframework.http.server.ServerHttpResponse;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;@ControllerAdvicepublic class FormatResponseBodyAdvice implements ResponseBodyAdvice { private static Logger logger = LoggerFactory.getLogger(FormatResponseBodyAdvice.class); @Autowired private ObjectMapper objectMapper; @Override public boolean supports(MethodParameter returnType, Class converterType) { return true; } @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) { Object wrapperBody = body; try { if (!(body instanceof Response)) { if (body instanceof String) { wrapperBody = objectMapper.writeValueAsString(new Response&lt;&gt;(body)); } else { wrapperBody = new Response&lt;&gt;(body); } } } catch (Exception e) { logger.error(&quot;request uri path: {}, format response body error&quot;, request.getURI().getPath(), e); } return wrapperBody; }} 为什么要对返回类型是 String 时进行特殊处理呢？因为如果直接返回 new Response&lt;&gt;(body) 的话，在使用时返回 String 类型的话，会报类型转换异常，当时也没有理解什么原因导致的，所以最后使用了 jackson 对 Response 又做了一次序列化。 今天找到了导致这个异常的原因： 因为在所有的 HttpMessageConverter 实例集合中，StringHttpMessageConverter 要比其它的 Converter 排得靠前一些。我们需要将处理 Object 类型的 HttpMessageConverter 放得靠前一些，这可以在 Configuration 类中完成： 123456789101112131415import org.springframework.context.annotation.Configuration;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import java.util.List;@Configurationpublic class WebConfiguration implements WebMvcConfigurer { @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { converters.add(0, new MappingJackson2HttpMessageConverter()); }} 然后 FormatResponseBodyAdvice 就可以修改为如下实现： 1234567891011121314151617181920212223242526272829import org.springframework.core.MethodParameter;import org.springframework.http.MediaType;import org.springframework.http.server.ServerHttpRequest;import org.springframework.http.server.ServerHttpResponse;import org.springframework.http.server.ServletServerHttpRequest;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;@ControllerAdvicepublic class FormatResponseBodyAdvice implements ResponseBodyAdvice { @Override public boolean supports(MethodParameter returnType, Class converterType) { return true; } @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) { if (!(body instanceof Response)) { return new Response&lt;&gt;(body); } return body; }} 比之前的实现方式优雅了很多而且不用再处理 jackson 的异常了。 写一个 Controller 来尝试一下： 123456789@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String hello() { return &quot;hello world!&quot;; }} 请求这个端点得到结果： 12345{ &quot;code&quot;: 200, &quot;msg&quot;: &quot;success&quot;, &quot;data&quot;: &quot;hello world!&quot;} 说明我们的配置是成功的，同时可以在相应头中看到： 1content-type: application/json;charset=UTF-8 如果是之前的实现方式，这里的值就是： 1content-type: html/text 也不太符合 restful 规范。 转载自：https://jpanj.com/2018/SpringBoot-%E4%B8%AD%E7%BB%9F%E4%B8%80%E5%8C%85%E8%A3%85%E5%93%8D%E5%BA%94/","link":"/2019/10/22/SpringBoot%E4%B8%AD%E7%BB%9F%E4%B8%80%E5%8C%85%E8%A3%85%E5%93%8D%E5%BA%94/"},{"title":"Sublime Text3注册码","text":"12345678910111213—– BEGIN LICENSE —–Ryan ClarkSingle User LicenseEA7E-8124792158A7DE B690A7A3 8EC04710 006A5EEB34E77CA3 9C82C81F 0DB6371B 79704E6F93F36655 B031503A 03257CCC 01B20F60D304FA8D B1B4F0AF 8A76C7BA 0FA94D5556D46BCE 5237A341 CD837F30 4D60772D349B1179 A996F826 90CDB73C 24D41245FD032C30 AD5E7241 4EAA66ED 167D91FB55896B16 EA125C81 F550AF6B A6820916—— END LICENSE ——","link":"/2016/03/29/Sublime-Text3%E6%B3%A8%E5%86%8C%E7%A0%81/"},{"title":"Ubuntu18.10配置rc.local自启动","text":"Ubuntu新版本中已经不使用rc.local这种自启动方式了，熟悉旧版本的同学肯定是很不习惯的。那么新版本中如何配置rc.local呢。 自行创建 /etc/rc.local 添加以下默认内容 1234567891011121314#!/bin/sh -e## rc.local## This script is executed at the end of each multiuser runlevel.# Make sure that the script will &quot;exit 0&quot; on success or any other# value on error.## In order to enable or disable this script just change the execution# bits.## By default this script does nothing.exit 0 在 exit 0 之前加入自定义内容 执行以下命令确保 rc.local 开机自启 123sudo chown root:root /etc/rc.localsudo chmod 755 /etc/rc.localsudo systemctl enable rc-local.service","link":"/2018/11/17/Ubuntu18-10%E9%85%8D%E7%BD%AErc-local%E8%87%AA%E5%90%AF%E5%8A%A8/"},{"title":"Ubuntu安装NodeJs","text":"之前使用apt命令安装node，但是安装之后每次执行都要sudo，比较麻烦。通过一下脚本可以将node安装到个人home下，以后执行就不用sudo了。 123456789echo 'export PATH=$HOME/local/bin:$PATH' &gt;&gt; ~/.bashrc. ~/.bashrcmkdir ~/localmkdir ~/node-latest-installcd ~/node-latest-installcurl http://nodejs.org/dist/node-latest.tar.gz | tar xz --strip-components=1./configure --prefix=$HOME/localmake installcurl -L https://www.npmjs.com/install.sh | sh","link":"/2017/09/07/Ubuntu%E5%AE%89%E8%A3%85NodeJs/"},{"title":"Ubuntu安装Docker","text":"安装命令 12sudo apt-get install -y docker.io 等待安装完毕，现在我们使用下面的命令启动 Docker： 1systemctl start docker 运行系统引导时启用 docker，命令： 1systemctl enable docker","link":"/2017/09/24/Ubuntu%E5%AE%89%E8%A3%85docker/"},{"title":"Ubuntu配置Shadownsocks以及配置pac规则","text":"周末没事将自己闲置的Thinkpad安装了最新的Ubuntu18.10版本，安装成功之后就想着将之前在自己的vps上配置的shadowsock服务使用上。 第一步安装shadowsocks1sudo apt-get install shadowsocks 第二步配置shadowsocks安装完成之后默认的配置文件在/etc/shadowsocks/local.json，去将里面的配置修改成自己的即可。 123456789101112{ &quot;server&quot;:&quot;xxx.xxx.xxx.xxx&quot;, &quot;server_port&quot;:xxx, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;xxx&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: true, &quot;workers&quot;: 1, &quot;prefer_ipv6&quot;: false} 第三步启动shadowsocks1sudo sslocal -c /etc/shadowsocks/local.json -d start 第四步配置pac规则1. 安装GenPac12sudo pip install genpacpip install --upgrade genpac 2. 新建pac配置存放目录用来存放用户自定义规则列表文件user-rules.txt和生成后的autoproxy.pac文件，例如我的放在home目录下 123mkdir ~/soft/paccd ~./soft/pactouch user-rules.txt 3. 生成autoproxy.pac文件我使用的是github上托管的这份文件：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt执行一下命令来创建autoprox.pac 1genpac --pac-proxy &quot;SOCKS5 127.0.0.1:1080&quot; --output=&quot;autoproxy.pac&quot; --gfwlist-url=&quot;https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot; --user-rule-from=&quot;user-rules.txt&quot; 4. 配置系统代理去Ubuntu设置 -&gt; 网络 -&gt; 代理设置设置代理，选择自动，配置url填写你本地的文件路径，例如：file:///home/xxx/soft/pac/autoproxy.pac","link":"/2018/11/17/Ubuntu%E9%85%8D%E7%BD%AEShadownsocks%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AEpac%E8%A7%84%E5%88%99/"},{"title":"Use Go Channels as Promises and Async&#x2F;Await","text":"原文地址：https://levelup.gitconnected.com/use-go-channels-as-promises-and-async-await-ee62d93078ec If you’ve ever programmed with Javascript, you definitely know about Promise and async/await. C#, *Java, Python, *and some other programming languages apply the same pattern but with other names such as Task or Future. On the contrary, Go doesn’t follow the pattern at all. Instead, it introduces goroutines and channels. However, it isn’t difficult to replicate the pattern with goroutines and channels. Single async/awaitFirst, let’s experiment with a simple use case: await a result from an async function. 12345678910// Javascript.const longRunningTask = async () =&gt; { // Simulate a workload. sleep(3000) return Math.floor(Math.random() * Math.floor(100))}const r = await longRunningTask()console.log(r) 12345678910111213141516171819202122232425262728// Go.package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;)func longRunningTask() &lt;-chan int32 { r := make(chan int32) go func() { defer close(r) // Simulate a workload. time.Sleep(time.Second * 3) r &lt;- rand.Int31n(100) }() return r}func main() { r := &lt;-longRunningTask() fmt.Println(r)} Single async/await in Javascript vs. Golang To declare an “async” function in Go: The return type is &lt;-chan ReturnType. Within the function, create a channel by make(chan ReturnType) and return the created channel at the end of the function. Start an anonymous goroutine by go func() {...} and implement the function’s logic inside that anonymous function. Return the result by sending the value to channel. At the beginning of the anonymous function, add defer close(r) to close the channel once done. To “await” the result, simply read the value from channel by v := &lt;- fn(). Promise.all()It’s very common that we start multiple async tasks then wait for all of them to finish and gather their results. Doing that is quite simple in both Javascript and Golang. 12345678910// Javascript.const longRunningTask = async () =&gt; { // Simulate a workload. sleep(3000) return Math.floor(Math.random() * Math.floor(100))}const [a, b, c] = await Promise.all(longRunningTask(), longRunningTask(), longRunningTask())console.log(a, b, c) 123456789101112131415161718192021222324252627282930// Go.package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;)func longRunningTask() &lt;-chan int32 { r := make(chan int32) go func() { defer close(r) // Simulate a workload. time.Sleep(time.Second * 3) r &lt;- rand.Int31n(100) }() return r}func main() { aCh, bCh, cCh := longRunningTask(), longRunningTask(), longRunningTask() a, b, c := &lt;-aCh, &lt;-bCh, &lt;-cCh fmt.Println(a, b, c)} We have to do it in 2 lines of code and introduce 3 more variables, but it’s clean and simple enough. We can not do &lt;-longRun(), &lt;-longRun(), &lt;-longRun(), which will longRun() one by one instead all in once. Promise.race()Sometimes, a piece of data can be received from several sources to avoid high latencies, or there’re cases that multiple results are generated but they’re equivalent and the only first response is consumed. This first-response-win pattern, therefore, is quite popular. Achieving that in both Javascript and Go is very simple. 1234567891011121314151617// Javascript.const one = async () =&gt; { // Simulate a workload. sleep(Math.floor(Math.random() * Math.floor(2000))) return 1}const two = async () =&gt; { // Simulate a workload. sleep(Math.floor(Math.random() * Math.floor(1000))) sleep(Math.floor(Math.random() * Math.floor(1000))) return 2}const r = await Promise.race(one(), two())console.log(r) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Go.package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;)func one() &lt;-chan int32 { r := make(chan int32) go func() { defer close(r) // Simulate a workload. time.Sleep(time.Millisecond * time.Duration(rand.Int63n(2000))) r &lt;- 1 }() return r}func two() &lt;-chan int32 { r := make(chan int32) go func() { defer close(r) // Simulate a workload. time.Sleep(time.Millisecond * time.Duration(rand.Int63n(1000))) time.Sleep(time.Millisecond * time.Duration(rand.Int63n(1000))) r &lt;- 2 }() return r}func main() { var r int32 select { case r = &lt;-one(): case r = &lt;-two(): } fmt.Println(r)} select-case is the pattern that Go designed specifically for racing channel operations. We can even do more stuff within each case, but we’re focusing only on the result so we just leave them all empty. Promise.then() and Promise.catch()Because Go’s error propagation model is very different from Javascript, there’s any clean way to replicate Promise.then() and Promise.catch(). In Go, error is returned along with return values instead of being thrown as exception. Therefore, if your function can fail, you can consider changing your return &lt;-chan ReturnType into &lt;-chan ReturnAndErrorType, which is a struct holding both the result and error.","link":"/2019/11/13/Use-Go-Channels-as-Promises-and-Async-Await/"},{"title":"ffmpeg常用命令总结","text":"音频格式转换123456ffmpeg -y -i aidemo.mp3 -acodec pcm_s16le -f s16le -ac 1 -ar 16000 16k.pcm // -acodec pcm_s16le pcm_s16le 16bits 编码器 // -f s16le 保存为16bits pcm格式// -ac 1 单声道// -ar 16000 16000采样率 查看音频格式1234567891011121314151617181920212223242526272829303132333435363738394041424344ffprobe -v quiet -print_format json -show_streams aidemo.mp3输出如下： { &quot;streams&quot;: [ { &quot;index&quot;: 0, &quot;codec_name&quot;: &quot;mp3&quot;, // mp3 格式 &quot;codec_long_name&quot;: &quot;MP3 (MPEG audio layer 3)&quot;, &quot;codec_type&quot;: &quot;audio&quot;, &quot;codec_time_base&quot;: &quot;1/16000&quot;, &quot;codec_tag_string&quot;: &quot;[0][0][0][0]&quot;, &quot;codec_tag&quot;: &quot;0x0000&quot;, &quot;sample_fmt&quot;: &quot;s16p&quot;, &quot;sample_rate&quot;: &quot;16000&quot;, // 16000采样率 &quot;channels&quot;: 1, // 单声道 &quot;channel_layout&quot;: &quot;mono&quot;, &quot;bits_per_sample&quot;: 0, &quot;r_frame_rate&quot;: &quot;0/0&quot;, &quot;avg_frame_rate&quot;: &quot;0/0&quot;, &quot;time_base&quot;: &quot;1/14112000&quot;, &quot;start_pts&quot;: 0, &quot;start_time&quot;: &quot;0.000000&quot;, &quot;duration_ts&quot;: 259096320, &quot;duration&quot;: &quot;18.360000&quot;, &quot;bit_rate&quot;: &quot;16000&quot;, &quot;disposition&quot;: { &quot;default&quot;: 0, &quot;dub&quot;: 0, &quot;original&quot;: 0, &quot;comment&quot;: 0, &quot;lyrics&quot;: 0, &quot;karaoke&quot;: 0, &quot;forced&quot;: 0, &quot;hearing_impaired&quot;: 0, &quot;visual_impaired&quot;: 0, &quot;clean_effects&quot;: 0, &quot;attached_pic&quot;: 0, &quot;timed_thumbnails&quot;: 0 } } ]}","link":"/2018/05/11/ffmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"title":"go mod 的使用","text":"从Go1.11开始，golang官方支持了新的依赖管理工具go mod。 命令行说明123456789101112131415161718192021222324➜ ~ go modGo mod provides access to operations on modules.Note that support for modules is built into all the go commands,not just 'go mod'. For example, day-to-day adding, removing, upgrading,and downgrading of dependencies should be done using 'go get'.See 'go help modules' for an overview of module functionality.Usage: go mod &lt;command&gt; [arguments]The commands are: download download modules to local cache edit edit go.mod from tools or scripts graph print module requirement graph init initialize new module in current directory tidy add missing and remove unused modules vendor make vendored copy of dependencies verify verify dependencies have expected content why explain why packages or modules are neededUse &quot;go help mod &lt;command&gt;&quot; for more information about a command. go mod download: 下载依赖的module到本地cache go mod edit: 编辑go.mod go mod graph: 打印模块依赖图 go mod init: 在当前目录下初始化go.mod(就是会新建一个go.mod文件) go mod tidy: 整理依赖关系，会添加丢失的module，删除不需要的module go mod vender: 将依赖复制到vendor下 go mod verify: 校验依赖 go mod why: 解释为什么需要依赖 在新项目中使用使用go mod并不要求你的项目源码放到$GOPATH下，所以你的新项目可以放到任意你喜欢的路径。在项目根目录下执行go mod init，会生成一个go.mod文件。然后你可以在其中增加你的依赖，如下： 12345678module github.com/gaoyoubo/xxxgo 1.12require ( github.com/go-sql-driver/mysql v1.4.1 .... 你的依赖类似这样，添加到这里，一行一条。) 然后执行go mod download，将依赖下载到本地。这些依赖并不是下载到你的项目目录下，而是会下载到$GOPATH/pkg/mod目录下，这样所有使用go mod的项目都可以共用。 在旧项目中使用在旧项目中使用非常简单，只需要一下两个步骤： go mod init: 在项目根目录下执行该命令，会在项目根目录下生成一个go.mod文件。 go mod tidy: 在项目根目录下执行该命令，go mod会自动分析你当前项目所需要的依赖，并且将他们下载下来。 如何升级依赖运行 go get -u 将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号y是次要版本号)运行 go get -u=patch 将会升级到最新的修订版本运行 go get package@version 将会升级到指定的版本","link":"/2019/03/15/go-mod-%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"hexo-client 1.1.3更新","text":"升级markdown编辑器，使用mavonEditor编辑器（https://github.com/hinesboy/mavonEditor）。 修复图片文章列表过长是，切换页面滚动位置丢失的问题。 重构代码，优化调用逻辑和布局层级关系。 升级electron版本到2.0.6。 mac版本下载地址：https://pan.baidu.com/s/1VuJIOoltpsTwnurn9aVQXw","link":"/2018/08/07/hexo-client-1-1-3%E6%9B%B4%E6%96%B0/"},{"title":"HexoClient1.2.4版本发布","text":"发布地址https://github.com/gaoyoubo/hexo-client/releases/tag/v1.2.4 更新内容 新增分类标签导航 支持自定义文章路径 修复若干BUG 功能预览","link":"/2019/01/24/hexo-client-1.2.4-release/"},{"title":"iphone6到手","text":"买的港版、灰色、64G，总共花了5060块。","link":"/2015/02/12/iphone6%E5%88%B0%E6%89%8B/"},{"title":"javacv使用笔记","text":"使用过程中遇到的异常异常：Could not initialize class org.bytedeco.javacpp.avutil12345678Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: Could not initialize class org.bytedeco.javacpp.avutilat java.lang.Class.forName0(Native Method)at java.lang.Class.forName(Class.java:274)at org.bytedeco.javacpp.Loader.load(Loader.java:385)at org.bytedeco.javacpp.Loader.load(Loader.java:353)at org.bytedeco.javacpp.avformat$AVFormatContext.&lt;clinit&gt;(avformat.java:2249)at org.bytedeco.javacv.FFmpegFrameGrabber.startUnsafe(FFmpegFrameGrabber.java:346)at org.bytedeco.javacv.FFmpegFrameGrabber.start(FFmpegFrameGrabber.java:340) 解决办法： 1mvn package exec:java -Dplatform.dependencies -Dexec.mainClass=Demo 警告：Warning: data is not aligned! This can lead to a speedloss出现这个警告是因为ffmpeg要求视频的宽度必须是32的倍数，高度必须是2的倍数，按要求修改下宽高就好了。 使用示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import com.google.common.collect.Lists;import org.apache.commons.io.FileUtils;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.math.NumberUtils;import org.bytedeco.javacpp.avcodec;import org.bytedeco.javacpp.opencv_core;import org.bytedeco.javacpp.opencv_imgcodecs;import org.bytedeco.javacv.*;import javax.imageio.ImageIO;import java.awt.image.BufferedImage;import java.io.File;import java.util.Collections;import java.util.List;/** * @author Gao Youbo * @since 2018-08-15 16:43 */public class OpenCVUtils { public static void main(String[] args) throws Exception { List&lt;BufferedImage&gt; images = grab(new File(&quot;/data/opencv/test.mp4&quot;)); int i = 1; for (BufferedImage image : images) { ImageIO.write(image, &quot;jpg&quot;, new File(&quot;/data/opencv/frame/&quot; + i + &quot;.jpg&quot;)); i++; } // grabAudioFromVideo(new File(&quot;/data/opencv/test.mp4&quot;), new File(&quot;/data/opencv/test.aac&quot;)); List&lt;File&gt; files = Lists.newArrayList(FileUtils.listFiles(new File(&quot;/data/opencv/frame/&quot;), new String[]{&quot;jpg&quot;}, false)); Collections.sort(files, (o1, o2) -&gt; { int i1 = NumberUtils.toInt(StringUtils.substringBefore(o1.getName(), &quot;.&quot;)); int i2 = NumberUtils.toInt(StringUtils.substringBefore(o2.getName(), &quot;.&quot;)); return Integer.compare(i1, i2); }); record(&quot;/data/opencv/out.mp4&quot;, files, new File(&quot;/data/opencv/test.aac&quot;), 544, 960); } /** * 将多个图片文件合成视频 * * @param output 输出文件 * @param images 序列帧图片 * @param audioFile 音频 * @param width 宽 * @param height 高 * @throws Exception */ public static void record(String output, List&lt;File&gt; images, File audioFile, int width, int height) throws Exception { try (FFmpegFrameRecorder recorder = new FFmpegFrameRecorder(output, width, height); FFmpegFrameGrabber grabber = FFmpegFrameGrabber.createDefault(audioFile)) { recorder.setVideoCodec(avcodec.AV_CODEC_ID_H264); recorder.setFormat(&quot;mp4&quot;); recorder.setFrameRate(30); recorder.setAudioBitrate(192000); recorder.setAudioQuality(0); recorder.setSampleRate(44100); recorder.setAudioChannels(2); recorder.start(); OpenCVFrameConverter.ToIplImage converter = new OpenCVFrameConverter.ToIplImage(); for (File file : images) { opencv_core.IplImage image = opencv_imgcodecs.cvLoadImage(file.getPath()); recorder.record(converter.convert(image)); opencv_core.cvReleaseImage(image); } grabber.start(); Frame frame; while ((frame = grabber.grabSamples()) != null) { recorder.setTimestamp(frame.timestamp); recorder.recordSamples(frame.sampleRate, frame.audioChannels, frame.samples); } } } /** * 从视频中将每一帧的图片提取出来 * * @param video * @return * @throws FrameGrabber.Exception */ public static List&lt;BufferedImage&gt; grab(File video) throws Exception { try (FFmpegFrameGrabber grabber = FFmpegFrameGrabber.createDefault(video.getPath())) { grabber.start(); List&lt;BufferedImage&gt; images = Lists.newArrayList(); Frame frame; while ((frame = grabber.grabImage()) != null) { images.add(Java2DFrameUtils.toBufferedImage(frame)); } return images; } } /** * 从视频中提取出音频 * * @param video * @param outputAudio */ public static void grabAudioFromVideo(File video, File outputAudio) throws Exception { try (FFmpegFrameGrabber grabber = FFmpegFrameGrabber.createDefault(video); FFmpegFrameRecorder recorder = new FFmpegFrameRecorder(outputAudio, 1)) { grabber.start(); recorder.setAudioCodec(avcodec.AV_CODEC_ID_AAC); recorder.start(); Frame frame; while ((frame = grabber.grab()) != null) { if (frame.audioChannels == 1) { recorder.recordSamples(frame.sampleRate, frame.audioChannels, frame.samples); } } } }} 图片合成视频简单的封装1234567891011121314151617181920212223242526272829303132333435363738private static class VideoRecorder implements Closeable { private FFmpegFrameRecorder recorder; public VideoRecorder(String output, int width, int height) throws FrameRecorder.Exception { recorder = new FFmpegFrameRecorder(output, width, height); recorder.setVideoCodec(avcodec.AV_CODEC_ID_H264); recorder.setFormat(&quot;mp4&quot;); recorder.setFrameRate(FPS); recorder.setAudioBitrate(192000); recorder.setAudioQuality(0); recorder.setSampleRate(44100); recorder.setAudioChannels(2); recorder.start(); } public void addFrame(BufferedImage image) throws FrameRecorder.Exception { Frame frame = Java2DFrameUtils.toFrame(image); recorder.record(frame, avutil.AV_PIX_FMT_ARGB); } public void addAudio(File audioFile) throws FrameGrabber.Exception, FrameRecorder.Exception { if (audioFile == null || !audioFile.exists()) { return; } try (FFmpegFrameGrabber grabber = FFmpegFrameGrabber.createDefault(audioFile)) { grabber.start(); Frame frame; while ((frame = grabber.grabSamples()) != null) { recorder.recordSamples(frame.sampleRate, frame.audioChannels, frame.samples); } } } @Override public void close() throws IOException { recorder.close(); } } 解决maven打包时将不必要的包引入进来的问题我在实际使用中只用到了ffmpeg，但是打包的时候却将flycapture、libdc1394、libfreenect、artoolkitplus、tesseract…等包都打进来了，这些都是我不需要的，下面贴出我的maven配置示例。 1234567891011121314151617181920212223242526272829303132333435&lt;properties&gt; &lt;javacpp.version&gt;1.4.2&lt;/javacpp.version&gt; &lt;!-- 这里要根据自己的平台选择不同的依赖 --&gt; &lt;!--&lt;javacpp.platform.dependencies&gt;linux-x86_64&lt;/javacpp.platform.dependencies&gt;--&gt; &lt;javacpp.platform.dependencies&gt;macosx-x86_64&lt;/javacpp.platform.dependencies&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.bytedeco&lt;/groupId&gt; &lt;artifactId&gt;javacv&lt;/artifactId&gt; &lt;version&gt;${javacpp.version}&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.bytedeco.javacpp-presets&lt;/groupId&gt; &lt;artifactId&gt;*&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.bytedeco.javacpp-presets&lt;/groupId&gt; &lt;artifactId&gt;opencv&lt;/artifactId&gt; &lt;version&gt;3.4.2-${javacpp.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.bytedeco.javacpp-presets&lt;/groupId&gt; &lt;artifactId&gt;ffmpeg&lt;/artifactId&gt; &lt;version&gt;4.0.1-${javacpp.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.bytedeco.javacpp-presets&lt;/groupId&gt; &lt;artifactId&gt;ffmpeg&lt;/artifactId&gt; &lt;version&gt;4.0.1-${javacpp.version}&lt;/version&gt; &lt;classifier&gt;${javacpp.platform.dependencies}&lt;/classifier&gt; &lt;/dependency&gt; &lt;/dependencies&gt;","link":"/2018/08/14/javacv%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"title":"mac iterm2 rz与sz的功能","text":"本文主要介绍mac环境下使用iterm2的rz sz功能的安装流程。 1. 安装lrzsz1brew install lrzsz 2. 安装执行脚本将iterm2-send-zmodem.sh和iterm2-recv-zmodem.sh保存到/usr/local/bin目录下。 iterm2-send-zmodem.sh 12345678910111213141516171819202122232425#!/bin/bash# Author: Matt Mastracci (matthew@mastracci.com)# AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script# licensed under cc-wiki with attribution required # Remainder of script public domainosascript -e 'tell application &quot;iTerm2&quot; to version' &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTermif [[ $NAME = &quot;iTerm&quot; ]]; then FILE=$(osascript -e 'tell application &quot;iTerm&quot; to activate' -e 'tell application &quot;iTerm&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;' -e &quot;do shell script (\\&quot;echo \\&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\&quot;\\&quot;)&quot;)else FILE=$(osascript -e 'tell application &quot;iTerm2&quot; to activate' -e 'tell application &quot;iTerm2&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;' -e &quot;do shell script (\\&quot;echo \\&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\&quot;\\&quot;)&quot;)fiif [[ $FILE = &quot;&quot; ]]; then echo Cancelled. # Send ZModem cancel echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18 sleep 1 echo echo \\# Cancelled transferelse /usr/local/bin/sz &quot;$FILE&quot; --escape --binary --bufsize 4096 sleep 1 echo echo \\# Received &quot;$FILE&quot;fi iterm2-recv-zmodem.sh 12345678910111213141516171819202122232425262728#!/bin/bash# Author: Matt Mastracci (matthew@mastracci.com)# AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script# licensed under cc-wiki with attribution required # Remainder of script public domainosascript -e 'tell application &quot;iTerm2&quot; to version' &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTermif [[ $NAME = &quot;iTerm&quot; ]]; then FILE=$(osascript -e 'tell application &quot;iTerm&quot; to activate' -e 'tell application &quot;iTerm&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;' -e &quot;do shell script (\\&quot;echo \\&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\&quot;\\&quot;)&quot;)else FILE=$(osascript -e 'tell application &quot;iTerm2&quot; to activate' -e 'tell application &quot;iTerm2&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;' -e &quot;do shell script (\\&quot;echo \\&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\&quot;\\&quot;)&quot;)fiif [[ $FILE = &quot;&quot; ]]; then echo Cancelled. # Send ZModem cancel echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18 sleep 1 echo echo \\# Cancelled transferelse cd &quot;$FILE&quot; /usr/local/bin/rz --rename --escape --binary --bufsize 4096 sleep 1 echo echo echo \\# Sent \\-\\&gt; $FILEfi 3. 赋予这两个文件可执行权限1chmod 777 /usr/local/bin/iterm2-* 4. 设置Iterm2的Tirgger特性设置Iterm2的Tirgger特性，profiles-&gt;default-&gt;editProfiles-&gt;Advanced中的Tirgger 添加两条trigger，分别设置 Regular expression，Action，Parameters，Instant如下： 123456789Regular expression: rz waiting to receive.\\*\\*B0100Action: Run Silent CoprocessParameters: /usr/local/bin/iterm2-send-zmodem.shInstant: checkedRegular expression: \\*\\*B00000000000000Action: Run Silent CoprocessParameters: /usr/local/bin/iterm2-recv-zmodem.shInstant: checked 示例图： 5. 使用 上传文件：rz 下载文件：sz + file 参考： https://www.robberphex.com/use-zmodem-at-macos/ https://github.com/RobberPhex/iterm2-zmodem","link":"/2021/01/19/mac-iterm2-rz%E4%B8%8Esz%E7%9A%84%E5%8A%9F%E8%83%BD/"},{"title":"mac下，mds_stores占用过高cpu，导致风扇狂转，怎么解决？","text":"网上的以下方法，是不行的： 1sudo mdutil -a -i off 运行了这一行，mds mds_stores等还是在20% 左右运行中 于是，发现了一个新方法，在终端运行这个： 1sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist 等你想开的时候，在终端运行这个就行了： 1sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist 哈哈，成功关闭后，世界都变流畅了！！！ 相关文章： https://www.jianshu.com/p/d76dbc097521","link":"/2020/06/12/mac%E4%B8%8B%EF%BC%8Cmds-stores%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98cpu%EF%BC%8C%E5%AF%BC%E8%87%B4%E9%A3%8E%E6%89%87%E7%8B%82%E8%BD%AC%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/"},{"title":"Markdown 语法指南","text":"Markdown 语法指南 语法详解 粗体12**粗体**__粗体__ 斜体12*斜体*_斜体_ 标题12345678910# 一级标题 #一级标题====## 二级标题 ##二级标题----### 三级标题 ####### 四级标题 ######### 五级标题 ########### 六级标题 ###### 分割线12***--- ^上^角下标12上角标 x^2^下角标 H~2~0 ++下划线++ 中划线12++下划线++~~中划线~~ ==标记==1==标记== 段落引用1234&gt; 一级&gt;&gt; 二级&gt;&gt;&gt; 三级... 列表123456789有序列表1.2.3....无序列表--... 任务列表 已完成任务 未完成任务 12- [x] 已完成任务- [ ] 未完成任务 链接12[链接](www.baidu.com)![图片描述](http://www.image.com) 代码段落``` type 代码段落 ``` ` 代码块 ` 1234int main(){ printf(&quot;hello world!&quot;);} code 表格(table)1234| 标题1 | 标题2 | 标题3 || :-- | :--: | ----: || 左对齐 | 居中 | 右对齐 || ---------------------- | ------------- | ----------------- | 标题1 标题2 标题3 左对齐 居中 右对齐 ———————- ————- —————– 脚注(footnote)1hello[^hello] 见底部脚注^hello 表情(emoji)参考网站: https://www.webpagefx.com/tools/emoji-cheat-sheet/ 12345:laughing::blush::smiley::)... :laughing::blush::smiley::) $\\KaTeX$公式我们可以渲染公式例如：$x_i + y_i = z_i$和$\\sum_{i=1}^n a_i=0$我们也可以单行渲染$$\\sum_{i=1}^n a_i=0$$具体可参照katex文档和katex支持的函数以及latex文档 布局::: hljs-left::: hljs-left居左:::::: ::: hljs-center::: hljs-center居中:::::: ::: hljs-right::: hljs-right居右:::::: 定义术语一 : 定义一 包含有行内标记的术语二 : 定义二 {一些定义二的文字或代码} 定义二的第三段 123456789101112术语一: 定义一包含有*行内标记*的术语二: 定义二 {一些定义二的文字或代码} 定义二的第三段 abbr*[HTML]: Hyper Text Markup Language*[W3C]: World Wide Web ConsortiumHTML 规范由 W3C 维护 123*[HTML]: Hyper Text Markup Language*[W3C]: World Wide Web ConsortiumHTML 规范由 W3C 维护","link":"/2019/04/28/markdown-help/"},{"title":"maven打包可执行jar文件","text":"需要打包有依赖第三方jar包的可执行jar会用到，他会帮你将所有的第三方的jar包都打到同一个jar中，这样就不用手动去设置classpath 12345678910111213141516171819202122232425&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt; &lt;mainClass&gt;cn.mucang.saturn.transfer.Transfer&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;","link":"/2017/03/27/maven%E6%89%93%E5%8C%85%E5%8F%AF%E6%89%A7%E8%A1%8Cjar%E6%96%87%E4%BB%B6/"},{"title":"mysql decimal精度问题","text":"decimal(M,N) 参数说明M指定指定小数点左边和右边可以存储的十进制数字的最大个数，最大精度38。N指定小数点右边可以存储的十进制数字的最大个数。小数位数必须是从 0 到 M之间的值。默认小数位数是 0。","link":"/2018/01/17/mysql-decimal%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/"},{"title":"mysql5.x重置密码","text":"This one is for all MySQL-DBA’s, which are working on macOS. Since the Apple OS has a rather peculiar way of starting and stopping MySQL, compared to Linux, you can run into some issues. These problems occur especially, if you have no access to the GUI. PREPARATIONPut skip-grant-tables into the mysqld section of the my.cnf. A my.cnf can be found in /usr/local/mysql/support-files. You MUST work as root for all the following steps. 12345678shell&gt; sudo -sshell&gt; vi /usr/local/mysql/support-files/my-default.cnf...[mysqld]skip-grant-tablesskip-networking... Save the configuration file! (In vi this is “[ESC] + :x”) Continue with stopping MySQL: 1launchctl unload /Library/LaunchDaemons/com.oracle.oss.mysql.mysqld.plist Restart MySQL, so skip-grant-tables becomes active: 1launchctl load /Library/LaunchDaemons/com.oracle.oss.mysql.mysqld.plist RESET THE PASSWORDAfter MySQL is started again, you can log into the CLI and reset the password: 123shell&gt; mysql -u rootmysql&gt; FLUSH PRIVILEGES;mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'super-secret-password'; PLAN BIf you are not capable of stopping MySQL in a civilised manner, you can use the more rough way. You can send a SIGTERM to the MySQL-Server: 12shell&gt; ps -aef | grep mysql | grep -v grep 74 28017 1 0 Fri10AM ?? 5:59.50 /usr/local/mysql/bin/mysqld --user=_mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --log-error=/usr/local/mysql/data/mysqld.local.err --pid-file=/usr/local/mysql/data/mysqld.local.pid You should receive one line. The second column from the left is the process id. Use this process id to stop the MySQL-Server. 1shell&gt; kill -15 [process id] In this example, the command would look like this: 1shell&gt; kill -15 28017 macOS will restart MySQL, since the process has not stopped correctly. The configuration will be read and the changes to the parameters will become effective. Continue with logging in to the CLI. CONCLUSIONNo matter how secure your MySQL-Password is, it is a lot more important to secure access to the server it self. If your server is not secured by something that prevents access from the internet, it will only take a few minutes for someone with bad intentions to take over your database or worse, the entire server.","link":"/2019/03/11/mysql5-x%E9%87%8D%E7%BD%AE%E5%AF%86%E7%A0%81/"},{"title":"nginx-clojure安装使用","text":"安装配置环境要求jdk1.6+ nginx1.4+ 安装下载nginx和nginx-clojure源码，分别去他们的官网下载就可以，然后将他们解压、编译、安装。编译安装nginx时，加上nginx-clojure模块，具体安装脚本如下： 123./configure --prefix=/usr/local/nginx --add-module=nginx-clojure模块解压路径makesudo make install 配置### 建议这里查看官方文档，比较详细 ### 官方文档地址：http://nginx-clojure.github.io/configuration.html#21-jvm-path--class-path--other-jvm-options jvm_path auto; # classpath：需要加载nginx-clojure自己的jar包，并加载自己开发的jar包 jvm_classpath &quot;/usr/local/nginx/libs/nginx-clojure-0.4.4/jars/*:/Users/gaoyoubo/work/dianping-service/dianping-nginx/target/dianping-nginx-2.0.1-SNAPSHOT.jar&quot;; 使用rewrite handler rewrite handler可用于请求的转发。 Java handler类12345678910111213141516package my.test;import static nginx.clojure.java.Constants.*;public static class MyRewriteProxyPassHandler implements NginxJavaRingHandler { @Override public Object[] invoke(Map&lt;String, Object&gt; req) { String myhost = computeMyHost(req); ((NginxJavaRequest)req).setNGXVariable(&quot;myhost&quot;, myhost); return PHASE_DONE; } private String computeMyHost(Map&lt;String, Object&gt; req) { //compute a upstream name or host name; }} nginx.conf配置set $myhost &quot;&quot;; location /myproxy { ### 这里指定handle_type rewrite_handler_type 'java'; ### 这里指定处理类 rewrite_handler_name 'my.test.MyRewriteProxyPassHandler'; proxy_pass $myhost; } access handler 可做请求的权限校验 Java handler类12345678910111213141516171819202122/** * This is an example of HTTP basic Authentication. * It will require visitor to input a user name (xfeep) and password (hello!) * otherwise it will return 401 Unauthorized or BAD USER &amp; PASSWORD */ public class BasicAuthHandler implements NginxJavaRingHandler { @Override public Object[] invoke(Map&lt;String, Object&gt; request) { String auth = (String) ((Map)request.get(HEADERS)).get(&quot;authorization&quot;); if (auth == null) { return new Object[] { 401, ArrayMap.create(&quot;www-authenticate&quot;, &quot;Basic realm=\\&quot;Secure Area\\&quot;&quot;), &quot;&lt;HTML&gt;&lt;BODY&gt;&lt;H1&gt;401 Unauthorized.&lt;/H1&gt;&lt;/BODY&gt;&lt;/HTML&gt;&quot; }; } String[] up = new String(DatatypeConverter.parseBase64Binary(auth.substring(&quot;Basic &quot;.length())), DEFAULT_ENCODING).split(&quot;:&quot;); if (up[0].equals(&quot;xfeep&quot;) &amp;&amp; up[1].equals(&quot;hello!&quot;)) { return PHASE_DONE; } return new Object[] { 401, ArrayMap.create(&quot;www-authenticate&quot;, &quot;Basic realm=\\&quot;Secure Area\\&quot;&quot;), &quot;&lt;HTML&gt;&lt;BODY&gt;&lt;H1&gt;401 Unauthorized BAD USER &amp; PASSWORD.&lt;/H1&gt;&lt;/BODY&gt;&lt;/HTML&gt;&quot; }; } } nginx.conf配置location /basicAuth { access_handler_type 'java'; access_handler_name 'my.BasicAuthHandler'; .... } header filter 可拦截头信息，并作出相应的处理 Java handler类123456789101112131415package my;import nginx.clojure.java.NginxJavaRingHandler;import nginx.clojure.java.Constants;public class RemoveAndAddMoreHeaders implements NginxJavaHeaderFilter { @Override public Object[] doFilter(int status, Map&lt;String, Object&gt; request, Map&lt;String, Object&gt; responseHeaders) { responseHeaders.remove(&quot;Content-Type&quot;); responseHeaders.put(&quot;Content-Type&quot;, &quot;text/html&quot;); responseHeaders.put(&quot;Xfeep-Header&quot;, &quot;Hello2!&quot;); responseHeaders.put(&quot;Server&quot;, &quot;My-Test-Server&quot;); return Constants.PHASE_DONE; }} nginx.conf配置location /javafilter { header_filter_type 'java'; header_filter_name 'my.RemoveAndAddMoreHeaders '; .................. } body filter 可修改返回数据 Java handler类12345678910public static class StringFacedUppercaseBodyFilter extends StringFacedJavaBodyFilter { @Override protected Object[] doFilter(Map&lt;String, Object&gt; request, String body, boolean isLast) throws IOException { if (isLast) { return new Object[] {200, null, body.toUpperCase()}; }else { return new Object[] {null, null, body.toUpperCase()}; } }} nginx.conf配置location /hello { body_filter_type java; body_filter_name mytest.StringFacedUppercaseBodyFilter; } 更多使用场景 nginx-clojure能够获取和修改请求数据、响应数据、header信息等（基本上java servlet中能够获取和修改的数据，他也都能获取和修改），所以基于他，我们能够完成很多servlet能够完成的数据，甚至他能够连接mysql，redis等。 可操作的请求数据Server port Server-name Remote addr Uri Query String Scheme Request-method Protocol Content type Content length Character encoding Headers Body 可操作的相应数据Status Headers Body","link":"/2016/04/20/nginx-clojure%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"},{"title":"npm发布自己的包","text":"如果没有账号，那么使用npm adduser去创建账号，中间会引导你输入用户名、密码、邮箱。 如果已经有账号，需要使用npm login去登录，同样会引导你输入正确的用户名、密码、邮箱。 登录成功之后使用npm publish将自己的包发不上去。","link":"/2018/08/07/npm%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8C%85/"},{"title":"pypi 镜像使用帮助","text":"pypi 镜像每 5 分钟同步一次。 临时使用1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package 注意，simple 不能少, 是 https 而不是 http 设为默认升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置： 12pip install pip -Upip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 如果您到 pip 默认源的网络连接较差，临时使用本镜像站来升级 pip： 1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U","link":"/2019/04/03/pypi-%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/"},{"title":"shadowsocks go 一键安装","text":"本脚本适用环境：系统支持：CentOS，Debian，Ubuntu内存要求：≥128M日期：2015年08月01日 关于本脚本：一键安装 go 版的 shadowsocks 最新版本 1.1.4。据说 go 版本有 buff 。与 python 版不同的是，其客户端程序能使用多个服务端配置，本脚本安装的是服务端程序。作者默认推荐 aes-128-cfb 加密，基于一致性，脚本使用了 aes-256-cfb 加密方式。 默认配置：服务器端口：自己设定（如不设定，默认为 8989）客户端端口：1080密码：自己设定（如不设定，默认为teddysun.com） 客户端下载：http://sourceforge.net/projects/shadowsocksgui/files/dist/ 使用方法：使用root用户登录，运行以下命令： 123wget --no-check-certificate https://raw.githubusercontent.com/iMeiji/shadowsocks_install/master/shadowsocks-go.shchmod +x shadowsocks-go.sh./shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log 安装完成后，脚本提示如下：123456789Congratulations, shadowsocks-go install completed!Your Server IP:your_server_ipYour Server Port:your_server_portYour Password:your_passwordYour Local Port:1080Your Encryption Method:aes-256-cfbWelcome to visit:http://teddysun.com/392.htmlEnjoy it! 卸载方法：使用 root 用户登录，运行以下命令： 1./shadowsocks-go.sh uninstall 其他事项：客户端配置的参考链接：http://teddysun.com/339.html安装完成后即已后台启动 shadowsocks-go ，运行： 1/etc/init.d/shadowsocks status 可以查看 shadowsocks-go 进程是否已经启动。本脚本安装完成后，已将 shadowsocks-go 加入开机自启动。 使用命令：启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status 多用户多端口配置文件 sample（2015年01月08日）：配置文件路径：vi /etc/shadowsocks/config.json 1234567891011{ &quot;port_password&quot;:{ &quot;8989&quot;:&quot;password0&quot;, &quot;9001&quot;:&quot;password1&quot;, &quot;9002&quot;:&quot;password2&quot;, &quot;9003&quot;:&quot;password3&quot;, &quot;9004&quot;:&quot;password4&quot; }, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;timeout&quot;:600} 参考链接：https://github.com/shadowsocks/shadowsocks-gohttps://github.com/iMeiji/shadowsocks_install/wiki/shadowsocks-go-%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85","link":"/2019/12/24/shadowsocks-go-%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85/"},{"title":"xxx is not in the sudoers file解决方法","text":"用sudo时提示”xxx is not in the sudoers file. This incident will be reported.其中XXX是你的用户名，也就是你的用户名没有权限使用sudo,我们只要修改一下/etc/sudoers文件就行了。下面是修改方法： 进入超级用户模式。也就是输入”su -“,系统会让你输入超级用户密码，输入密码后就进入了超级用户模式。（当然，你也可以直接用root用） 添加文件的写权限。也就是输入命令chmod u+w /etc/sudoers。 编辑/etc/sudoers文件。也就是输入命令vim /etc/sudoers,输入”i”进入编辑模式，找到这一 行：root ALL=(ALL) ALL在起下面添加xxx ALL=(ALL) ALL(这里的xxx是你的用户名)，然后保存（就是先按一 下Esc键，然后输入”:wq”）退出。 撤销文件的写权限。也就是输入命令chmod u-w /etc/sudoers。","link":"/2019/11/28/xxx-is-not-in-the-sudoers-file%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"《倚天屠龙记》读后感","text":"看过各种版本的倚天屠龙记，最早看的是TVB吴启华版本的，后来是苏有朋版本的，再到到后来是邓超版本的。 作为一个原著党，我之前是看过一遍《倚天屠龙记》的。不止《倚天屠龙记》，金庸的书我基本上都看过。上一次看《倚天屠龙记》距离现在已经很久了，里面的情节很多已经都忘记了。前段时间在网上看到了一段描写郭襄的话，让我决定再看一遍《倚天屠龙记》，《倚天屠龙记》作为射雕三部曲的最后一部，郭襄是起到很重要的承上启下的作用的。 风陵渡口初相遇,一见杨过误终身。只恨我生君已老,断肠崖前忆故人。我走过山时，山不说话，我路过海时，海不说话，倚天剑伴我走天涯。大家都说我因为爱着杨过大侠，才在峨眉山上出了家，其实我只是爱上了峨眉山上的云和霞，像极了十六岁那年的烟花。 有纪念意义的是我读到第二卷的时候，金庸先生去世了。 …","link":"/2018/11/09/%E3%80%8A%E5%80%9A%E5%A4%A9%E5%B1%A0%E9%BE%99%E8%AE%B0%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"title":"一台丢失的iphone 续","text":"上篇内容：一台丢失的iphone 继昨天被我识破icloud密码骗取的钓鱼网站之后，骗子又来新招了。他往我的icloud对应的邮箱发来了一封邮件，开始时我是在手机上看到的邮件，差点就输入密码了，但是为了安全起见我还是打开电脑确认了下，也幸亏我确认了一下。邮件内容如下： 打开页面之后，就立马发现域名不对。 同样的，我也监控了下表单提交的请求，发现他的请求和上篇文章中讲的一样，302到http://www.id1111.pw","link":"/2016/02/03/%E4%B8%80%E5%8F%B0%E4%B8%A2%E5%A4%B1%E7%9A%84iphone%20%E7%BB%AD/"},{"title":"一台丢失的iphone","text":"败家娘们来武汉之后已经被偷了6000块钱了，不得不吐槽一下武汉的贼真他妈的多！第一次大概是一个多月之前，被偷了两千块现金。第二次是下雨我出去接她，手机就放在她口袋中，而且我们在通一把伞下，转眼的功夫手机就没了。为了不让爸妈知道了后心疼，当天晚上回去就又在网上买了部一样的iphone6土豪金，花了老子4000大洋，肾疼！！！ 手机丢了之后我就使用“查找iphone”功能将手机设置为丢失模式了，也不知道管不管用，也从来没用过，苹果手机号称安全，应该是管用的吧。 今天中午我收到了一条这样的短信，短信内容如下： 于是我就按照短信提示，打开了短信中的网址：http://www.icloud-ier.com。打开之后首先让我感到不对的地方是该页面的字体， 虽然这个登录页面和icloud的登录页面相识，但是他右下角的字体有点虚，icloud官网却没有。 作为一名有探索精神的程序员，于是我就随便提交了条数据看了下请求，请求如下： 居然将我的请求302到一个乱七八糟的URL，这个时候我就基本确认了，这是一个钓鱼网站！ 接下来，老子要写一个程序1000个线程，往死的给他提交垃圾数据，操！！！","link":"/2016/02/02/%E4%B8%80%E5%8F%B0%E4%B8%A2%E5%A4%B1%E7%9A%84iphone/"},{"title":"一年前的今天从北京转战武汉","text":"一年前的今天从北京转战武汉。","link":"/2016/11/14/%E4%B8%80%E5%B9%B4%E5%89%8D%E7%9A%84%E4%BB%8A%E5%A4%A9%E4%BB%8E%E5%8C%97%E4%BA%AC%E8%BD%AC%E6%88%98%E6%AD%A6%E6%B1%89/"},{"title":"一篇文章看懂when.js","text":"最近在拾起很久都没做过的前端，总结下When.js的最常用的场景。 场景1执行异步function a，当成功时执行function b，失败时执行function c，执行过程中需要回调function d来监控执行状态。 这个是最通用的用法，也是when.js中最长用到的，示例代码如下： 1234567891011121314151617181920212223function a () { var deferred = when.defer() for (var i = 0; i &lt; 100; i++) { try { deferred.notify(i++); } catch (err) { deferred.reject(e) } } deferred.resolve('成功消息') return deferred.promise;}a().then(function b(msg){ console.log('执行成功')}, function c(err){ console.log('执行失败')}, function d(i){ console.log('执行中...' + i)}) 总结：then有三个参数，分别是onFulfilled、onRejected、onProgress，通过这三个参数，就可以指定上一个任务在resolve、reject和notify时该如何处理。例如上一个任务被resolve(data)，onFulfilled函数就会被触发，data作为它的参数；被reject(reason)，那么onRejected就会被触发，收到reason。任何时候，onFulfilled和onRejected都只有其一可以被触发，并且只触发一次；onProgress顾名思义，每次notify时都会被调用。 场景2执行完function a，再执行function b；执行完function b，在执行function c。 1234567891011121314151617function a () { var deferred = when.defer() for (var i = 0; i &lt; 100; i++) { try { deferred.notify(i++); } catch (err) { deferred.reject(e) } } deferred.resolve('成功消息') return deferred.promise;}a().then(function b(){}).then(function c(){})","link":"/2017/03/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E7%9C%8B%E6%87%82when-js/"},{"title":"三亚三日游","text":"三亚几点印象： 天很蓝，水很清。 椰子真的不好喝，酸酸的，还没在武汉买的好喝。 商业化太严重，一双普通拖鞋能买100块，吃的喝的都挺贵的。 住的酒店挺好的，如果亲子游的话定个好点的酒店，就在酒店玩也挺好，酒店后面是海滩、酒店有游泳池、小朋友玩耍的地方。 最后要吐槽的是，住的酒店环境虽然很好，但是比较偏附近没啥好吃的，这次去肯德基吃的够够的…","link":"/2018/10/30/%E4%B8%89%E4%BA%9A%E4%B8%89%E6%97%A5%E6%B8%B8/"},{"title":"使用AppVeyor和Travis自动编译Electron全平台应用","text":"package.json配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283{ &quot;name&quot;: &quot;HexoClient&quot;, &quot;version&quot;: &quot;1.2.2&quot;, &quot;author&quot;: &quot;......&quot;, &quot;description&quot;: &quot;Hexo 桌面客户端&quot;, &quot;license&quot;: &quot;Apache License, Version 2.0&quot;, &quot;homepage&quot;: &quot;https://github.com/gaoyoubo/hexo-client&quot;, &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/gaoyoubo/hexo-client.git&quot; }, &quot;main&quot;: &quot;./dist/electron/main.js&quot;, &quot;scripts&quot;: { &quot;build&quot;: &quot;node .electron-vue/build.js &amp;&amp; electron-builder --publish onTagOrDraft&quot; ...... }, &quot;build&quot;: { &quot;appId&quot;: &quot;org.mspring.hexo.client&quot;, &quot;productName&quot;: &quot;HexoClient&quot;, &quot;directories&quot;: { &quot;output&quot;: &quot;build&quot; }, &quot;files&quot;: [ &quot;dist/electron/**/*&quot;, &quot;build/icons/*&quot; ], &quot;publish&quot;: { &quot;provider&quot;: &quot;github&quot;, &quot;owner&quot;: &quot;gaoyoubo&quot;, &quot;repo&quot;: &quot;hexo-client&quot; }, &quot;dmg&quot;: { &quot;contents&quot;: [ { &quot;x&quot;: 410, &quot;y&quot;: 150, &quot;type&quot;: &quot;link&quot;, &quot;path&quot;: &quot;/Applications&quot; }, { &quot;x&quot;: 130, &quot;y&quot;: 150, &quot;type&quot;: &quot;file&quot; } ] }, &quot;mac&quot;: { &quot;icon&quot;: &quot;build/icons/icon.icns&quot; }, &quot;win&quot;: { &quot;target&quot;: &quot;nsis&quot;, &quot;icon&quot;: &quot;build/icons/icon.ico&quot; }, &quot;linux&quot;: { &quot;category&quot;: &quot;Utility&quot;, &quot;target&quot;: [ { &quot;target&quot;: &quot;AppImage&quot;, &quot;arch&quot;: [ &quot;x64&quot;, &quot;ia32&quot; ] }, { &quot;target&quot;: &quot;deb&quot;, &quot;arch&quot;: [ &quot;x64&quot;, &quot;ia32&quot; ] }, { &quot;target&quot;: &quot;rpm&quot;, &quot;arch&quot;: [ &quot;x64&quot;, &quot;ia32&quot; ] } ], &quot;icon&quot;: &quot;build/icons&quot; } }, ......} build配置electron-builder支持构建多个平台安装包，上面的配置中我配置了Windows、macos、linux，可以直接拷贝使用，如果想了解更多可以看这篇官方出品的文档：https://www.electron.build/configuration/configuration 构建命令配置1node .electron-vue/build.js &amp;&amp; electron-builder --publish onTagOrDraft 可以看到后面的参数--publish onTagOrDraft他的意思是，当在标签中提交，或github中存在draft发布版本的时候触发publish操作，这个时候会自动将构建好的包上传到github releases中。publish配置的取值如下： Value Description onTag on tag push only onTagOrDraft on tag push or if draft release exists always always publish never never publish 参考： AppVeyor Travis electron-builder官方文档 https://github.com/gaoyoubo/hexo-client/issues/15 https://juejin.im/entry/5995599a6fb9a0249f6a131b","link":"/2018/11/26/%E4%BD%BF%E7%94%A8AppVeyor%E5%92%8CTravis%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91Electron%E5%85%A8%E5%B9%B3%E5%8F%B0%E5%BA%94%E7%94%A8/"},{"title":"使用nginx-clojure配置nginx负载均衡","text":"使用背景 最近遇到一个很困扰的问题，系统请求量变大了一台服务器已经扛不住了。于是我基于mq升级了我的服务，让我的服务能够支持横向扩展，通过mq服务完成各节点之间的通信。于是我们将服务部署到两个节点上，然后通过nginx随机将请求平均分发到两个节点。那么问题来了，在随机分发到两个节点之后服务器的CPU占用有所下降，但是内存占用却没有降下来。于是我们分析了一下原因，因为是随机分发，那么同一条数据请求两台服务器都会随机到，那么在这两台服务器上就会有相同的数据缓存，那么这样就会造成内存的浪费。于是我们就想办法根据请求的参数进行分发，保证同一条数据请求只会到同一台服务器。开始时我们用到了consistent_hash，但是我们客户端请求不规范有有些参数是放在POST请求中的，consistent_hash是无法根据POST请求中的参数进行hash，然后分发。于是在网上搜索了很多资料，直到我找到了nginx-clojure。选nginx-clojure是因为他可以用我熟悉的语言写插件：Java。安装配置 安装nginx-clojure插件下载nginx和nginx-clojure源码，分别去他们的官网下载就可以，然后将他们解压、编译、安装。脚本如下： 123./configure --prefix=/usr/local/nginx --add-module=nginx-clojure安装模块makesudo make install 配置nginx-clojure在nginx.conf中 12345### 建议这里查看官方文档，比较详细### 官方文档地址：http://nginx-clojure.github.io/configuration.html#21-jvm-path--class-path--other-jvm-optionsjvm_path auto;# 这个是classpath需要用到的jar包都需要加入到classpath中。jvm_classpath &quot;/usr/local/nginx/libs/nginx-clojure-0.4.4/jars/*:/Users/gaoyoubo/work/dianping-service/dianping-nginx/target/dianping-nginx-2.0.1-SNAPSHOT.jar&quot;; 配置自己的location12345678910111213set $node &quot;&quot;;location / { # 加上他会读取POST请求数据，不需要的时候建议关掉 always_read_body on; # handler类型，nginx-clojure支持三种：clojure、groovy、java，这里主要讲解java rewrite_handler_type 'java'; # 这里是处理类 rewrite_handler_name 'cn.mucang.dianping.nginx.DianpingRewriteHandler'; proxy_pass $node; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;} 编写处理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package cn.mucang.dianping.nginx;import nginx.clojure.NativeInputStream;import nginx.clojure.NginxClojureRT;import nginx.clojure.java.Constants;import nginx.clojure.java.NginxJavaRequest;import nginx.clojure.java.NginxJavaRingHandler;import org.apache.commons.collections.MapUtils;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.StringUtils;import java.io.IOException;import java.net.URLDecoder;import java.util.HashMap;import java.util.Map;import java.util.Random;/** * @author Gao Youbo * @since 2016-03-17 15:02 */public class DianpingRewriteHandler implements NginxJavaRingHandler { public static final String KEY_URI = &quot;uri&quot;; public static final String KEY_BODY = &quot;body&quot;; public static final String KEY_REQUEST_METHOD = &quot;request-method&quot;; public static final String KEY_QUERY_STRING = &quot;query-string&quot;; public static final String ENCODING = &quot;UTF-8&quot;; public static final Map NODES = new HashMap(); public static final int NODE_SIZE = 2; public static final String MASTER_NODE = &quot;node1&quot;; public static final String SALVE_NODE = &quot;node2&quot;; private static final Random R = new Random(); static { NODES.put(0, MASTER_NODE); NODES.put(1, SALVE_NODE); } public Object[] invoke(Map requestMap) throws IOException { long start = System.currentTimeMillis(); Map params = getParams(requestMap); // 所有的请求参数包括GET和POST String node = getNode(requestMap); NginxJavaRequest request = (NginxJavaRequest) requestMap; request.setVariable(&quot;node&quot;, normalizeNode(node)); long elasped = System.currentTimeMillis() - start; NginxClojureRT.log.info(String.format(&quot;[gaoyoubo] elasped:%s ms, node=%s, uri:%s, elasped, node, uri)); return Constants.PHASE_DONE; } /** * 计算当前请求应该走哪个节点 * * @param requestMap * @return */ private String getNode(Map requestMap) { // 业务逻辑 } private String normalizeNode(String node) { return &quot;http://&quot; + node; } /** * 获取请求参数, 包括GET和POST * * @param requestMap * @return */ private Map getParams(Map requestMap) { Map params = new HashMap&lt;&gt;(); try { params.putAll(getGetParams(requestMap)); params.putAll(getPostParams(requestMap)); } catch (Exception e) { NginxClojureRT.log.error(&quot;获取请求参数失败&quot;, e); } return params; } /** * 获取GET请求参数 * * @param requestMap * @return */ private Map getGetParams(Map requestMap) { String queryString = MapUtils.getString(requestMap, KEY_QUERY_STRING); return buildQuerys(queryString); } /** * 获取POST请求参数 * * @param requestMap * @return */ private Map getPostParams(Map requestMap) throws IOException { String requestMethod = MapUtils.getString(requestMap, KEY_REQUEST_METHOD); if (StringUtils.equalsIgnoreCase(requestMethod, &quot;POST&quot;)) { // 如果是POST请求,那么处理下POST参数 Object bodyObj = requestMap.get(KEY_BODY); if (bodyObj != null) { NativeInputStream nis = (NativeInputStream) bodyObj; String body = IOUtils.toString(nis, ENCODING); return buildQuerys(body); } } return new HashMap&lt;&gt;(); } /** * 将字符串格式的参数转换成Map * * @param queryString * @return */ private Map buildQuerys(String queryString) { Map params = new HashMap&lt;&gt;(); if (StringUtils.isBlank(queryString)) { return params; } String[] kvs = queryString.split(&quot;&amp;&quot;); if (kvs != null) { for (String kv : kvs) { String[] pair = kv.split(&quot;\\\\=&quot;, 2); if (pair.length == 2) { params.put(pair[0], urlDecode(pair[1], ENCODING)); } } } return params; } private String urlDecode(String s, String encoding) { try { return URLDecoder.decode(s, encoding); } catch (Exception ex) { NginxClojureRT.log.error(null, ex); } return s; }}","link":"/2016/04/19/%E4%BD%BF%E7%94%A8nginx-clojure%E9%85%8D%E7%BD%AEnginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"title":"修改mariadb的datadir","text":"目标：将mariadb默认的datadir（/var/lib/mysql）迁移到/data/mysql 停止mariadb服务1systemctl stop mariadb 创建新datadir12mkdir /data/mysqlchown -R mysql:mysql /data/mysql 将数据文件复制过来1cp -a /var/lib/mysql /data/mysql 修改配置123456vi /etc/my.cnf[mysqld]# datadir=/var/lib/mysql# 注释掉之前的，将datadir设置成新目录datadir=/data/mysql 重新启动mariadb服务1systemctl start mariadb","link":"/2019/06/05/%E4%BF%AE%E6%94%B9mariadb%E7%9A%84datadir/"},{"title":"儿童房装修","text":"小姑娘下半年要来武汉上小学了，提前将她的房间装修下。","link":"/2019/02/25/%E5%84%BF%E7%AB%A5%E6%88%BF%E8%A3%85%E4%BF%AE/"},{"title":"包装类值判断异常","text":"复现代码123456789public class Test { public static void main(String[] args) { for (int i = 120; i &lt; 130; i++) { Integer a = i; Integer b = i; System.out.println(&quot;a == b: &quot; + (a == b)); } }} 输出结果12345678910a == b: truea == b: truea == b: truea == b: truea == b: truea == b: truea == b: truea == b: truea == b: falsea == b: false 原因分析123==是用来比较两个基本数据类型的变量值是否相等，==也用于判断两个对象引用名称是否参考至同一个对象。在自动装箱时对于值从–128到127之间的值，它们被装箱为Integer对象后，会存在内存中被重用(就是说内存指向相同)，所以造成 System.out.println(a == b); 输出true如果超过了从–128到127之间的值，被装箱后的Integer对象并不会被重用（指向了新的内存地址），即相当于每次装箱时都新建一个Integer对象所以 System.out.println(&quot;a == b: &quot; + (a == b));输出false总结：–128到127之间的值内存空间引用的是同一个地址，超出则存在新的内存空间","link":"/2017/09/26/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%80%BC%E5%88%A4%E6%96%AD/"},{"title":"北京植物园","text":"狠心将小朋友放在家，我们两个单独跑出去玩的。","link":"/2014/03/24/%E5%8C%97%E4%BA%AC%E6%A4%8D%E7%89%A9%E5%9B%AD/"},{"title":"十一嘉兴高艺涵","text":"放假的时间过的就是快。。。","link":"/2013/10/08/%E5%8D%81%E4%B8%80%E5%98%89%E5%85%B4%E9%AB%98%E8%89%BA%E6%B6%B5/"},{"title":"十八岁生日快乐","text":"正是江南好风景,落花时节又逢君。十八岁生日老婆不在身边，两位久别好友陪我过。一直陪我从十七岁的最后一晚上，陪我到十八岁的第一个凌晨。很高兴我们都从北京都转移到武汉了，以后大家又都在一起了。","link":"/2017/04/01/%E5%8D%81%E5%85%AB%E5%B2%81%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/"},{"title":"十月一日嘉兴的干活","text":"我老婆和女儿9月21号先过去开路，哥十月一日也过去。去吃一下传说中的牛蛙煲！","link":"/2013/09/17/%E5%8D%81%E6%9C%88%E4%B8%80%E6%97%A5%E5%98%89%E5%85%B4%E7%9A%84%E5%B9%B2%E6%B4%BB/"},{"title":"半径范围内随机经纬度","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private static final double EARTH_RADIUS = 6372.796924;public static GpsInfo getRandomLocation(GpsInfo center, double distance) { if (distance &lt;= 0) distance = 50; double lat, lon, brg; distance = distance / 1000; GpsInfo location = new GpsInfo(); double maxdist = distance; maxdist = maxdist / EARTH_RADIUS; double startlat = rad(center.getLat()); double startlon = rad(center.getLon()); double cosdif = Math.cos(maxdist) - 1; double sinstartlat = Math.sin(startlat); double cosstartlat = Math.cos(startlat); double dist; double rad360 = 2 * Math.PI; dist = Math.acos((new Random().nextDouble() * cosdif + 1)); brg = rad360 * new Random().nextDouble(); lat = Math.asin(sinstartlat * Math.cos(dist) + cosstartlat * Math.sin(dist) * Math.cos(brg)); lon = deg(normalizeLongitude(startlon * 1 + Math.atan2(Math.sin(brg) * Math.sin(dist) * cosstartlat, Math.cos(dist) - sinstartlat * Math.sin(lat)))); lat = deg(lat); location.setLat(padZeroRight(lat)); location.setLon(padZeroRight(lon)); return location;}static double rad(double d) { return d * Math.PI / 180.0;}static double deg(double rd) { return (rd * 180 / Math.PI);}static double normalizeLongitude(double lon) { double n = Math.PI; if (lon &gt; n) { lon = lon - 2 * n; } else if (lon &lt; -n) { lon = lon + 2 * n; } return lon;}static double padZeroRight(double s) { double sigDigits = 8; s = Math.round(s * Math.pow(10, sigDigits)) / Math.pow(10, sigDigits); return s;}","link":"/2019/04/03/%E5%8D%8A%E5%BE%84%E8%8C%83%E5%9B%B4%E5%86%85%E9%9A%8F%E6%9C%BA%E7%BB%8F%E7%BA%AC%E5%BA%A6/"},{"title":"协同过滤和基于内容推荐有什么区别？","text":"根据数据源的不同推荐引擎可以分为三类1、基于人口的统计学推荐(Demographic-based Recommendation) 2、基于内容的推荐(Content-based Recommendation) 3、基于协同过滤的推荐(Collaborative Filtering-based Recommendation) 基于内容的推荐：根据物品或内容的元数据，发现物品或内容的相关性，然后基于用户以前的喜好记录推荐给用户相似的物品，如图所示：上图给出了基于内容推荐的一个典型的例子，电影推荐系统，首先我们需要对电影的元数据有一个建模，这里只简单的描述了一下电影的类型；然后通过电影的元数据发现电影间的相似度，因为类型都是“爱情，浪漫”电影 A 和 C 被认为是相似的电影（当然，只根据类型是不够的，要得到更好的推荐，我们还可以考虑电影的导演，演员等等）；最后实现推荐，对于用户 A，他喜欢看电影 A，那么系统就可以给他推荐类似的电影 C。 而基于协同过滤推荐又分为以下三类：(1)基于用户的协同过滤推荐(User-based Collaborative Filtering Recommendation) 基于用户的协同过滤推荐算法先使用统计技术寻找与目标用户有相同喜好的邻居，然后根据目标用户的邻居的喜好产生向目标用户的推荐。基本原理就是利用用户访问行为的相似性来互相推荐用户可能感兴趣的资源，如图所示：上图示意出基于用户的协同过滤推荐机制的基本原理，假设用户 A 喜欢物品 A、物品 C，用户 B 喜欢物品 B，用户 C 喜欢物品 A 、物品 C 和物品 D；从这些用户的历史喜好信息中，我们可以发现用户 A 和用户 C 的口味和偏好是比较类似的，同时用户 C 还喜欢物品 D，那么我们可以推断用户 A 可能也喜欢物品 D，因此可以将物品 D 推荐给用户 A。 (2)基于项目的协同过滤推荐(Item-based Collaborative Filtering Recommendation) 根据所有用户对物品或者信息的评价，发现物品和物品之间的相似度，然后根据用户的历史偏好信息将类似的物品推荐给该用户，如图所示：上图表明基于项目的协同过滤推荐的基本原理，用户A喜欢物品A和物品C，用户B喜欢物品A、物品B和物品C，用户C喜欢物品A，从这些用户的历史喜好中可以认为物品A与物品C比较类似，喜欢物品A的都喜欢物品C，基于这个判断用户C可能也喜欢物品C，所以推荐系统将物品C推荐给用户C。 (3)基于模型的协同过滤推荐(Model-based Collaborative Filtering Recommendation) 基模型的协同过滤推荐就是基于样本的用户喜好信息，训练一个推荐模型，然后根据实时的用户喜好的信息进行预测推荐。 综上所述：基于内容的推荐只考虑了对象的本身性质，将对象按标签形成集合，如果你消费集合中的一个则向你推荐集合中的其他对象； 基于协同过滤的推荐算法，充分利用集体智慧，即在大量的人群的行为和数据中收集答案，以帮助我们对整个人群得到统计意义上的结论，推荐的个性化程度高，基于以下两个出发点：(1)兴趣相近的用户可能会对同样的东西感兴趣；(2)用户可能较偏爱与其已购买的东西相类似的商品。也就是说考虑进了用户的历史习惯，对象客观上不一定相似，但由于人的行为可以认为其主观上是相似的，就可以产生推荐了。 以上答案只是参考IBM官网资料探索推荐引擎内部的秘密，第 1 部分: 推荐引擎初探，然后结合其他资料理解总结的，如有更好意见谢谢分享。","link":"/2019/07/19/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E5%92%8C%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E6%8E%A8%E8%8D%90%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"},{"title":"周六游圆明园","text":"周六涵涵小姨过来了，加上天气还好。我们就去圆明园逛了一圈，没有想到桃花竟然开了。春天来了，心情也好了！","link":"/2015/03/22/%E5%91%A8%E5%85%AD%E6%B8%B8%E5%9C%86%E6%98%8E%E5%9B%AD/"},{"title":"周末烧烤","text":"上周末买了烧烤架、羊腿，回家折腾烧烤，第一次自己腌肉烧烤，味道还不错。","link":"/2018/12/03/%E5%91%A8%E6%9C%AB%E7%83%A7%E7%83%A4/"},{"title":"命令行推送Jar包到nexus","text":"1mvn deploy:deploy-file -DgroupId=com.tencent -DartifactId=xinge -Dversion=1.1.8 -Dpackaging=jar -DrepositoryId=nexus -Dfile=/Users/gaoyoubo/xinge-push.jar -Durl=http://xxx.xxx.com:8081/nexus/content/repositories/thirdparty/ -DgeneratePom=false","link":"/2018/04/10/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8E%A8%E9%80%81Jar%E5%8C%85%E5%88%B0nexus/"},{"title":"喝醉了","text":"今天应该算我有史以来喝的最多的一次，一杯白酒加三瓶多啤酒。。。 喝的我直接睡觉觉了。。。","link":"/2015/02/21/%E5%96%9D%E9%86%89%E4%BA%86/"},{"title":"在命令行中压缩图片","text":"今天有需求将一些非常大的图片压缩一下，本来想自己写代码进行压缩的，但是觉得这是一个非常常见的需求，应该有现成的解决方案，于是Google了一下，找到了这两个工具：jpegoptim、optipng 安装我是在MacOS中安装的，Linux上应该也有这个两个工具，请自行摸索 我使用的是brew进行安装，命令如下： 12brew install jpegoptimbrew install optipng jpegoptim 使用12345678# 压缩jpegoptim file.jpg# 指定大小压缩jpegoptim --size=1024k file.jpg# 移除Exif信息jpegoptim --strip-exif file.jpg optipng 使用1optipng file.png","link":"/2020/10/27/%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"},{"title":"多个Github账号时，怎么配置sshkey","text":"我有两个Github账号，在配置sshkey的时候是会提示Key is already in use。因为github无法将相同的sshkey配置到不同的账号下，那么就要考虑同一台机器如何配置两个sshkey了。 生成第二个sshkey因为之前已经存在~/.ssh/id_rsa文件，所以这次生成的时候我们指定输出的文件名为id_rsa2 1ssh-keygen -t rsa -C &quot;example@example.com&quot; -f ~/.ssh/id_rsa2 创建config配置文件在~/.ssh/目录下创建config配置文件，内容如下，里面有详细的解释。 1234567891011# 原有的配置Host github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa# 第二个配置Host github_2.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa2 # 这里指定下所使用的公钥文件名，就是我们上一步新生成的那个。 使用第二个sshkey配置假如我们的仓库地址为：git@github.com:name/project.git ，那么按照上面config文件中Host的配置，需要将仓库地址修改为：git@github_2.com:name/project.git，修改git沧湖远程url的命令如下： 1git remote set-url origin git@github_2.com:name/project.git","link":"/2019/06/24/%E5%A4%9A%E4%B8%AAGithub%E8%B4%A6%E5%8F%B7%E6%97%B6%EF%BC%8C%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AEsshkey/"},{"title":"大年夜","text":"2014年的大年夜，抽时间来冒个泡。希望明年能够完成我2014年的愿望！也祝各位新年快乐。 我在想要不要现在还去写段代码，为我苦逼的2014年画上一个句号。","link":"/2015/02/18/%E5%A4%A7%E5%B9%B4%E5%A4%9C/"},{"title":"如何将 Debian Linux 中的默认的 Python 版本切换为替代版本","text":"当你安装 Debian Linux 时，安装过程有可能同时为你提供多个可用的 Python 版本，因此系统中会存在多个 Python 的可执行二进制文件。你可以按照以下方法使用 ls 命令来查看你的系统中都有那些 Python 的二进制文件可供使用。 12$ ls /usr/bin/python*/usr/bin/python /usr/bin/python2 /usr/bin/python2.7 /usr/bin/python3 /usr/bin/python3.4 /usr/bin/python3.4m /usr/bin/python3m 执行如下命令查看默认的 Python 版本信息: 12$ python --versionPython 2.7.8 1、基于用户修改 Python 版本：想要为某个特定用户修改 Python 版本，只需要在其 home 目录下创建一个 alias(别名) 即可。打开该用户的 ~/.bashrc 文件，添加新的别名信息来修改默认使用的 Python 版本。 1alias python='/usr/bin/python3.4' 一旦完成以上操作，重新登录或者重新加载 .bashrc 文件，使操作生效。 1$ . ~/.bashrc 检查当前的 Python 版本。 12$ python --versionPython 3.4.2 2、 在系统级修改 Python 版本我们可以使用 update-alternatives 来为整个系统更改 Python 版本。以 root 身份登录，首先罗列出所有可用的 python 替代版本信息： 12# update-alternatives --list pythonupdate-alternatives: error: no alternatives for python 如果出现以上所示的错误信息，则表示 Python 的替代版本尚未被 update-alternatives 命令识别。想解决这个问题，我们需要更新一下替代列表，将 python2.7 和 python3.4 放入其中。 1234# update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1 update-alternatives: using /usr/bin/python2.7 to provide /usr/bin/python (python) in auto mode# update-alternatives --install /usr/bin/python python /usr/bin/python3.4 2 update-alternatives: using /usr/bin/python3.4 to provide /usr/bin/python (python) in auto mode --install 选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中。这个例子中，我们为 /usr/bin/python3.4 设置的优先级为2，所以 update-alternatives 命令会自动将它设置为默认 Python 版本。 12# python --versionPython 3.4.2 接下来，我们再次列出可用的 Python 替代版本。 123# update-alternatives --list python/usr/bin/python2.7/usr/bin/python3.4 现在开始，我们就可以使用下方的命令随时在列出的 Python 替代版本中任意切换了。 1# update-alternatives --config python 12# python --versionPython 2.7.8 3、移除替代版本一旦我们的系统中不再存在某个 Python 的替代版本时，我们可以将其从 update-alternatives 列表中删除掉。例如，我们可以将列表中的 python2.7 版本移除掉。 123# update-alternatives --remove python /usr/bin/python2.7update-alternatives: removing manually selected alternative - switching python to auto modeupdate-alternatives: using /usr/bin/python3.4 to provide /usr/bin/python (python) in auto mode","link":"/2018/02/23/%E5%A6%82%E4%BD%95%E5%B0%86-Debian-Linux-%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E7%9A%84-Python-%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2%E4%B8%BA%E6%9B%BF%E4%BB%A3%E7%89%88%E6%9C%AC/"},{"title":"宝宝两周岁","text":"祝小宝宝越来越聪明、漂亮，一直都这么开心健康。","link":"/2015/04/27/%E5%AE%9D%E5%AE%9D%E4%B8%A4%E5%91%A8%E5%B2%81/"},{"title":"宝宝今天半岁了","text":"都说孩子在别人家长的快，终于体会到了，我的小艺涵今天终于也半岁了！来两张照片纪念一下！","link":"/2013/10/13/%E5%AE%9D%E5%AE%9D%E4%BB%8A%E5%A4%A9%E5%8D%8A%E5%B2%81%E4%BA%86/"},{"title":"宝宝的第一次旋转木马","text":"上周末带涵涵去超市，路过旁边的旋转木马，她看的高兴的不得了。从超市出来之后也带她坐了一下。刚上去还好，但是转起来之后她就害怕了，我只好把她抱起来。她把我抱的紧紧的，小朋友就是可爱，瞬间能让你有种当父亲的责任感。","link":"/2014/06/25/%E5%AE%9D%E5%AE%9D%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%97%8B%E8%BD%AC%E6%9C%A8%E9%A9%AC/"},{"title":"小可可周岁啦","text":"","link":"/2018/05/02/%E5%B0%8F%E5%8F%AF%E5%8F%AF%E5%91%A8%E5%B2%81%E5%95%A6/"},{"title":"小米手机安装Charles证书","text":"平时使用Charles进行接口抓包，新换小米手机之后发现按照之前的流程安装Charles ssl证书不好使，百度了好久才找到一下解决办法。 使用第三方浏览器（我用的是QQ浏览器）下载.pem 格式的文件 将这个文件放入小米的Download文件夹下 将.pem文件修改为.crt 格式 设置—更多设置—系统安全—加密与凭据—从存储设备安装–选择Download文件夹下的文件 Finish~~","link":"/2018/08/27/%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA%E5%AE%89%E8%A3%85Charles%E8%AF%81%E4%B9%A6/"},{"title":"已购房，坐等交房","text":"","link":"/2014/10/20/%E5%B7%B2%E8%B4%AD%E6%88%BF%EF%BC%8C%E5%9D%90%E7%AD%89%E4%BA%A4%E6%88%BF/"},{"title":"并发队列-无界阻塞延迟队列DelayQueue原理探究","text":"12转载自：http://ifeve.com/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97-%E6%97%A0%E7%95%8C%E9%98%BB%E5%A1%9E%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97delayqueue%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/最近在开发中正好有类似场景。 前言DelayQueue队列中每个元素都有个过期时间，并且队列是个优先级队列，当从队列获取元素时候，只有过期元素才会出队列。 DelayQueue类图结构 如图DelayQueue中内部使用的是PriorityQueue存放数据，使用ReentrantLock实现线程同步，可知是阻塞队列。另外队列里面的元素要实现Delayed接口，一个是获取当前剩余时间的接口，一个是元素比较的接口，因为这个是有优先级的队列。 offer操作插入元素到队列，主要插入元素要实现Delayed接口。 1234567891011121314public boolean offer(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { q.offer(e); if (q.peek() == e) {（2） leader = null; available.signal(); } return true; } finally { lock.unlock(); }} 首先获取独占锁，然后添加元素到优先级队列，由于q是优先级队列，所以添加元素后，peek并不一定是当前添加的元素，如果（2）为true，说明当前元素e的优先级最小也就即将过期的，这时候激活avaliable变量条件队列里面的线程，通知他们队列里面有元素了。 take操作获取并移除队列首元素，如果队列没有过期元素则等待。 123456789101112131415161718192021222324252627282930313233public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { for (;;) { //获取但不移除队首元素（1) E first = q.peek(); if (first == null) available.await();//(2) else { long delay = first.getDelay(TimeUnit.NANOSECONDS); if (delay &lt;= 0)//(3) return q.poll(); else if (leader != null)//(4) available.await(); else { Thread thisThread = Thread.currentThread(); leader = thisThread;//(5) try { available.awaitNanos(delay); } finally { if (leader == thisThread) leader = null; } } } } } finally { if (leader == null &amp;&amp; q.peek() != null)//(6) available.signal(); lock.unlock(); } } 第一次调用take时候由于队列空，所以调用（2）把当前线程放入available的条件队列等待，当执行offer并且添加的元素就是队首元素时候就会通知最先等待的线程激活，循环重新获取队首元素，这时候first假如不空，则调用getdelay方法看该元素海剩下多少时间就过期了，如果delay&lt;=0则说明已经过期，则直接出队返回。否者看leader是否为null，不为null则说明是其他线程也在执行take则把该线程放入条件队列，否者是当前线程执行的take方法，则调用(5)await直到剩余过期时间到（这期间该线程会释放锁，所以其他线程可以offer添加元素，也可以take阻塞自己），剩余过期时间到后，该线程会重新竞争得到锁，重新进入循环。 （6）说明当前take返回了元素，如果当前队列还有元素则调用singal激活条件队列里面可能有的等待线程。leader那么为null，那么是第一次调用take获取过期元素的线程，第一次调用的线程调用设置等待时间的await方法等待数据过期，后面调用take的线程则调用await直到signal。 poll操作获取并移除队头过期元素，否者返回null 1234567891011121314public E poll() { final ReentrantLock lock = this.lock; lock.lock(); try { E first = q.peek(); //如果队列为空，或者不为空但是队头元素没有过期则返回null if (first == null || first.getDelay(TimeUnit.NANOSECONDS) &gt; 0) return null; else return q.poll(); } finally { lock.unlock(); }} 一个例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class DelayedEle implements Delayed { private final long delayTime; //延迟时间 private final long expire; //到期时间 private String data; //数据 public DelayedEle(long delay, String data) { delayTime = delay; this.data = data; expire = System.currentTimeMillis() + delay; } /** * 剩余时间=到期时间-当前时间 */ @Override public long getDelay(TimeUnit unit) { return unit.convert(this.expire - System.currentTimeMillis() , TimeUnit.MILLISECONDS); } /** * 优先队列里面优先级规则 */ @Override public int compareTo(Delayed o) { return (int) (this.getDelay(TimeUnit.MILLISECONDS) -o.getDelay(TimeUnit.MILLISECONDS)); } @Override public String toString() { final StringBuilder sb = new StringBuilder(&quot;DelayedElement{&quot;); sb.append(&quot;delay=&quot;).append(delayTime); sb.append(&quot;, expire=&quot;).append(expire); sb.append(&quot;, data='&quot;).append(data).append('\\''); sb.append('}'); return sb.toString(); }}public static void main(String[] args) { DelayQueue&lt;DelayedEle&gt; delayQueue = new DelayQueue&lt;DelayedEle&gt;(); DelayedEle element1 = new DelayedEle(1000,&quot;zlx&quot;); DelayedEle element2 = new DelayedEle(1000,&quot;gh&quot;); delayQueue.offer(element1); delayQueue.offer(element2); element1 = delayQueue.take(); System.out.println(element1);} 使用场景TimerQueue的内部实现ScheduledThreadPoolExecutor中DelayedWorkQueue是对其的优化使用","link":"/2018/03/31/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97-%E6%97%A0%E7%95%8C%E9%98%BB%E5%A1%9E%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97DelayQueue%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"title":"微信红包的架构设计简介","text":"转载自：http://colobu.com/2015/05/04/weixin-red-packets-design-discussion/ 背景：有某个朋友在朋友圈咨询微信红包的架构，于是乎有了下面的文字（有误请提出，谢谢）概况：2014年微信红包使用数据库硬抗整个流量，2015年使用cache抗流量。 微信的金额什么时候算？答：微信金额是拆的时候实时算出来，不是预先分配的，采用的是纯内存计算，不需要预算空间存储。采取实时计算金额的考虑：预算需要占存储，实时效率很高，预算才效率低。 实时性：为什么明明抢到红包，点开后发现没有？答：2014年的红包一点开就知道金额，分两次操作，先抢到金额，然后再转账。2015年的红包的拆和抢是分离的，需要点两次，因此会出现抢到红包了，但点开后告知红包已经被领完的状况。进入到第一个页面不代表抢到，只表示当时红包还有。 分配：红包里的金额怎么算？为什么出现各个红包金额相差很大？答：随机，额度在0.01和剩余平均值 * 2之间。 例如：发100块钱，总共10个红包，那么平均值是10块钱一个，那么发出来的红包的额度在0.01元～20元之间波动。当前面3个红包总共被领了40块钱时，剩下60块钱，总共7个红包，那么这7个红包的额度在：0.01～（60/7 * 2）=17.14之间。注意：这里的算法是每被抢一个后，剩下的会再次执行上面的这样的算法（Tim老师也觉得上述算法太复杂，不知基于什么样的考虑）。 这样算下去，会超过最开始的全部金额，因此到了最后面如果不够这么算，那么会采取如下算法：保证剩余用户能拿到最低1分钱即可。如果前面的人手气不好，那么后面的余额越多，红包额度也就越多，因此实际概率一样的。 红包的设计答：微信从财付通拉取金额数据过来，生成个数/红包类型/金额放到redis集群里，app端将红包ID的请求放入请求队列中，如果发现超过红包的个数，直接返回。根据红包的逻辑处理成功得到令牌请求，则由财付通进行一致性调用，通过像比特币一样，两边保存交易记录，交易后交给第三方服务审计，如果交易过程中出现不一致就强制回归。 并发性处理：红包如何计算被抢完？答：cache会抵抗无效请求，将无效的请求过滤掉，实际进入到后台的量不大。cache记录红包个数，原子操作进行个数递减，到0表示被抢光。财付通按照20万笔每秒入账准备，但实际还不到8万每秒。 通如何保持8w每秒的写入？答：多主sharding，水平扩展机器。 数据容量多少？答：一个红包只占一条记录，有效期只有几天，因此不需要太多空间。 查询红包分配，压力大不？答：抢到红包的人数和红包都在一条cache记录上，没有太大的查询压力。 一个红包一个队列？答：没有队列，一个红包一条数据，数据上有一个计数器字段。 有没有从数据上证明每个红包的概率是不是均等？答：不是绝对均等，就是一个简单的拍脑袋算法。 拍脑袋算法，会不会出现两个最佳？答：会出现金额一样的，但是手气最佳只有一个，先抢到的那个最佳。 每领一个红包就更新数据么？答：每抢到一个红包，就cas更新剩余金额和红包个数。 红包如何入库入账？数据库会累加已经领取的个数与金额，插入一条领取记录。入账则是后台异步操作。 入帐出错怎么办？比如红包个数没了，但余额还有？答：最后会有一个take all操作。另外还有一个对账来保障。 下面这张图是@周帆 同学的杰作！","link":"/2018/04/27/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/"},{"title":"我曾七次鄙视自己的灵魂","text":"知乎上看到的一段话，虽然本人不太喜欢鸡汤文，但是觉得这篇文章说的自己基本上都遇到过，共勉吧。 123原文：给你启发最大的一段话是什么？ - Daisy的回答 - 知乎https://www.zhihu.com/question/28385545/answer/40608814 我曾七次鄙视自己的灵魂:第一次，当它本可进取时，却故作谦卑；第二次，当它在空虚时，用爱欲来填充；第三次，在困难和容易之间，它选择了容易；第四次，它犯了错，却借由别人也会犯错来宽慰自己；第五次，它自由软弱，却把它认为是生命的坚韧；第六次，当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副；第七次，它侧身于生活的污泥中，虽不甘心，却又畏首畏尾。","link":"/2018/10/12/%E6%88%91%E6%9B%BE%E4%B8%83%E6%AC%A1%E9%84%99%E8%A7%86%E8%87%AA%E5%B7%B1%E7%9A%84%E7%81%B5%E9%AD%82/"},{"title":"批量拉取代码","text":"场景：目录中有多个git项目，想要更新批量拉取一下这些项目的最新代码。 实现如下： 1234567891011121314#!/bin/shfor dir in $(ls -d */); do cd $dir if [ -d &quot;.git&quot; ]; then branch=$(git symbolic-ref --short -q HEAD) if [ &quot;$branch&quot; != &quot;master&quot; ]; then echo &quot;skip $dir branch: $branch&quot; else echo &quot;dir:$dir branch: $branch&quot; git pull origin $branch fi fi cd ..done 扫码目录下的所有项目，如果发现当前项目在master分支，那么pull一下代码。","link":"/2021/06/10/%E6%89%B9%E9%87%8F%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"},{"title":"搬瓦工使用笔记","text":"之前一直使用朋友的vpn进行翻墙，今天突然发现用不了了，同事强烈推荐使用搬瓦工（ https://bwh8.net ），他们反馈很稳定。于是就去官网上买了一个最低配的，配置如下： 123456SSD: 10 GB RAID-10RAM: 512 MBCPU: 1x Intel XeonTransfer: 500 GB/moLink speed: 1 GigabitMultiple locations 价格：$19.99/year 购买的时候可以输入优惠码，优惠码自行百度去，有很多资源。我找了个优惠码，优惠了6.25% 接下来就是配置Shadowsocks Server了， 之前网上的教程中都会看到虚拟机vps的控制台会有一个Shadowsocks Server的选项，进去之后能够一键安装配置该服务，但是我的控制台却没有这个选项，在网上找到了下面一段话。 注：最近很多新购买的服务器在VPS管理面板没有“Shadowsocks server”这一项，若是发生此原因，请按如下操作即可正常安装！若页面中没有Shadowsocks Server这一项，说明一键搭建SS功能被去掉了，这时候需要在当前浏览器的新标签中打开以下网址：https://kiwivm.64clouds.com/main-exec.php?mode=extras_shadowsocks 打开以后就是安装页面，点击页面中的Install Shadowsocks Server安装即可(安装前提是服务器已打开已运行)。 目前已经按照上面链接中的步骤搞定翻墙了。 另外附上Shadowsocks-NG下载地址：https://github.com/shadowsocks/ShadowsocksX-NG/releases","link":"/2018/11/07/%E6%90%AC%E7%93%A6%E5%B7%A5%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"title":"搭建Shadowsocks-Server","text":"之前一直使用的搬瓦工的vps搭建的shadowsocks，但是最近被封掉了。正好手里还有一台阿里云香港服务器，所以就自己搭建了一个，下面是搭建流程。 我是使用shadowsocks-go进行搭建的，是基于golang编写的，所以先需要安装golang环境，请自行安装。 shadowsocks-go项目地址：https://github.com/shadowsocks/shadowsocks-go 安装方式： 1go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server 安装完成之后请在：$GOPATH/bin 目录下找到：shadowsocks-server 文件。 然后在该文件同文件夹下创建配置文件：config.json，密码端口请自行修改，我们这里使用的服务端端口为：8388 123456789{ &quot;server&quot;:&quot;127.0.0.1&quot;, &quot;server_port&quot;:8388, &quot;local_port&quot;:1080, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;password&quot;:&quot;helloworld&quot;, &quot;method&quot;: &quot;aes-128-cfb&quot;, &quot;timeout&quot;:600} 另外阿里云默认情况下8388端口是不对外开放的，请去阿里云控制到，找到对应的ecs实例，找到该实例的安全组，将8388端口添加到白名单。","link":"/2019/06/06/%E6%90%AD%E5%BB%BAShadowsocks-Server/"},{"title":"摘草莓","text":"上午带高烦烦来采草莓了，10块钱一斤，是不是很便宜。","link":"/2017/03/10/%E6%91%98%E8%8D%89%E8%8E%93/"},{"title":"支持生产阻塞的线程池","text":"在各种并发编程模型中，生产者-消费者模式大概是最常用的了。在实际工作中，对于生产消费的速度，通常需要做一下权衡。通常来说，生产任务的速度要大于消费的速度。一个细节问题是，队列长度，以及如何匹配生产和消费的速度。一个典型的生产者-消费者模型如下： 在并发环境下利用J.U.C提供的Queue实现可以很方便地保证生产和消费过程中的线程安全。这里需要注意的是，Queue必须设置初始容量，防止生产者生产过快导致队列长度暴涨，最终触发OutOfMemory。 对于一般的生产快于消费的情况。当队列已满时，我们并不希望有任何任务被忽略或得不到执行，此时生产者可以等待片刻再提交任务，更好的做法是，把生产者阻塞在提交任务的方法上，待队列未满时继续提交任务，这样就没有浪费的空转时间了。阻塞这一点也很容易，BlockingQueue就是为此打造的，ArrayBlockingQueue和LinkedBlockingQueue在构造时都可以提供容量做限制，其中LinkedBlockingQueue是在实际操作队列时在每次拿到锁以后判断容量。 更进一步，当队列为空时，消费者拿不到任务，可以等一会儿再拿，更好的做法是，用BlockingQueue的take方法，阻塞等待，当有任务时便可以立即获得执行，建议调用take的带超时参数的重载方法，超时后线程退出。这样当生产者事实上已经停止生产时，不至于让消费者无限等待。 于是一个高效的支持阻塞的生产消费模型就实现了。 等一下，既然J.U.C已经帮我们实现了线程池，为什么还要采用这一套东西？直接用ExecutorService不是更方便？ 我们来看一下ThreadPoolExecutor的基本结构： 可以看到，在ThreadPoolExecutor中，BlockingQueue和Consumer部分已经帮我们实现好了，并且直接采用线程池的实现还有很多优势，例如线程数的动态调整等。 但问题在于，即便你在构造ThreadPoolExecutor时手动指定了一个BlockingQueue作为队列实现，事实上当队列满时，execute方法并不会阻塞，原因在于ThreadPoolExecutor调用的是BlockingQueue非阻塞的offer方法： 123456789101112public void execute(Runnable command) { if (command == null) throw new NullPointerException(); if (poolSize &amp;amp;gt;= corePoolSize || !addIfUnderCorePoolSize(command)) { if (runState == RUNNING &amp;amp;amp;&amp;amp;amp; workQueue.offer(command)) { if (runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); } else if (!addIfUnderMaximumPoolSize(command)) reject(command); // is shutdown or saturated }} 这时候就需要做一些事情来达成一个结果：当生产者提交任务，而队列已满时，能够让生产者阻塞住，等待任务被消费。 关键在于，在并发环境下，队列满不能由生产者去判断，不能调用ThreadPoolExecutor.getQueue().size()来判断队列是否满。 线程池的实现中，当队列满时会调用构造时传入的RejectedExecutionHandler去拒绝任务的处理。默认的实现是AbortPolicy，直接抛出一个RejectedExecutionException。 几种拒绝策略在这里就不赘述了，这里和我们的需求比较接近的是CallerRunsPolicy，这种策略会在队列满时，让提交任务的线程去执行任务，相当于让生产者临时去干了消费者干的活儿，这样生产者虽然没有被阻塞，但提交任务也会被暂停。 123456789101112131415161718public static class CallerRunsPolicy implements RejectedExecutionHandler { /** * Creates a &amp;amp;lt;tt&amp;amp;gt;CallerRunsPolicy&amp;amp;lt;/tt&amp;amp;gt;. */ public CallerRunsPolicy() { } /** * Executes task r in the caller's thread, unless the executor * has been shut down, in which case the task is discarded. * @param r the runnable task requested to be executed * @param e the executor attempting to execute this task */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { r.run(); } }} 但这种策略也有隐患，当生产者较少时，生产者消费任务的时间里，消费者可能已经把任务都消费完了，队列处于空状态，当生产者执行完任务后才能再继续生产任务，这个过程中可能导致消费者线程的饥饿。 参考类似的思路，最简单的做法，我们可以直接定义一个RejectedExecutionHandler，当队列满时改为调用BlockingQueue.put来实现生产者的阻塞： 123456789101112new RejectedExecutionHandler() { @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { if (!executor.isShutdown()) { try { executor.getQueue().put(r); } catch (InterruptedException e) { // should not be interrupted } } }}; 这样，我们就无需再关心Queue和Consumer的逻辑，只要把精力集中在生产者和消费者线程的实现逻辑上，只管往线程池提交任务就行了。 相比最初的设计，这种方式的代码量能减少不少，而且能避免并发环境的很多问题。当然，你也可以采用另外的手段，例如在提交时采用信号量做入口限制等，但是如果仅仅是要让生产者阻塞，那就显得复杂了。 转载自：http://ifeve.com/blocking-threadpool-executor/","link":"/2017/12/28/%E6%94%AF%E6%8C%81%E7%94%9F%E4%BA%A7%E9%98%BB%E5%A1%9E%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"title":"收藏两首程序员打油诗","text":"12345678商女不知亡国恨，一天到晚敲代码。举头望明月，低头敲代码。洛阳亲友如相问，就说我在敲代码。少壮不努力，老大敲代码。垂死病中惊坐起，今天还没敲代码。生当作人杰，死亦敲代码。人生自古谁无死，来生继续敲代码。众里寻他千百度，蓦然回首，那人正在敲代码。 1234567891011121314151617181920212223写字楼里写字间，写字间里程序员；程序人员写程序，又拿程序换酒钱。酒醒只在网上坐，酒醉还来网下眠；酒醉酒醒日复日，网上网下年复年。宁愿老死程序间，只要老板多发钱；小车大房不去想，撰个二千好过年。若要见识新世面，公务员比程序员；一个在天一在地，而且还比我们闲。别人看我穿白领，我看别人穿名牌；天生我才写程序，臀大近视肩周炎。年复一年春光度，度得他人做老板；老板扣我薄酒钱，没有酒钱怎过年。春光逝去皱纹起，作起程序也委靡；来到水源把水灌，打死不做程序员。别人笑我忒疯癫，我笑他人命太贱；状元三百六十行，偏偏来做程序员。但愿老死电脑间，不愿鞠躬老板前；奔驰宝马贵者趣，公交自行程序员。别人笑我忒疯癫，我笑自己命太贱；不见满街漂亮妹，哪个归得程序员。不想只挣打工钱，那个老板愿发钱；小车大房咱要想，任我享用多悠闲。比尔能搞个微软，我咋不能捞点钱；一个在天一在地，定有一日乾坤翻。我在天来他在地，纵横天下山水间；傲视武林豪杰墓，一樽还垒风月山。电脑面前眼发直，眼镜下面泪茫茫；做梦发财好几亿，从此不用手指忙。哪知梦醒手空空，老板看到把我训；待到老时眼发花，走路不知哪是家。小农村里小民房，小民房里小民工；小民工人写程序，又拿代码讨赏钱。钱空只在代码中，钱醉仍在代码间；有钱无钱日复日，码上码下年复年。但愿老死代码间，不愿鞠躬奥迪前，奥迪奔驰贵者趣，程序代码贫者缘。若将贫贱比贫者，一在平地一在天；若将贫贱比车马，他得驱驰我得闲。别人笑我忒疯癫，我笑他人看不穿；不见盖茨两手间，财权富贵世人鉴。","link":"/2018/08/11/%E6%94%B6%E8%97%8F%E4%B8%A4%E9%A6%96%E7%A8%8B%E5%BA%8F%E5%91%98%E6%89%93%E6%B2%B9%E8%AF%97/"},{"title":"新年假期最后一天","text":"今天是新年假期最后一天了，早上起来将禁用的闹铃启用了。 程序员的新年也是苦逼的，今年没回家是一个错误的决定，在北京过年太无聊了，无聊到除夕夜敲代码。。。 放假这两天也没消停，前天夜里驾校之家服务挂了，服务器CPU占用100%，当天夜里搞到两点多去找原因，值得欣慰的是原因被找到了，也能长点经验，以后不会出现类似问题了。 初三、初四、初五、初六这四天每天都醉酒，酒量不好还是少喝点。 这几天有人陪高烦烦玩，她开心的不得了。感觉这几天她成长了好多，已经基本上能和小朋友们交流了。她今天突然跑过来抱着我的腿，问我：”爸爸、爸爸，爱是什么呀！“。 可爱死了！","link":"/2015/02/25/%E6%96%B0%E5%B9%B4%E5%81%87%E6%9C%9F%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/"},{"title":"明天去武汉看房","text":"这次走的太突然了。武汉购房标准放开了，上次去看的房子卖的差不多了。所以这次准备带上小方去看看，如果合适就先定下来！","link":"/2014/08/25/%E6%98%8E%E5%A4%A9%E5%8E%BB%E6%AD%A6%E6%B1%89%E7%9C%8B%E6%88%BF/"},{"title":"春暖花开，带小朋友看牡丹","text":"","link":"/2015/04/22/%E6%98%A5%E6%9A%96%E8%8A%B1%E5%BC%80%EF%BC%8C%E5%B8%A6%E5%B0%8F%E6%9C%8B%E5%8F%8B%E7%9C%8B%E7%89%A1%E4%B8%B9/"},{"title":"武汉-买房","text":"今天晚上的火车，明天要花我人生中有史以来的最大一笔钱。希望明天能够一切顺利，并感谢那些帮助过我的人。","link":"/2014/10/17/%E6%AD%A6%E6%B1%89-%E4%B9%B0%E6%88%BF/"},{"title":"涩港水污染，这他妈的没人管吗？","text":"今天在微博看到一个很让我心疼的消息。长年不在家，我跟别人聊天的时候一直很自豪的说自己的家乡很好，很美。看到这条微博让我无言以对啊。 下面是微博内容： 【信阳罗山一镇居民饮用水 散发“猪粪味”】近日，灵山镇居民说，自来水颜色发黄浑浊，混有猪粪味。记者实地走访竟发现，当地水源地涩港河已经成了垃圾遍地，污染严重的臭水河。对此，自来水公司态度恶劣并大骂记者“滚”，镇政府工作人员则笑称“#我们排污他们喝#”！ 下面这个视频，我看完之后我问候了一下他祖宗十八代。","link":"/2015/05/07/%E6%B6%A9%E6%B8%AF%E6%B0%B4%E6%B1%A1%E6%9F%93%EF%BC%8C%E8%BF%99%E4%BB%96%E5%A6%88%E7%9A%84%E6%B2%A1%E4%BA%BA%E7%AE%A1%E5%90%97%EF%BC%9F/"},{"title":"生产环境下JAVA进程高CPU占用故障排查","text":"收藏一篇文章，这两天被驾校之家CPU占用过高的问题弄的寝食难安。马上用下面的方法监控一下。 参考文章： 1. http://blog.csdn.net/blade2001/article/details/9065985 2. http://blog.csdn.net/jiangguilong2000/article/details/17971247 问题描述：生产环境下的某台tomcat7服务器，在刚发布时的时候一切都很正常，在运行一段时间后就出现CPU占用很高的问题，基本上是负载一天比一天高。 问题分析：1，程序属于CPU密集型，和开发沟通过，排除此类情况。2，程序代码有问题，出现死循环，可能性极大。 问题解决：1，开发那边无法排查代码某个模块有问题，从日志上也无法分析得出。2，记得原来通过strace跟踪的方法解决了一台PHP服务器CPU占用高的问题，但是通过这种方法无效，经过google搜索，发现可以通过下面的方法进行解决，那就尝试下吧。 解决过程：1，根据top命令，发现PID为2633的Java进程占用CPU高达300%，出现故障。 2，找到该进程后，如何定位具体线程或代码呢，首先显示线程列表,并按照CPU占用高的线程排序：[root@localhost logs]# ps -mp 2633 -o THREAD,tid,time | sort -rn 显示结果如下：USER %CPU PRI SCNT WCHAN USER SYSTEM TID TIMEroot 10.5 19 - - - - 3626 00:12:48root 10.1 19 - - - - 3593 00:12:16 找到了耗时最高的线程3626，占用CPU时间有12分钟了！ 将需要的线程ID转换为16进制格式：[root@localhost logs]# printf “%x\\n” 3626e18 最后打印线程的堆栈信息：[root@localhost logs]# jstack 2633 |grep e18 -A 30 将输出的信息发给开发部进行确认，这样就能找出有问题的代码。通过最近几天的监控，CPU已经安静下来了。","link":"/2015/03/13/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8BJAVA%E8%BF%9B%E7%A8%8B%E9%AB%98CPU%E5%8D%A0%E7%94%A8%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"title":"用16G内存在Java Map中处理30亿对象","text":"在一个下雨的夜晚，我在思考Java中内存管理的问题，以及Java集合对内存使用的效率情况。我做了一个简单的实验，测试在16G内存条件下，Java的Map可以插入多少对象。 这个试验的目的是为了得出集合的内部上限。所以，我决定使用很小的key和value。所有的测试，都是在64w位linux环境下进行的，操作系统是ubuntu12.04。JVM版本为Oracle Java 1.7.0_09-bo5 (HotSpot 23.5-b02)。在这个JVM中，压缩指针(compressed pointers(-XX:+UseCompressedOops))的选项是默认打开的。 首先是简单的针对java.util.TreeMap的测试。不停向其中插入数字，直到其抛出内存溢出异常。JVM的设置是-xmx15G import java.util.*; Map m = new TreeMap(); for(long counter=0;;counter++){ m.put(counter,&quot;&quot;); if(counter%1000000==0) System.out.println(&quot;&quot;+counter); } 这个用例插入了1 7200 0000条数据。在接近结束的时候，由于高负荷的GC插入效率开始降低。第二次，我用HashMap代替TreeMap，这次插入了182 000 000条数据。 Java默认的集合并不是最高效利用内存的。所以，这回我们尝试最后化内存的测试。我选择了MapDB中的LongHashMap，其使用原始的long key并且对封装的内存占用进行了优化。JVM的设置仍然是-Xmx15G。 import org.mapdb.* LongMap m = new LongHashMap(); for(long counter=0;;counter++){ m.put(counter,&quot;&quot;); if(counter%1000000==0) System.out.println(&quot;&quot;+counter); } 这次，计数器停止在了276 000 000。同样，在插入接近结束的时候，速度开始减慢。看起来这是基于堆的结合的限制所在。垃圾回收带来了瓶颈 。 现在是时候祭出杀手锏了:-)。我们可以采用非基于堆的方式存储，这样GC就不会发现我们的数据。我来介绍一下MapDB，它提供了基于数据库引擎的并发同步的TreeMap和HashMap。它提供了多样化的存储方式，其中一个就是非堆内存的方式。(声明：我是MapDB的作者)。 现在，让我们再跑一下之前的用例，这次采用的是非堆的Map。首先是配置并打开数据库，它打开的直接基于内存存储并且关闭事物的模式。接下来的代码是在这个db中创建一个新的map。 import org.mapdb.* DB db = DBMaker .newDirectMemoryDB() .transactionDisable() .make(); Map m = db.getTreeMap(&quot;test&quot;); for(long counter=0;;counter++){ m.put(counter,&quot;&quot;); if(counter%1000000==0) System.out.println(&quot;&quot;+counter); } 这是非堆的Map，所以我们需要不同的JVM配置： -XX:MaxDirectMemorySize=15G -Xmx128M。这次测试在达到980 000 000条记录的时候出现内存溢出。 但是，MapDB还可以优化。之前样例的问题在于记录的破碎分散，b-tree的节点每次插入都要调整它的容量。变通的方案是，将b-tree的节点在其插入前短暂的缓存起来。这使得记录的分散降到最低。所以，我们来改变一下DB的配置： DB db = DBMaker .newDirectMemoryDB() .transactionDisable() .asyncFlushDelay(100) .make(); Map m = db.getTreeMap(&quot;test&quot;); 这次记录数达到了 1 738 000 000。速度也是达到了惊人的31分钟完成了17亿数据的插入。 MapDB还能继续优化。我们把b-tree的节点容量从32提升到120并且打开透明(OneCoder理解为对用户不可见的)压缩： DB db = DBMaker .newDirectMemoryDB() .transactionDisable() .asyncFlushDelay(100) .compressionEnable() .make(); Map m = db.createTreeMap(&quot;test&quot;,120, false, null, null, null); 这个用例在大约3 315 000 000条记录时出现内存溢出。由于压缩，他的速度 有所降低，不过还是在几个小时内完成。我还可以进行一些优化(自定义序列化等等) ，使得数据量达到大约40亿。 也许你好奇所有这些记录是怎么存储的。答案就是，delta-key压缩。当然，向B-Tree插入已经排好序的递增key是最佳的使用场景，并且MapDB也对此进行了一些小小的 优化。最差的情形就是key是随机的. 后续更新：很多朋友对压缩有一些困惑。在这些用例中，Delta-key 压缩默认都是启用的。在下面的用例中，我又额外开启了zlib方式的压缩： DB db = DBMaker .newDirectMemoryDB() .transactionDisable() .asyncFlushDelay(100) .make(); Map m = db.getTreeMap(&quot;test&quot;); Random r = new Random(); for(long counter=0;;counter++){ m.put(r.nextLong(),&quot;&quot;); if(counter%1000000==0) System.out.println(&quot;&quot;+counter); } 即使在随机序列情况下，MapDB也可以存储652 000 000条记录，大概4倍于基于堆的集合。 这个简单的试验没有太多的目的。这仅仅是我对MapDB的一种优化。也许，更多的惊喜在于插入效率确实不错并且MapDB可以抗衡基于内存的集合。 原文地址：http://kotek.net/blog/3G_map","link":"/2015/02/04/%E7%94%A816G%E5%86%85%E5%AD%98%E5%9C%A8Java-Map%E4%B8%AD%E5%A4%84%E7%90%8630%E4%BA%BF%E5%AF%B9%E8%B1%A1/"},{"title":"结婚两周年","text":"今天结婚两周年，时间过的还挺快！","link":"/2013/12/20/%E7%BB%93%E5%A9%9A%E4%B8%A4%E5%91%A8%E5%B9%B4/"},{"title":"罗山高中，很牛的样子！","text":"罗山高中，哥的母校哈。这张图是刚在空间看到别人转发的，作为学渣的我按道理应该有一丝丝的羞意。但是如果重新给我一次就会，我会继续选择当学渣。","link":"/2014/06/25/%E7%BD%97%E5%B1%B1%E9%AB%98%E4%B8%AD%EF%BC%8C%E5%BE%88%E7%89%9B%E7%9A%84%E6%A0%B7%E5%AD%90%EF%BC%81/"},{"title":"群辉QNAP使用备忘","text":"记录家里的群辉NAS使用备忘，防止忘记了。 IP192.168.1.13 文件目录实际文件目录在：/share/… 备忘很多图片传重复了，抽空写个脚本判断下是否是重复文件，如果是重复的只保留一份就够了，节省磁盘空间，就判断文件的md5即可。","link":"/2021/01/22/%E7%BE%A4%E8%BE%89QNAP%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/"},{"title":"自制的喇叭","text":"很多年没在家过春天了，今天看到杨柳树发芽了，突发奇想要找一下童年的感觉，就用柳树条做了一个喇叭。做的过程中，小朋友还很期待的样子，哈哈，也让他感受一下我们童年的快乐。","link":"/2017/03/10/%E8%87%AA%E5%88%B6%E7%9A%84%E5%96%87%E5%8F%AD/"},{"title":"西安行","text":"总结一下： 历史文化古城，找个导游听一下讲解还是不错的，不建议自己逛。 人居多，天气还热，都晒伤了。 回民街的小吃不正中，就和北京的王府井、武汉的户部巷一样片外地人钱的。 不要被导游忽悠买他们的蓝田玉，就算是兵马俑博物馆里面卖的也不要买，哪怕他们说在这里买到假的就是世界第九大奇迹。 12345分享一篇知乎上看到的文章，里面导游的套路、说辞和我们导游是一模一样的，都怀疑是同一个导游了。作者：嘉禾链接：https://www.zhihu.com/question/34382541/answer/139343627来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 因为是找了导游游西安的，一路有导游带队。那导游还挺能说的（据说西安导游全靠嘴，因为西安古迹多，有好多故事可以讲），而且导游的确很厉害，介绍了很多西安的人文历史，所以我们挺喜欢那导游的。然后进兵马俑博物馆之前，导游就提醒我们绝对不要在博物馆外头买东西，不是假的就是贵的，连价格也不要问，万一你去了，老板砸个假的蓝田玉，然后说是你碰掉的，说都说不清。我们就多了个心眼，打死不多看一眼那里的商店。博物馆外面的贩卖各种玉石雕刻的都是假的，都是按斤卖的。当地人称“野兽街”。————————关于秦始皇兵马俑博物馆小贴士的分割线————————逛兵马俑真的还是要请个讲解员的，因为只有1号坑有兵马俑，而且后半段挖出的兵马俑又被黄土盖上去了，讲解员说是因为兵马俑本来都是有颜色的，但是一出土就受到氧化褪色了，为了保护兵马俑，1号坑的后半截挖了一半又全埋回去了。而2号坑就全是黄土堆，没把兵马俑挖出来 ；3号坑有陶俑马车和碎成渣的兵马俑碎片。如果没有讲解员，自己去逛根本看不出什么东西，就只是一堆土娃娃。而讲解员会给游客将兵马俑的来历，意义，和秦始皇陵墓的关系和其他陪葬坑。据说在秦始皇陵周围有600多个陪葬坑。嗯，而且还没有盗墓贼光顾过。————————————————分割线结束————————————————————问了小伙伴一下，真的是蓝田玉，可能是和田玉在我心中太高大了，一直盘旋脑海，已改正——————本次经历就是和这个讲解员有关。进了博物馆后，有个讲解员带我们欣赏兵马俑，导游在外头等我们。因为这个讲解员是导游找的，我觉得应该是很正规的，而且穿的也很正式。在他要推销蓝田玉之前，你完全不会想到坑钱这件事上去。在讲1,2号坑时，讲解员还是很称职的，而且有问必答，我问了很多关于盗墓的事情，他都回答了。但是到了3号坑（最后一个游览点），就开始有点问题了。因为3号坑本身就有点小，就是个凹型的坑，相对来说很小，没啥可讲的，然后他就说我们快结束了，可以去看看杨老先生（就是第一个发现秦始皇兵马俑的那位当地百姓），运气好时他在博物馆，可以握手签名什么的。又说道陕西特产蓝田玉。让我们出了博物馆千万不要去门口买商店里的蓝田玉，都是假的（这个他没直说，因为他是当地人，说假的不好，但是都是那个意思），称博物馆门口的街为野兽街，不要问价，和导游提醒我们的一样。为此，我们都觉得这讲解员真不错，好感顿生。之后细讲了下蓝田玉，说蓝田玉分活玉和死玉，活玉是玉养人，死玉是人养玉。外面买的蓝田玉不是假的就是死玉，让我们不要买，要买也请把价格压到100元8个。那我们就更加觉得有意思了，追问他什么是死玉什么是活玉。百般追问后，他说他身上带了一块，在腰间，补肾健体什么的。我们可以看不能摸。而且要在光亮的地方可以看得到。后来去了门口，他拿出来给我们看，不对光的时候是个墨绿到有点黑色的平安扣。但是一对光就真的是透亮的翠绿色，还带有黑色的暗点（美玉有瑕）。我们当时就很惊奇了。然后他又说，买蓝田玉不用买太好，买中档的就行，便宜的也不要，那是假的。然后我们就问什么是中档，他说就是300~2000左右的，太好也没什么用。之后我们就出了3号坑，去了有杨老先生在的那个地方，讲解员还说如果老先生不在就看照片。还说他是免费讲解的，所以进了那个地方（请原谅我忘记叫什么馆了），我们的门票就算是给他记了一分，他靠这个得到奖金什么的。然后，那里也讲解什么是蓝田玉的死玉和活玉，还有和假玉真玉的真假对比。我们可以看看。那里出售的所有的蓝田玉都是有宝石鉴定证书的，都是博物馆里统一管理的。之所以有这个展厅，就是因为以前游客买了博物馆外的蓝蓝田玉，发现是假的，但是投诉不了摊贩，就投诉到了博物馆。博物馆为了名誉，就自己弄了个正规的，让游客免得受骗。而且是国际性的，所以不收税，价格会比其他地方便宜10%到15%。甚至觉得是假的，随时可以带着发票退货，如果不小心摔碎了，还能邮寄回碎片，只要承担50%的费用，就能拿个新的。其实听到这里我就有点怀疑了，因为我觉得所有要我掏钱的人都是骗子。后来，还是进了那个馆。果然，只有杨老先生的照片。而且旁边和对面全是买蓝田玉的柜台。当时就有点懵。————之后几段的和田玉我就不改了，因为我当时一直听成了和田玉，没想到蓝田玉。也多亏我听岔了，所以才会认为这些玉是假的，因为和田玉真的很贵。如果当时就知道是蓝田玉，我可能还没那么快跳出骗局。满眼的和田玉啊，以前只有在电视上看到的和田玉，这可以08奥运金牌上的玉呢！但是就和小商品市场上的玻璃珠子一样堆在柜台上，当时就觉得好假啊。然后讲解员带我们到了一个柜台，说是给我们讲什么是真玉假玉和死玉活玉。然后拿出两个假的给我们看。因为我们团有25个人，柜台都坐不下了。我就站在旁边了，也没听了，因为就是掏钱买东西的地方，没意思。我同学有在看，一个美容养颜的芙蓉玉手镯，说是280元。还有什么墨绿色的可以买给爸爸，黄色的可以买给妈妈，功效不同。我一看就不对劲，因为在我眼中，玉镯子是很值钱的，尤其是和田玉。这里越看越像骗钱的。而且我们又不会鉴别什么是真的什么是假的，在山寨大国，除了人不能造，什么不能造假啊，我才不信宝石鉴定证书呢，就更加觉得是坑人的。觉得是骗钱的地方，怎么办？第一件事当然是百度看看，是不是真的骗钱。百度贴吧上果然有人爆贴说在兵马俑买了2个镯子花了1220元，去鉴定发现是玛瑙做的，还是鉴定费贵。我立刻把这个帖子给了我同学看，然后拉着我同学走了。被柜台售货员白了好几眼。所以，进了景区一定要多长心眼，看好钱财。感谢鉴宝节目，让我对和田玉和玉石有所了解，不会轻易别骗感谢百度和网友的以身试假，让我们有了警惕之心再加一个，感谢我运气好，和田玉、蓝田玉傻傻分不清对了，博物馆门口的野兽街每户人家家产300万左右，怎么来的，你们懂的！（讲解员说的）","link":"/2018/08/03/%E8%A5%BF%E5%AE%89%E8%A1%8C/"},{"title":"解决nvm加载慢的问题","text":"为了图方便，我使用nvm安装的nodejs。后来发现每当打开terminal的时候都会很慢，开始不知道什么原因，后来分析了下才知道是nvm的锅。 其实我不是每次打开terminal都需要用到nvm，所以我将nvm修改为按需加载，需要的时候手动执行命令去加载，我使用的是zsh，于是我修改了一下~/.zshrc文件： 修改前： 1234# nvmexport NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 修改后： 123456789101112131415# nvmexport NVM_DIR=&quot;$HOME/.nvm&quot;# 本来每次启动terminal的时候都需要执行下面两行代码的#[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm#[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completionfunction _install_nvm() { unset -f nvm [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This sets up nvm [ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # load nvm bash_completion nvm &quot;$@&quot;}function nvm() { _install_nvm &quot;$@&quot;} 修改之后，不是每次启动都会去加载nvm.sh仅当需要的时候在terminal中执行一下nvm命令即可，修改之后terminal启动速度明显快了。 参看资料：https://github.com/nvm-sh/nvm/issues/539","link":"/2020/11/02/%E8%A7%A3%E5%86%B3nvm%E5%8A%A0%E8%BD%BD%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"解决配置authorized_keys无法登陆","text":"因为权限问题才无法登陆，这里记录下，方便后面查用。 12sudo chmod 644 ~/.ssh/authorized_keyssudo chmod 700 ~/.ssh","link":"/2019/04/23/%E8%A7%A3%E5%86%B3%E9%85%8D%E7%BD%AEauthorized-keys%E6%97%A0%E6%B3%95%E7%99%BB%E9%99%86/"},{"title":"账号中心服务线上稳定一年纪念","text":"这台服务由三台机器负载，每日处理一亿四千万+次请求，线上稳定运营一年多，未出现任何故障，如果不是这次需求变动还能继续稳定运行。在重启县截图纪念一下。","link":"/2018/10/25/%E8%B4%A6%E5%8F%B7%E4%B8%AD%E5%BF%83%E6%9C%8D%E5%8A%A1%E7%BA%BF%E4%B8%8A%E7%A8%B3%E5%AE%9A%E4%B8%80%E5%B9%B4%E7%BA%AA%E5%BF%B5/"},{"title":"迁户口","text":"孩子要上学，急忙将房产证办下来，户口迁过来。 2018-06-29今天早上去派出所将新的户口本办理好了，还挺快的，一会儿就弄完了。","link":"/2018/06/28/%E8%BF%81%E6%88%B7%E5%8F%A3/"},{"title":"送小朋友回家了","text":"","link":"/2015/07/28/%E9%80%81%E5%B0%8F%E6%9C%8B%E5%8F%8B%E5%9B%9E%E5%AE%B6%E4%BA%86/"},{"title":"高烦烦的小猪佩奇","text":"高涵涵说，他是小猪佩奇、我是猪爸爸、妈妈是猪妈妈、爷爷是猪爷爷、奶奶是猪奶奶、还有乔治在妈妈肚肚里，我们一家也过上了童话中的生活了。","link":"/2017/03/05/%E9%AB%98%E7%83%A6%E7%83%A6%E7%9A%84%E5%B0%8F%E7%8C%AA%E4%BD%A9%E5%A5%87/"},{"title":"Java图片处理工具类","text":"这段代码是我四年前写的，当时的使用场景为使用tesseract做图片的预处理。功能包含图片二值化、移除杂色、横向切分、水平切分等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516import java.awt.Color;import java.awt.Image;import java.awt.Toolkit;import java.awt.image.BufferedImage;import java.awt.image.ColorModel;import java.awt.image.MemoryImageSource;import java.awt.image.PixelGrabber;import java.util.ArrayList;import java.util.List;/** * @author Gao Youbo * @since 2014-05-29 14:34:13 */public class ImageUtils { public static class SplitItem { private int x; private int w; private int y; private int h; public int getX() { return x; } public void setX(int x) { this.x = x; } public int getW() { return w; } public void setW(int w) { this.w = w; } public int getY() { return y; } public void setY(int y) { this.y = y; } public int getH() { return h; } public void setH(int h) { this.h = h; } } /** * 图片纵向切分（切分为列） * * @param image * @param minWidth 每个汉字的最小宽度，如果汉字的最小宽度小于该参数，那么认为系统将一个汉字截断了 * @return */ public static List&lt;BufferedImage&gt; splitLengthwaysWithMinWidth(BufferedImage image, int minWidth) { if (minWidth &lt; 0) { minWidth = 0; } List&lt;BufferedImage&gt; subImgs = new ArrayList&lt;&gt;(); int width = image.getWidth(); int height = image.getHeight(); int startX = 0; int endX = 0; boolean start = false; boolean end = false; for (int x = 0; x &lt; width; ++x) { boolean blank = isXBlank(image, x); if (!start) { //如果是白色 int space = spaceX(image, x); x = x + space; startX = x; endX = x; start = true; } if (start &amp;&amp; !blank) { endX = x; } int wordLength = endX - startX; if (start &amp;&amp; blank &amp;&amp; wordLength &gt; 0) { // 汉字长度小于设定长度，那么认为这不是一个完成的汉字，而是将左右结构的汉字切分成了两份 if (wordLength &lt; minWidth) { int space = spaceX(image, x); x = x + space; } else { end = true; endX = x; } } if (start &amp;&amp; end &amp;&amp; wordLength &gt; 0) { BufferedImage subImage = image.getSubimage(startX, 0, (endX - startX), height); subImgs.add(subImage); start = false; end = false; } } return subImgs; } /** * x轴上的所有点是空白的（白色的） * * @param image * @param x * @return */ private static boolean isXBlank(BufferedImage image, int x) { int height = image.getHeight(); for (int y = 0; y &lt; height; y++) { int rgb = image.getRGB(x, y); if (isBlack(rgb)) { return false; } } return true; } /** * 图片纵向切分（切分为列） * * @param image * @param minGap 文字之间的最小间隙，如果间隙文字之间的间隙小于或等于该参数，那么认为该间隙为一个汉字上的正常间隙。主要处理左右结构的一些汉字，例如：”北、川、外...“ * @return */ public static List&lt;BufferedImage&gt; splitLengthways(BufferedImage image, int minGap) { if (minGap &lt; 0) { minGap = 0; } List&lt;BufferedImage&gt; subImgs = new ArrayList&lt;&gt;(); int width = image.getWidth(); int height = image.getHeight(); List&lt;Integer&gt; weightlist = new ArrayList&lt;&gt;(); for (int x = 0; x &lt; width; ++x) { int count = 0; for (int y = 0; y &lt; height; ++y) { if (isBlack(image.getRGB(x, y))) { count++; } } if (minGap &gt; 0) { int space = spaceX(image, x); if (space &lt;= minGap) { count = count + space; } } weightlist.add(count); } List&lt;SplitItem&gt; splitItems = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; weightlist.size(); i++) { int length = 0; while (i &lt; weightlist.size() &amp;&amp; weightlist.get(i) &gt; 0) { i++; length++; } if (length &gt; 0) { int x = i - length; int w = length; int y = 0; int h = height; SplitItem item = new SplitItem(); item.setX(x); item.setW(w); item.setY(y); item.setH(h); splitItems.add(item); } } for (SplitItem splitItem : splitItems) { subImgs.add(image.getSubimage(splitItem.getX(), splitItem.getY(), splitItem.getW(), splitItem.getH())); } return subImgs; } /** * X轴上两个字之间的间距 * * @param image * @param currentX 当前索引所在的x坐标 * @return */ private static int spaceX(BufferedImage image, int currentX) { int w = image.getWidth(); int h = image.getHeight(); int spaceLength = 0; for (int x = currentX; x &lt; w; x++) { boolean space = true; for (int y = 0; y &lt; h; y++) { if (isBlack(image.getRGB(x, y))) { //有黑色的，表明非空白 space = false; break; } } if (space) { spaceLength++; } else { return spaceLength; } } return spaceLength; } /** * y轴上两个字之间的间距 * * @param image * @param currentY 当前索引所在的y坐标 * @return */ private static int spaceY(BufferedImage image, int currentY) { int w = image.getWidth(); int h = image.getHeight(); int spaceLength = 0; for (int y = currentY; y &lt; h; y++) { boolean space = true; for (int x = 0; x &lt; w; x++) { if (isBlack(image.getRGB(x, y))) { //有黑色的，表明非空白 space = false; break; } } if (space) { spaceLength++; } else { return spaceLength; } } return spaceLength; } /** * 图片横向切分（切分为行） * * @param image * @param minGap 两行之间的最小间隙,如果间隙小于或等于该参数,那么认为没有折行 * @return */ public static List&lt;BufferedImage&gt; splitCrosswise(BufferedImage image, int minGap) { if (minGap &lt; 0) { minGap = 0; } List&lt;BufferedImage&gt; subImgs = new ArrayList&lt;&gt;(); int w = image.getWidth(); int h = image.getHeight(); List&lt;Integer&gt; heightlist = new ArrayList&lt;&gt;(); for (int y = 0; y &lt; h; y++) { int count = 0; for (int x = 0; x &lt; w; x++) { if (ImageUtils.isBlack(image.getRGB(x, y))) { count++; } } if (minGap &gt; 0) { int space = spaceY(image, y); if (space &lt;= minGap) { count = count + space; } } heightlist.add(count); } for (int i = 0; i &lt; heightlist.size(); i++) { int length = 0; while (i &lt; heightlist.size() &amp;&amp; heightlist.get(i) &gt; 0) { i++; length++; } if (length &gt; 0) { int y = i - length; int x = 0; int height = length; int width = w; BufferedImage bufferedImage = image.getSubimage(x, y, width, height); subImgs.add(bufferedImage); } } return subImgs; } /** * 图片横向切分（切分为行） * * @param image * @return */ public static List&lt;BufferedImage&gt; splitCrosswise(BufferedImage image) { List&lt;BufferedImage&gt; subImgs = new ArrayList&lt;&gt;(); int w = image.getWidth(); int h = image.getHeight(); List&lt;Integer&gt; heightlist = new ArrayList&lt;&gt;(); for (int y = 0; y &lt; h; y++) { int count = 0; for (int x = 0; x &lt; w; x++) { if (ImageUtils.isBlack(image.getRGB(x, y))) { count++; } } heightlist.add(count); } for (int i = 0; i &lt; heightlist.size(); i++) { int length = 0; while (i &lt; heightlist.size() &amp;&amp; heightlist.get(i) &gt; 0) { i++; length++; } if (length &gt; 0) { int y = i - length; int x = 0; int height = length; int width = w; BufferedImage bufferedImage = image.getSubimage(x, y, width, height); subImgs.add(bufferedImage); } } return subImgs; } /** * 删除杂色(图片二值化) * &lt;p&gt; * 默认图片中字体颜色为黑色，如果非黑色像素全部替换为白色 * * @param image * @return * @throws java.lang.InterruptedException */ public static final BufferedImage removeMotley(BufferedImage image) throws InterruptedException { int width = image.getWidth(); int height = image.getHeight(); int[] pixels = new int[width * height]; int grey = 100; PixelGrabber pixelGrabber = new PixelGrabber(image.getSource(), 0, 0, width, height, pixels, 0, width); pixelGrabber.grabPixels(); ColorModel cm = ColorModel.getRGBdefault(); for (int i = 0; i &lt; width * height; i++) { int red, green, blue; int alpha = cm.getAlpha(pixels[i]); if (cm.getRed(pixels[i]) &gt; grey) { red = 255; } else { red = 0; } if (cm.getGreen(pixels[i]) &gt; grey) { green = 255; } else { green = 0; } if (cm.getBlue(pixels[i]) &gt; grey) { blue = 255; } else { blue = 0; } pixels[i] = alpha &lt;&lt; 24 | red &lt;&lt; 16 | green &lt;&lt; 8 | blue; //通过移位重新构成某一点像素的RGB值 } //将数组中的象素产生一个图像 Image tempImg = Toolkit.getDefaultToolkit().createImage(new MemoryImageSource(width, height, pixels, 0, width)); image = new BufferedImage(tempImg.getWidth(null), tempImg.getHeight(null), BufferedImage.TYPE_INT_BGR); image.createGraphics().drawImage(tempImg, 0, 0, null); return image; } /** * 清除空白部分 * * @param image * @return */ public static BufferedImage removeSpace(BufferedImage image) { BufferedImage result = removeTBWhite(image); return removeLRWhite(result); } /** * 移除上下白色部分（top bottom） * * @param image * @return */ public static BufferedImage removeTBWhite(BufferedImage image) { int width = image.getWidth(); int height = image.getHeight(); int start = 0; int end = 0; Label1: for (int y = 0; y &lt; height; ++y) { int count = 0; for (int x = 0; x &lt; width; ++x) { if (isBlack(image.getRGB(x, y))) { count++; } if (count &gt;= 1) { start = y; break Label1; } } } Label2: for (int y = height - 1; y &gt;= 0; --y) { int count = 0; for (int x = 0; x &lt; width; ++x) { if (isBlack(image.getRGB(x, y))) { count++; } if (count &gt;= 1) { end = y; break Label2; } } } return image.getSubimage(0, start, width, end - start + 1); } /** * 移除左右白色部分（left right） * * @param image * @return */ public static BufferedImage removeLRWhite(BufferedImage image) { int width = image.getWidth(); int height = image.getHeight(); int start = 0; int end = 0; Label1: for (int x = 0; x &lt; width; ++x) { int count = 0; for (int y = 0; y &lt; height; ++y) { if (isBlack(image.getRGB(x, y))) { count++; } if (count &gt;= 1) { start = x; break Label1; } } } Label2: for (int x = width - 1; x &gt;= 0; --x) { int count = 0; for (int y = height - 1; y &gt;= 0; --y) { if (isBlack(image.getRGB(x, y))) { count++; } if (count &gt;= 1) { end = x; break Label2; } } } return image.getSubimage(start, 0, end - start + 1, height); } /** * 移除黑色部分 * * @param img * @return */ public static BufferedImage removeBlack(BufferedImage img) { int width = img.getWidth(); int height = img.getHeight(); int start = 0; int end = 0; Label1: for (int y = 0; y &lt; height; ++y) { for (int x = 0; x &lt; width; ++x) { if (isBlack(img.getRGB(x, y))) { start = y; break Label1; } } } Label2: for (int y = height - 1; y &gt;= 0; --y) { for (int x = 0; x &lt; width; ++x) { if (isBlack(img.getRGB(x, y))) { end = y; break Label2; } } } return img.getSubimage(0, start, width, end - start + 1); } /** * 是否是黑色 * * @param colorInt * @return */ public static boolean isBlack(int colorInt) { Color color = new Color(colorInt); return color.getRed() + color.getGreen() + color.getBlue() &lt;= 100; } /** * 是否是白色 * * @param colorInt * @return */ public static boolean isWhite(int colorInt) { Color color = new Color(colorInt); return color.getRed() + color.getGreen() + color.getBlue() &gt; 100; }}","link":"/2018/09/06/Java%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"title":"TOP 10开源的推荐系统简介","text":"转载自：http://ibillxia.github.io/blog/2014/03/10/top-10-open-source-recommendation-systems/ 最近这两年推荐系统特别火，本文搜集整理了一些比较好的开源推荐系统，即有轻量级的适用于做研究的SVDFeature、LibMF、LibFM等，也有重量级的适用于工业系统的 Mahout、Oryx、EasyRecd等 SVDFeature 主页：http://svdfeature.apexlab.org/wiki/Main_Page 语言：C++一个feature-based协同过滤和排序工具，由上海交大Apex实验室开发，代码质量较高。在KDD Cup 2012中获得第一名，KDD Cup 2011中获得第三名，相关论文 发表在2012的JMLR中，这足以说明它的高大上。SVDFeature包含一个很灵活的Matrix Factorization推荐框架，能方便的实现SVD、SVD++等方法, 是单模型推荐算法中精度最高的一种。SVDFeature代码精炼，可以用 相对较少的内存实现较大规模的单机版矩阵分解运算。另外含有Logistic regression的model，可以很方便的用来进行ensemble。 LibMF 主页：http://www.csie.ntu.edu.tw/~cjlin/libmf/ 语言：C++作者Chih-Jen Lin来自大名鼎鼎的台湾国立大学，他们在机器学习领域享有盛名，近年连续多届KDD Cup竞赛上均 获得优异成绩，并曾连续多年获得冠军。台湾大学的风格非常务实，业界常用的LibSVM， Liblinear等都是他们开发的，开源代码的效率和质量都非常高。LibMF在矩阵分解的并行化方面作出了很好的贡献，针对SGD（随即梯度下降）优化方法在并行计算中存在的locking problem和memory discontinuity问题，提出了一种 矩阵分解的高效算法FPSGD（Fast Parallel SGD），根据计算节点的个数来划分评分矩阵block，并分配计算节点。系统介绍可以见这篇 论文（ACM Recsys 2013的 Best paper Award）。 LibFM 主页：http://www.libfm.org/ 语言：C++作者是德国Konstanz大学的Steffen Rendle，他用LibFM同时玩转KDD Cup 2012 Track1和Track2两个子竞赛单元，都取得了很好的成绩，说明LibFM是非常管用的利器。LibFM是专门用于矩阵分解的利器，尤其是其中实现了MCMC（Markov Chain Monte Carlo）优化算法，比常见的SGD优化方法精度要高，但运算速度要慢一些。当然LibFM中还 实现了SGD、SGDA（Adaptive SGD）、ALS（Alternating Least Squares）等算法。 Lenskit 主页：http://lenskit.grouplens.org/ 语言Java 这个Java开发的开源推荐系统，来自美国的明尼苏达大学的GroupLens团队，也是推荐领域知名的测试数据集Movielens的作者。该源码托管在GitHub上，https://github.com/grouplens/lenskit。主要包含lenskit-api,lenskit-core, lenskit-knn,lenskit-svd,lenskit-slopone,lenskit-parent,lenskit-data-structures,lenskit-eval,lenskit-test等模块，主要实现了k-NN，SVD，Slope-One等 典型的推荐系统算法。 GraphLab 主页：GraphLab - Collaborative Filtering 语言：C++Graphlab是基于C++开发的一个高性能分布式graph处理挖掘系统，特点是对迭代的并行计算处理能力强（这方面是hadoop的弱项），由于功能独到，GraphLab在业界名声很响。 用GraphLab来进行大数据量的random walk或graph-based的推荐算法非常有效。Graphlab虽然名气比较响亮（CMU开发），但是对一般数据量的应用来说可能还用不上。GraphLab主要实现了ALS，CCD++，SGD，Bias-SGD，SVD++，Weighted-ALS，Sparse-ALS，Non-negative Matrix Factorization，Restarted Lanczos Algorithm等算法。 Mahout 主页：http://mahout.apache.org/ 语言：JavaMahout 是 Apache Software Foundation (ASF) 开发的一个全新的开源项目，其主要目标是创建一些可伸缩的机器学习算法，供开发人员在 Apache 在许可下免费 使用。Mahout项目是由 Apache Lucene社区中对机器学习感兴趣的一些成员发起的，他们希望建立一个可靠、文档翔实、可伸缩的项目，在其中实现一些常见的用于 聚类和分类的机器学习算法。该社区最初基于 Ngetal. 的文章 “Map-Reduce for Machine Learning on Multicore”，但此后在发展中又并入了更多广泛的机器学习 方法，包括Collaborative Filtering（CF），Dimensionality Reduction，Topic Models等。此外，通过使用 Apache Hadoop 库，Mahout 可以有效地扩展到云中。在Mahout的Recommendation类算法中，主要有User-Based CF，Item-Based CF，ALS，ALS on Implicit Feedback，Weighted MF，SVD++，Parallel SGD等。 Myrrix 主页：http://myrrix.com/ 语言：JavaMyrrix最初是Mahout的作者之一Sean Owen基于Mahout开发的一个试验性质的推荐系统。目前Myrrix已经是一个完整的、实时的、可扩展的集群和推荐系统，主要 架构分为两部分：服务层：在线服务，响应请求、数据读入、提供实时推荐；计算层：用于分布式离线计算，在后台使用分布式机器学习算法为服务层更新机器学习 模型。Myrrix使用这两个层构建了一个完整的推荐系统，服务层是一个HTTP服务器，能够接收更新，并在毫秒级别内计算出更新结果。服务层可以单独使用，无需 计算层，它会在本地运行机器学习算法。计算层也可以单独使用，其本质是一系列的Hadoop jobs。目前Myrrix以被 Cloudera 并入Oryx项目。 EasyRec 主页：http://easyrec.org/ 语言：JavaEasyRec是一个易集成、易扩展、功能强大且具有可视化管理的推荐系统，更像一个完整的推荐产品，包括了数据录入模块、管理模块、推荐挖掘、离线分析等。 EasyRec可以同时给多个不同的网站提供推荐服务，通过tenant来区分不同的网站。架设EasyRec服务器，为网站申请tenant，通过tenant就可以很方便的集成到 网站中。通过各种不同的数据收集（view,buy.rating）API收集到网站的用户行为，EasyRec通过离线分析，就可以产生推荐信息，您的网站就可以通过 Recommendations和Community Rankings来进行推荐业务的实现。 Waffles 主页：http://waffles.sourceforge.net/ 语言：C++Waffles英文原意是蜂蜜甜饼，在这里却指代一个非常强大的机器学习的开源工具包。Waffles里包含的算法特别多，涉及机器学习的方方面面，推荐系统位于 其中的Waffles_recommend tool，大概只占整个Waffles的1/10的内容，其它还有分类、聚类、采样、降维、数据可视化、音频处理等许许多多工具包，估计 能与之媲美的也就数Weka了。 RapidMiner 主页：http://rapidminer.com/ 语言：JavaRapidMiner（前身是Yale）是一个比较成熟的数据挖掘解决方案，包括常见的机器学习、NLP、推荐、预测等方法（推荐只占其中很小一部分），而且带有GUI的 数据分析环境，数据ETL、预处理、可视化、评估、部署等整套系统都有。另外RapidMiner提供commercial license，提供R语言接口，感觉在向着一个商用的 数据挖掘公司的方向在前进。 开源的推荐系统大大小小的还有很多，以上只是介绍了一些在学术界和工业界比较流行的TOP 10，而且基本上都是用C++/Java实现的，在参考资料[1]、[2]中还提 到的有Crab（Python）、CofiRank（C++）、MyMediaLite（.NET/C#）、PREA（Java）、Python-recsys（Python）、Recommendable（Ruby）、Recommenderlab（R）、 Oryx（Java）、recommendify（Ruby）、RecDB（SQL）等等，当然GitHub上还有更多。。。即有适合单机运行的，也有适合集群的。虽然使用的编程语言不同，但实现 的算法都大同小异，主要是SVD、SGD、ALS、MF、CF及其改进算法等。 参考资料 推荐系统开源软件列表汇总和点评 开源中国社区-搜索：推荐系统","link":"/2018/10/24/TOP-10%E5%BC%80%E6%BA%90%E7%9A%84%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/"},{"title":"Tesseract分享","text":"本分享基于tesseract4.x 认识Tesseract项目主页：https://github.com/tesseract-ocr/tesseract Tesseract的OCR引擎最先由HP实验室于1985年开始研发，至1995年时已经成为OCR业内最准确的三款识别引擎之一。然而，HP不久便决定放弃OCR业务，Tesseract也从此尘封。 数年以后，HP意识到，与其将Tesseract束之高阁，不如贡献给开源软件业，让其重焕新生－－2005年，Tesseract由美国内华达州信息技术研究所获得，并求诸于Google对Tesseract进行改进、消除Bug、优化工作。 识别识别前处理调整尺寸Tesseract对于dpi &gt;= 300的图片有更好的识别效果。所以在识别之前将图片调整到合适的尺寸有助于提高识别效果。下图为识别图片调整尺寸前后的识别效果对比，可以看出图片放大之后，识别效果有明显的提升。 二值化二值化就是将图像中灰度值大于某个临界灰度值的像素点设置为灰度最大值，灰度值小于某个临界灰度值的像素点设置为灰度最小值。这样图像中就只会出现黑和白两种颜色。合理的二值化能够减少被识别图像中的干扰因素，对于提升识别效果也是有很大的帮助的。例如下图，在二值化之前图片是有水印的，二值化之后能将水印直接去掉。 图片切割很多情况下我们要识别的图片中文字的排版并不是我们想要的样子，有很多无用的信息，并且排版也不利于tesseract去识别。 简单切割例如下图，我们要从图片中识别出违章信息，包括违章的时间、地点、原因、罚了多少钱、扣了多少分。如果直接拿原图去进行识别，假设所有的字都是别正确，那么这些字的排版也是不是我们最终想要的样子，并且图片中有很多的信息是我们不需要的。所以，可以在识别前分别将图片中时间、地点、原因、金额、分数分别切出多张图，将其他无用的信息都剔除掉。这样做的好处一是单行文字识别对tesseract很友好，二是针对时间、金额、分数这些数字内容可以针对性的使用数字语言库进行识别来提高识别率。 多行、多列切割 图片旋转如果图片中的文字是倾斜的，会导致Tesseract的行数据分割不准确，严重影响ocr的效果，所以在识别之前可以先旋转图片，使文字保持水平。 命令号调用识别命令行使用手册12345678910111213141516171819202122232425262728293031323334353637383940➜ bin ./tesseract --help-extraUsage: ./tesseract --help | --help-extra | --help-psm | --help-oem | --version ./tesseract --list-langs [--tessdata-dir PATH] ./tesseract --print-parameters [options...] [configfile...] ./tesseract imagename|imagelist|stdin outputbase|stdout [options...] [configfile...]OCR options: --tessdata-dir PATH Specify the location of tessdata path. --user-words PATH Specify the location of user words file. --user-patterns PATH Specify the location of user patterns file. -l LANG[+LANG] Specify language(s) used for OCR. -c VAR=VALUE Set value for config variables. Multiple -c arguments are allowed. --psm NUM Specify page segmentation mode. --oem NUM Specify OCR Engine mode.NOTE: These options must occur before any configfile.Page segmentation modes: 0 Orientation and script detection (OSD) only. 1 Automatic page segmentation with OSD. 2 Automatic page segmentation, but no OSD, or OCR. 3 Fully automatic page segmentation, but no OSD. (Default) 4 Assume a single column of text of variable sizes. 5 Assume a single uniform block of vertically aligned text. 6 Assume a single uniform block of text. 7 Treat the image as a single text line. 8 Treat the image as a single word. 9 Treat the image as a single word in a circle. 10 Treat the image as a single character. 11 Sparse text. Find as much text as possible in no particular order. 12 Sparse text with OSD. 13 Raw line. Treat the image as a single text line, bypassing hacks that are Tesseract-specific.OCR Engine modes: 0 Legacy engine only. 1 Neural nets LSTM engine only. 2 Legacy + LSTM engines. 3 Default, based on what is available. 识别效果展示效果如下图所示，对于这种排版整齐、文字清晰、大小合适的图片，直接使用官方提供的中文语言库，识别效果是很好的，下图就做到了100%正确识别。所以一个合适的输入图片，对于提高识别的正确率是有很大的帮助的，识别前图片的预处理就显得尤为重要。 识别后处理 识别之后有些词能看出明显无语义的错误，可以再做一下替换，例如下面的词。 1234匕京=北京交又=交叉东潮=东湖... 训练对于一些特殊的字体，使用Tesseract自带的识别库，识别效果并不是那么理想。所以我们可以训练自己的识别库。例如下图的手写字体，我们对比下使用官方提供的chi_sim库和我训练的chi_my库的识别效果。 很明显，我自己训练的识别库能够100%准确的识别出图片中的文字，那么我们接下来看下如何去训练自己的识别库。 jTessBoxEditor是一个第三方工具，借助这个工具能够很方便的去训练一个自己的字库。jTessBoxEditor下载地址：https://sourceforge.net/projects/vietocr/files/jTessBoxEditor/ 我接下来的介绍中所使用的版本为jTessBoxEditorFX-2.1.0。jTessBoxEditor其实是对Tesseract命令的GUI封装，该工具其实最终也是调用的Tesseract相关的命令来完成训练工作。 基于图片训练根据图片生成box文件 下面介绍下上图标注的5个步骤 tesseract的安装目录，在这个目录下可以找到tesseract等可执行文件。 需要训练的图片所在的路径。 所要训练的语言名称，这个可以自己取名，我这里叫做：chi_my。 Bootstrap Languange，在生成box文件的时候Tesseract会先根据这里指定的语言识别下，虽然这里识别的会有很多的错误，但是也能帮我们减少一定的工作量。 这里选择Make Box File Only，因为生成的box文件可能会有错误，我们后面还会在进行一次编辑，所以这里先只生成box文件。 在jTessBoxEditor下面的输出中我们可以看到，我们最终执行的命令其实是： 1/Users/gaoyoubo/lib/tesseract/bin/tesseract train.png train -l chi_sim batch.nochop makebox 编辑box文件在生成box文件之后，我们可以使用jTessEditor文件打开查看下box文件。如下图： 我们对照着生成的box文件查看一下： 123456789101112131415轲 69 17 165 72 0轲 159 17 193 72 0他 199 16 261 72 0放 268 12 384 75 0士 1040 0 1040 0 03 416 13 474 71 0, 1040 0 1040 0 0正 534 15 625 72 0如 631 12 694 75 0收 729 19 759 72 0轲 753 17 825 72 0轲 819 17 853 72 0他 859 16 968 72 0李 969 17 980 33 0。 996 17 1011 30 0 可以看出box文件其实就是描述了图片中的每个字所在的位置，格式为： 1字 x坐标 y坐标 宽度 高度 当然我们使用命令生成的box文件是有很多错误的，接下来就需要使用jTessBoxEditor来编辑box文件，调整文字、xy坐标、宽高来准确的标注图片中的每个字。调整完成的结果如下图： 完成训练在完成box文件的编辑之后就可以使用box文件进行训练了，如下图： 我们这里需要选择Train with Existing Box，进行训练，训练过程中具体使用了哪些命令，都可以在控制台中查看。训练完成之后会在Training Data目录下生成有一个tessdata文件夹，文件夹文件夹中有个chi_my.tessdata文件就是我们的训练结果。我们需要将这个文件copy到%TESSERACT_HOME%/share/tessdata就可以使用了。 基于字体训练 字体各式各样，很多情况下我们在识别图片中文字的时候可能由于字体问题，导致识别并不准确。所以就有为某种字体单独训练识别库的需求。对于根据字体进行训练jTessBoxEditor也做了很好的支持。 如下图，我们输入想要训练的文字，然后选择字体就能生成相应的图片和box文件了。 生成结果如下： 有了box文件之后，我们的识别库训练就可以参照上面的步骤了。 参考文档 编译安装文档：https://github.com/tesseract-ocr/tesseract/wiki/Compiling 训练文档：https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract-4.00 如何提高识别质量：https://github.com/tesseract-ocr/tesseract/wiki/ImproveQuality 什么是二值化：https://baike.baidu.com/item/%E4%BA%8C%E5%80%BC%E5%8C%96 图片降噪：https://blog.csdn.net/weixin_42225141/article/details/80714518 LSTM原理及实现：https://blog.csdn.net/gzj_1101/article/details/79376798","link":"/2018/09/28/Tesseract%E5%88%86%E4%BA%AB/"},{"title":"看了《洛阳女儿行》除了心痛还是心痛(转载)","text":"看洛阳女儿行第一部的时候，还在读高中二年级，现在情节是什么已经忘的差不多了，只是记得这是一本好书，故事情节、文笔都非常好。最近在微信读书上看到给我推荐洛阳女儿行，于是购买了接着往下看，今天在百度贴吧上看到了这篇书评，感觉写的非常好，于是转载了。 鉴于广大读者时下只能在网上找到整个作品的很小一部分，我这里给个内容简介，顺便加入一些个人看法。整个作品是有六部，目前我只读到读了前五部，第六部还在修改中。 第一部《斑骓待》，分上下两部。上部网上已发布，写青年剑客韩锷为寻找爱侣方柠，走入洛阳城，遭遇种种奇遇，最终发现自己被卷入了一桩陈年的灭门巨案，同时发觉自己其实是被他所爱的方柠，真名杜方柠，以及似乎爱他的于婕，真名余婕，诱入这个很大很大的迷局中的。结尾处，韩锷洛阳城外倚马苦待，但杜方柠告诉她的侍女韩锷终究不会走出她的洛阳，因此她也就不必去赴城外的约会，她还让侍女去探看余婕的墓穴，预示着她尚在人世。 由于情节的迷离和秘术的频现，这个故事略显生涩，但是极有张力，隐约是温瑞安《杀楚》的意境。文中特别的人物是余婕。这个故事中她以一个因面貌丑陋而自伤、因武功平常而有求于人、因言辞突兀的让人惊诧、终在关窍处引刀割喉、嘎然而去的烈女形象出现，但她身上那种历尽人生生死巨变，洞悉尘世前后因果的疲倦感和无力感，却与她激烈的复仇意识和对韩锷的浓烈爱意形成鲜明的对照，使得这个女子一出现就让人再难忘却。实际上，她虽死却始终给读者生的感觉，成为暗处的“洛阳女儿”，伴随着明处的杜方柠一同贯穿全书。尽管余婕是凭她所修行的大荒山秘术，洞悉韩锷是生命中能够给他绝大助力的男人，可是韩锷见她时那种前世、梦中似曾相逢的感觉，在萎靡内魅的洛阳城中，是如此让人迷惘而思忆，想必也会给身处现代都市中的读者感同身受之感。此外，余婕在这个故事里也以轮回巷老人、余姑姑的形象出现，后面还会以“漠上玫”的身份复活，但她在整部《洛阳》中形象，以在这个故事中最为引人追思。 《洛阳》的写法上一点突破于传统武侠作品之处，在于大量的涉及了秘术，如后面要出现的素女门一派的“忌体香”、“枕头咒”、“阿堵盅”，大荒山的“十诧古图轮回阵”，小计天生的“止水清瞳”，龙门异的“龙门二十品”阵法等。秘术最重要的所在，是余婕对于韩锷命运的种种预测，以至于把韩锷的大部分行为都置于一种不可改变的状态，从而让这个故事在整体上充满了迷幻色彩，具有极为强烈的宿命感，有些相似于《英雄志》。其它阵法奇术之类，虽然作者之前作品《杯雪》、《脂剑奇僧录》中已经有过，而且即使在金庸的《射雕》中，也已有所出现，但该作中小椴的写法别具一格，另有新意，与温瑞安的同类描写相仿佛，属于作品中非常有观赏性的一个看点。 《斑骓待》下部写韩锷解救余婕之弟余小计，并从此与其建立了亦师亦友的伙伴关系，之后他返回洛阳城，解除了杜方柠的危局，在洛阳势力的欢呼中与小计一道孤单的走出洛阳、走向长安。韩锷与杜方柠的首度联手，使得这个故事在大局上不乏鲜活之气，但洛阳城外那貌似善意的近乎驱除式的群体送客，却让韩锷满怀苦闷。故事至此告一段落，结尾时，利大夫和杜方柠独特的送别方式，还有小计许下的“让锷哥从此快乐起来”的良愿，让人对这故事的下文充满了善意的期待。 第二部《陇头行》也是上下两个故事。上部写韩锷来到长安，为察探小计的身世而独闯皇城，得到的讯息为他日后的塞外之行打下伏笔。旋即，韩锷在芙蓉园遭遇紫宸高手艾可的暗算，不得以而不退出长安，却在路上与京城秩序的维护者，第一高手俞九阙遭遇，险死还生。这个故事中出现了全书的两大武学高手，俞九阙、卫子矜，他们武功固然绝顶高超，却一失左手一少右手，如此非同一般的关系把故事向多年之前的宫廷暗斗拉伸开去。特别值得注意的是作品中以非常近的距离细细描写了韩锷的父亲，一个当年置弃子于长安城外、时下在长安城中洁厕挑粪为生的老人，以及这种奇异的父子关系在群体中所造成的轰动效果。在小椴独具传奇色彩的文字故事中，这种错失的人物关系对读者所造成的震撼感，尤其强烈而引人深思。后面的故事里还会写到韩锷父亲的死亡，一回极有悲剧意识的沉湖自尽。这样一种父子关系，在底层里把韩锷至于一个异常孤独的境地，使得他具有了本质上的漂泊感，并且一直在试图建设自己自小就丧失的价值意识。 下部从韩锷逗留天水，教习余小计武艺写起，期间二人与老将军王横海相识。不久韩锷闻讯杜方柠长安有事，终于忍不住赶赴观望，却不经意中夺得龙会武会的魁首，乃授封天子使臣，欲往塞外一行。这部分的前舒后疾，前面天水一段文字从容舒缓，尤其写韩余二人适逢麦积山的“花儿会”，即当地一年一度青年男女公开择偶的节日，别有一番旖旎风光。之后写长安城中龙华会的比武夺帅，采用常规武侠小说情节的非常规写法，简练而精粹，带动着情节骤然加速，示意作品要进入新篇章新主题——韩锷将由闲散转入征战。 三部《居延猎》、四部《戎马逸》关系密切，是整个《洛阳》最为波澜壮阔，也是最为写意抒情的两部，写洛阳女儿杜方柠出行的部分。故事中，韩锷与杜方柠再度携手，转战边疆，安定塞外十五城，决荡千里草原沙场；更剑索合璧，力拼咯丹三杀与大漠王，谋刺左贤王与羌戎首领于万军之中。两部作品开阔浩荡，风格上接作者的中篇作品《弓箫缘》，与第一部《斑骓待》诡谲晦涩的形成鲜明的对比，恰好体现出杜方柠从繁荣拥塞的洛阳来到千里平沙的塞外在心理上所生的绝大变化。 尽管《洛阳》的三四两部洋溢着热烈的气氛，却始终为一种弥漫全书的孤寂所萦绕。韩杜两人每于生死关头总是无分彼此，却始终在战局安定略有间隔，让人时刻感觉到两人之间内在的距离感。杜方柠行出洛阳，驰骋疆场，终于有一回让她酣畅尽致的出世恋情，但也终究为现世中的使命所束缚。韩锷侠客行般的英雄主义，始终无法彻底溶入那样一个整体柔媚的时代里，因此他不但在扰攘的洛阳于长安中是孤独的，在塞外的原野里也是孤寂的，热烈的气氛伴随寂寞的情怀。 此外，小椴在他的故事中也放入了关于战争的种种反思，从而使得主人公的种种努力在本质上具有了一定程度的悲剧感。有一段情节依稀曾经在一部很轰动也很受争议的电影里出现。韩杜行刺之前遇到一个儿子被羌戎王杀光的老人，问他恨不恨羌戎王，老人回答：“草原上就是这样的了。乌毕汗是个真英雄，他的心胸大。就算没有他，草原上的各个部落领主们相互争战的还少了？”之后二人在刺杀过程中一直心存犹疑，为羌戎王的气度而心折，谋刺后更对陷入内乱的羌戎人心存愧疚。 这一部分还有一个值得留意的细节。韩锷刺探敌营被发觉，却恰好当时天空中有烟花绽放，吸引了敌军的视线，他才能得以脱身，然后突然就看到荒野中一个老人般的汉家小孩在痛哭着燃放最后一只烟花。在这一瞬间，韩锷错愕了，读者仿佛随之看到：韩锷心中关于童年、关于父亲、关于孤单、关于危险的种种回忆骤然涌现，他也随着那孩子失声痛哭泪流满面。 第四部的结尾部分情节又开始回到宫廷争斗，余小计的皇子身份呼之欲出，暗线中的洛阳女儿余婕的 “漠上玫”分身也以造就完成，长安城中惊心动魄的宫闱之变即将上演了。 第五部《日色赋》写韩锷与余小计回到长安，连番遭遇袭杀中，余小计日益长成，余婕一派大荒山势力凸现，杜方柠所在太子一派岌岌可危。然而临末，韩锷识破余婕诱他刺杀太子的图谋，杜方柠更在俞九阙的默许下毒毙皇帝，太子在他东宫的楼顶远望太极殿。到这里，韩锷的势力已经丰满，掌控兵权，成为左右时局的最主要的力量，他虽一直醉心于塞上的驰骋生涯，却已经有足够的实力拥小计为帝，他问道：“你是更想回塞上，还是更想当皇帝？” 至此，韩锷的特征已经清晰化。最为作品的的头号主人公，他所担当的主要使命却是支持故事的进展。他身上凸现的男性标识，超脱的出世意识，简单的济世情怀，都可以看作一种象征和符号，这些象征与符号不可能在他身上获得圆满的结合而使他成为一个真实的个体。把整个作品比作一个圆，韩锷虽然处在最中心的位置，但圆周的边界才是那个时代真实的存在。小椴架空了韩锷这个人物，借这个人物去寄托浪漫主义的理想，即韩锷时代里一种无法实现的幻想。韩锷虽然有强力的武功和兵权，总是不能越过别人给他设置的边界，反倒一再发现自己的边界被别人所逾越，每每在暂时的实现自己的“理念”之后发现自己实际上走入了女人的圈套。不但对杜方柠、余婕、小殊、艾可如此，对一个普通民女他也无能为力，他进入民女夭夭为他安排的宿处，在夜里遭遇了性侵犯，然后第二天呆呆的注视着夭夭远去。 《洛阳》中行出洛阳的女儿有两个，明线和主旨说的是杜方柠，但副线余婕却一直在暗中追随她的脚步。杜方柠出身豪门世家，却要以联姻的方式把自己出让，在这个尘世中苦苦的挣扎，以维护两个家族的运转。她也曾与爱人乐游原上索剑结盟，曾于壮阔的边疆跃马驰骋，曾城头浴血苦战以守候那不可期待的太平。当洛阳的女子行走在塞外旷野，我们发现她还是一个女子。可是当她回到了洛阳长安，就不得不执掌她那个世家的权柄，承担一个男子的责任。对于余婕，我们不知道这个神秘女子的内心深处埋藏了怎样的痛苦，只看到韩锷一见她的面就生出怜惜的念头，并且在很长的时间里把照顾好小计当作是对她的苦难与死亡的一种交代。如果这只是余婕大荒山秘术的一种手段，那么我们不禁要想，在这个秘术的背后，余婕有怎样的真是情绪？在第六部故事了，作者对蜕变成漠上玫的余婕的情绪当会有一个交代。 结合《洛阳》，小椴作品一个需要注意的特征是对于少年的刻画。从《杯雪》中的小六儿开始，到《长安》中的小稚，《脂剑》中的小苦儿，再到《洛阳》中的小计，甚至还能联想到作者的自己的笔名，小椴的作品总离不开一个占据重要篇幅的的小孩儿。这不能不让人归结为一种创作上的情结，即少年英雄主义情结。简单看来，这似乎可以追溯到每个人在自己少年时代的某种向往——当我们年少的时候是多么渴望的成为一个英雄，即使是追随一个英雄也是那么的美好。从事武侠创作的人们，这种情感很可能比一班人要浓烈的多，那种早期的对英雄的向往很可能是他们从事武侠作品创作的一个原动力，这实际上使得武侠小说具有很强的童话色彩，是 “成人的童话”。浪漫主义情绪突出的作者尤其强调少年在作品中的突出地位，比如还主楼主写《蜀山》，甚至金庸所创造的人物也作品也大都从主人公的少年写起。而小椴作品的少年痕迹则尤其明显，故事往往在少年长成之后就不再继续，少年们在少年时代就已经完成他们的传奇，成长得沧桑而历练。某种程度上，小椴是把小孩子当作大人来写的，从而在有限的时空里把传奇浓缩，以获得更强烈的表现效果。 比起小椴以前塑造的少年，小计有所不同，他不但是皇子，而且天赋异禀，善于秘术，一出世就充满了强烈神秘色彩，身世背后凝聚了绝大的传奇成分。这在某种程度上继续了《脂剑》中的小苦儿这一人物的特征。实际上，小苦儿在《脂剑》中的表现和可能让小椴感到不满意，而且意犹未尽，所以他在《洛阳》里给了小计一个更大的传奇，更大身份。在未完成的第六部里，小计应该是存在着诸多的变数的，《洛阳》文中有指称太子“少帝长安开紫宸”，如果这里“少帝”是隐约指历史上的唐少帝李重茂，那么小计则未免有点暗射李隆基的嫌疑了。 “每个男孩都有梦想成为一个王子的权利”，小计或许也能是给读者这样的期待吧。 第六部，待续中。 其它评价：就背景而言，《洛阳》的历史痕迹非常浓郁，字里行间满一派古旧厚重之气。小椴以浓艳的笔墨的刻画了汉家江山唐代宫廷的风貌，更是让作品里的故事围绕着皇权的争夺展开，但写的却是假史。这里的假史不同于架空，它是架构在唐朝的官制之上，严格按照中晚唐的风物人情去展开情节的，同时在边塞征战中写出了汉时的雄阔与壮丽。就情节而言，也隐有所指，疑似唐睿宗李旦年间，之先有武则天称帝，当时有韦后距帝位一步之遥，之后有太平公主掌权，整个时代都为女性的阴柔和强健所笼罩，小说的题目叫做女儿行，点出作品中对女性地位的强化。 虽然作品的所有的人物和情节都完全是小椴自己的，但是却给人以强烈的历史压迫感——小椴带读者进入他的历史里，伴随着他的江湖。就这感觉的强烈程度而言，超过红猪侠的《庆熹纪事》和孙晓的《英雄志》。《庆熹》用的明清的宫廷格调，却用了汉唐般的远疆杀伐，虽说结合的近乎无缝，但还是让人一看就觉出架空感。《英雄志》本身想表达的超越了故事所处的时代，但要不是情节上与明史本身如此接近，恐怕不容易让人辨出太多历史的味道。 《洛阳》与《杯雪》是大不相同的。计划中的《杯雪》是要写足七卷，但是作品的开篇太精彩，以至于那样精彩的江湖儿女乱世英雄，很难找到足以与之匹配的背景朝代了，所以小椴写完第一部《驼、锋》后，大概很有一种被正史“伤”了一下的感觉，却也绝不甘心抛却他的怀古情节，因此转笔去写洛阳跟长安，写他自己的“历史”而淡化了江湖。《洛阳》中的人物，虽然还是用第三人称，但是和读者的距离却比《杯雪》近的多了。耿苍怀和骆寒的壮阔与傲岸，主要是用远景写的，但《洛阳》中的韩锷和小计，则几乎和读者血脉相连了，也因为如此，他们有了更多的承载与担当，以至于韩锷这个人物逐渐被符号化。不过《洛阳》的开篇则是晦涩而疏远的，之后小椴才逐渐的把主人公拉到读者面前，带着表达倾诉的欲望让他的人物越来越生动充实，直至充实的给人压迫感。 对于《洛阳》，小椴对文字的期待可以归结为“细致绵密，诡异深艳”，用一个词来形容这种文字给我的感觉，就是“炽艳”。而实际上，小椴的在古旧的文字中对现代的句法也是照用不误，比如“城市”这个词，就时常被嵌入到非常现代的词句中：洛阳——“是一个阴污暗浊的城市，虽然远看着它好象闹哄哄的一片橙红瑰丽，可禁不住走近细看，揭开来那一层面纱底下可全都是浊血污泥的晦暗啊。”；长安——“远远的那个城市，依旧冷冷无语地浅灰着”；居延——“你不在时，这个城市，对于我就是空的”（韩锷）。这里的城市带给人的是诸多的隔阂。那个人头拥挤的洛阳，韩锷于杜方柠会相逢无语，唯有黯然而别，可是在乐游原上，在塞外荒原上，他们的距离被无限的拉近。 乐游原是那样的：“乐游原上最好玩的季节却不是春天，而是初冬。乐游原的初冬是苍白的——从苍苍的露变成了白白的霜，光阴暗换。天气渐冷，马蹄儿踏上去，原野静静的，你会听到秋后露水儿在马蹄儿下爆裂的声音已渐渐换做了冬来后薄霜在马蹄下咯吱吱、几不可闻的轻响。但你不用担心颜色太过寡素，早上起来，那霜枯的草上也会有光晕的，黄晕晕的一层，因为天边会有金红的、咸蛋黄样的太阳，照着你，遥遥的温暖与口边的呵气……” 在这样的对比中，空间的距离和感观的距离被分离了，小椴所要表现的，是一种原始的群体之外的情绪上的接近，这样关于两性的描写就成为一个作品很重要的组成部分了。 《洛阳》沿袭了小椴作品感情浓烈的一贯风格，在个别要点关头的描写上甚至与已有作品非常相似。比如“紫宸一星”龚亦惺箭射杜方柠的那一瞬间，那种“在那一刻，他已爱绝了眼前的这个女子”这种异常惊艳的情感，和《长安古意——七月流火》中，清流社杀手吴暑在死斗中对程窈娘“默默无声坚决十年”的喜欢，在情境上是极为相似的。 同时，《洛阳》中大量以象征隐喻手法表现两性关系，无论是力度还是广度上，比之前的作品都大大的加强了。直接的性描写有韩在“花儿会”和民女夭夭的一夕欢好、韩杜二人在塞外行程里的“双修”，朴厄绯施展“迷迭之术”的香艳场景。如果说这些情节在小椴之前的《弓箫缘》和《脂剑》还有迹可寻，只是在描写力度上有所加强，那么其它诸如韩锷自渎的描写、韩在少年时代所遭遇的艾可的“性骚扰”，则已经确实的超越了传统武侠的尺度了。文学评论界一般以张贤亮《男人的一半是女人》作为中国当代性爱文学的开山之作，那么小椴的《洛阳》似乎可以在武侠作品中占据这样一个地位。实际上，小椴在性爱描写中所大量采用隐喻象征手法，也正是张贤亮在他的文学作品中所采用的方式。 值得注意的是，在这种爱与性描写中，韩锷已经失去了作为人物的真实性，而是成为了“性”与“爱”的象征。我们甚至可以认为韩锷是《洛阳》时代里男性意识的唯一标识。除了他之外，再没有一个真正的男人了：第一高手俞九阙是性变态，皇子余小计仍在青春期，老将军往横海已经垂老，杜方柠的丈夫韦得辉先天软骨。所以艾可对韩锷说“你害了我，害得我从此以后再不会对任何男人动心了”，所以书中所有的女子，如杜方柠、余婕、阿姝、小殊、艾可、朴厄绯、夭夭，全都围绕因着韩锷才能存在她们的爱与性。《洛阳》中以男主人公为“性中心”的程度之强烈，已经大大的超越了正常的尺度。但实际上，韩锷的强硬并不是为彰显他自我的强大和他强悍的性意识，与此相反，往往他是作为性行为的被动者甚至性侵犯的对象而存在的，甚至要采用自读的方式来实现自我解脱。这些性的描写在整体上映射出韩锷内心的虚弱与在女人如杜方柠面前的无力感，同时也是映射出那个时代男性的整体衰弱。联系那个时代，不由让人在杜方柠以及余婕身上，小椴是隐约寄托那个时代的强势女性韦后和太平公主的痕迹的。实际上，韩锷虽然拼命维持他男子的硬挺，但其行为却始终被杜方柠和余婕控制于指掌之间。而杜方柠和余婕两个女子，不但独立支撑起各自的世家，而且各自谋划着扶持其自己的天下。余婕借韩锷的力量谋刺太子的计划距功成只有一发之隔，杜方柠更亲自毒杀皇帝与宫廷深处，她们虽然把感情寄托给了韩锷这个男子，但却一直没有被她们的感情所左右价值观和大局观。 此外，作品中也不乏隐喻式的同性之爱的描写，如两大顶尖高手俞九阙与卫子矜之间的特殊情绪，宫廷宠臣陈果子对中原塞外两位帝王爱恨交错，甚至是韩锷与余小计那种洞穿世情的认同感。俞九阙对于卫子矜的性情绪，是潜伏的，出自于对世间完美事物的激赏和对于凡间精灵的激赏。而在陈果子和两位帝王性关系里，他完全是出于被侵犯与被伤害的地位，内在上有隐喻权利与性的关系的成分，而最终他的反叛，是写出了压抑之下的反抗情绪，对此，读者可以参考南冠的《凤起阿房》。而韩锷和余小计的关系，则是写出了男人之间的认同感，在某种程度上强调了男人在本质上是需要男人的认可的。需要注意的是，余小计在韩锷身边的成长过程，同时也是他的性成长的过程，小椴虽然没有明写这一点，但是在细节的隐蔽处，诸如小计为韩锷解除“阿堵盅”，我们是不难发现这种痕迹的。 这种对同性关系的关注，不免让人对照想起《庆熹纪事》和《凤起阿房》。相比而言，《庆熹》冷静细腻，《阿房》背景鲜明，《洛阳》则是一部情绪特征突出的作品，对作者的表现欲望体现较多，因此同性之间的性爱描写也更具有内在的传奇色彩和外在的冲击力。 但是这个同性的主题由于种种原因，小椴似乎并没有完全展开来写，有些地方从现在的作品看是相当的隐讳的，还请读者读到作品之后自行体会","link":"/2018/08/01/%E7%9C%8B%E4%BA%86%E3%80%8A%E6%B4%9B%E9%98%B3%E5%A5%B3%E5%84%BF%E8%A1%8C%E3%80%8B%E9%99%A4%E4%BA%86%E5%BF%83%E7%97%9B%E8%BF%98%E6%98%AF%E5%BF%83%E7%97%9B-%E8%BD%AC%E8%BD%BD/"},{"title":"JavaScript计算农历","text":"产品最近需要花一个万年历的图片用于分享使用，找了Java的很多库都不好用，于是在其他万年历的网页中找到了下面的代码，然后用Java调用JavaScript将万年历计算出来。 最终生成的图片 JavaScript代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Calendar&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var getData = (function () { //公历农历转换 var calendar = { lunarInfo: [0x04bd8, 0x04ae0, 0x0a570, 0x054d5, 0x0d260, 0x0d950, 0x16554, 0x056a0, 0x09ad0, 0x055d2, 0x04ae0, 0x0a5b6, 0x0a4d0, 0x0d250, 0x1d255, 0x0b540, 0x0d6a0, 0x0ada2, 0x095b0, 0x14977, 0x04970, 0x0a4b0, 0x0b4b5, 0x06a50, 0x06d40, 0x1ab54, 0x02b60, 0x09570, 0x052f2, 0x04970, 0x06566, 0x0d4a0, 0x0ea50, 0x06e95, 0x05ad0, 0x02b60, 0x186e3, 0x092e0, 0x1c8d7, 0x0c950, 0x0d4a0, 0x1d8a6, 0x0b550, 0x056a0, 0x1a5b4, 0x025d0, 0x092d0, 0x0d2b2, 0x0a950, 0x0b557, 0x06ca0, 0x0b550, 0x15355, 0x04da0, 0x0a5b0, 0x14573, 0x052b0, 0x0a9a8, 0x0e950, 0x06aa0, 0x0aea6, 0x0ab50, 0x04b60, 0x0aae4, 0x0a570, 0x05260, 0x0f263, 0x0d950, 0x05b57, 0x056a0, 0x096d0, 0x04dd5, 0x04ad0, 0x0a4d0, 0x0d4d4, 0x0d250, 0x0d558, 0x0b540, 0x0b6a0, 0x195a6, 0x095b0, 0x049b0, 0x0a974, 0x0a4b0, 0x0b27a, 0x06a50, 0x06d40, 0x0af46, 0x0ab60, 0x09570, 0x04af5, 0x04970, 0x064b0, 0x074a3, 0x0ea50, 0x06b58, 0x055c0, 0x0ab60, 0x096d5, 0x092e0, 0x0c960, 0x0d954, 0x0d4a0, 0x0da50, 0x07552, 0x056a0, 0x0abb7, 0x025d0, 0x092d0, 0x0cab5, 0x0a950, 0x0b4a0, 0x0baa4, 0x0ad50, 0x055d9, 0x04ba0, 0x0a5b0, 0x15176, 0x052b0, 0x0a930, 0x07954, 0x06aa0, 0x0ad50, 0x05b52, 0x04b60, 0x0a6e6, 0x0a4e0, 0x0d260, 0x0ea65, 0x0d530, 0x05aa0, 0x076a3, 0x096d0, 0x04bd7, 0x04ad0, 0x0a4d0, 0x1d0b6, 0x0d250, 0x0d520, 0x0dd45, 0x0b5a0, 0x056d0, 0x055b2, 0x049b0, 0x0a577, 0x0a4b0, 0x0aa50, 0x1b255, 0x06d20, 0x0ada0, 0x14b63, 0x09370, 0x049f8, 0x04970, 0x064b0, 0x168a6, 0x0ea50, 0x06b20, 0x1a6c4, 0x0aae0, 0x0a2e0, 0x0d2e3, 0x0c960, 0x0d557, 0x0d4a0, 0x0da50, 0x05d55, 0x056a0, 0x0a6d0, 0x055d4, 0x052d0, 0x0a9b8, 0x0a950, 0x0b4a0, 0x0b6a6, 0x0ad50, 0x055a0, 0x0aba4, 0x0a5b0, 0x052b0, 0x0b273, 0x06930, 0x07337, 0x06aa0, 0x0ad50, 0x14b55, 0x04b60, 0x0a570, 0x054e4, 0x0d160, 0x0e968, 0x0d520, 0x0daa0, 0x16aa6, 0x056d0, 0x04ae0, 0x0a9d4, 0x0a2d0, 0x0d150, 0x0f252, 0x0d520], solarMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Gan: [&quot;\\u7532&quot;, &quot;\\u4e59&quot;, &quot;\\u4e19&quot;, &quot;\\u4e01&quot;, &quot;\\u620a&quot;, &quot;\\u5df1&quot;, &quot;\\u5e9a&quot;, &quot;\\u8f9b&quot;, &quot;\\u58ec&quot;, &quot;\\u7678&quot;], Zhi: [&quot;\\u5b50&quot;, &quot;\\u4e11&quot;, &quot;\\u5bc5&quot;, &quot;\\u536f&quot;, &quot;\\u8fb0&quot;, &quot;\\u5df3&quot;, &quot;\\u5348&quot;, &quot;\\u672a&quot;, &quot;\\u7533&quot;, &quot;\\u9149&quot;, &quot;\\u620c&quot;, &quot;\\u4ea5&quot;], Animals: [&quot;\\u9f20&quot;, &quot;\\u725b&quot;, &quot;\\u864e&quot;, &quot;\\u5154&quot;, &quot;\\u9f99&quot;, &quot;\\u86c7&quot;, &quot;\\u9a6c&quot;, &quot;\\u7f8a&quot;, &quot;\\u7334&quot;, &quot;\\u9e21&quot;, &quot;\\u72d7&quot;, &quot;\\u732a&quot;], solarTerm: [&quot;\\u5c0f\\u5bd2&quot;, &quot;\\u5927\\u5bd2&quot;, &quot;\\u7acb\\u6625&quot;, &quot;\\u96e8\\u6c34&quot;, &quot;\\u60ca\\u86f0&quot;, &quot;\\u6625\\u5206&quot;, &quot;\\u6e05\\u660e&quot;, &quot;\\u8c37\\u96e8&quot;, &quot;\\u7acb\\u590f&quot;, &quot;\\u5c0f\\u6ee1&quot;, &quot;\\u8292\\u79cd&quot;, &quot;\\u590f\\u81f3&quot;, &quot;\\u5c0f\\u6691&quot;, &quot;\\u5927\\u6691&quot;, &quot;\\u7acb\\u79cb&quot;, &quot;\\u5904\\u6691&quot;, &quot;\\u767d\\u9732&quot;, &quot;\\u79cb\\u5206&quot;, &quot;\\u5bd2\\u9732&quot;, &quot;\\u971c\\u964d&quot;, &quot;\\u7acb\\u51ac&quot;, &quot;\\u5c0f\\u96ea&quot;, &quot;\\u5927\\u96ea&quot;, &quot;\\u51ac\\u81f3&quot;], sTermInfo: ['9778397bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c965cc920e', '97bcf97c3598082c95f8c965cc920f', '97bd0b06bdb0722c965ce1cfcc920f', 'b027097bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c965cc920e', '97bcf97c359801ec95f8c965cc920f', '97bd0b06bdb0722c965ce1cfcc920f', 'b027097bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c965cc920e', '97bcf97c359801ec95f8c965cc920f', '97bd0b06bdb0722c965ce1cfcc920f', 'b027097bd097c36b0b6fc9274c91aa', '9778397bd19801ec9210c965cc920e', '97b6b97bd19801ec95f8c965cc920f', '97bd09801d98082c95f8e1cfcc920f', '97bd097bd097c36b0b6fc9210c8dc2', '9778397bd197c36c9210c9274c91aa', '97b6b97bd19801ec95f8c965cc920e', '97bd09801d98082c95f8e1cfcc920f', '97bd097bd097c36b0b6fc9210c8dc2', '9778397bd097c36c9210c9274c91aa', '97b6b97bd19801ec95f8c965cc920e', '97bcf97c3598082c95f8e1cfcc920f', '97bd097bd097c36b0b6fc9210c8dc2', '9778397bd097c36c9210c9274c91aa', '97b6b97bd19801ec9210c965cc920e', '97bcf97c3598082c95f8c965cc920f', '97bd097bd097c35b0b6fc920fb0722', '9778397bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c965cc920e', '97bcf97c3598082c95f8c965cc920f', '97bd097bd097c35b0b6fc920fb0722', '9778397bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c965cc920e', '97bcf97c359801ec95f8c965cc920f', '97bd097bd097c35b0b6fc920fb0722', '9778397bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c965cc920e', '97bcf97c359801ec95f8c965cc920f', '97bd097bd097c35b0b6fc920fb0722', '9778397bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c965cc920e', '97bcf97c359801ec95f8c965cc920f', '97bd097bd07f595b0b6fc920fb0722', '9778397bd097c36b0b6fc9210c8dc2', '9778397bd19801ec9210c9274c920e', '97b6b97bd19801ec95f8c965cc920f', '97bd07f5307f595b0b0bc920fb0722', '7f0e397bd097c36b0b6fc9210c8dc2', '9778397bd097c36c9210c9274c920e', '97b6b97bd19801ec95f8c965cc920f', '97bd07f5307f595b0b0bc920fb0722', '7f0e397bd097c36b0b6fc9210c8dc2', '9778397bd097c36c9210c9274c91aa', '97b6b97bd19801ec9210c965cc920e', '97bd07f1487f595b0b0bc920fb0722', '7f0e397bd097c36b0b6fc9210c8dc2', '9778397bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c965cc920e', '97bcf7f1487f595b0b0bb0b6fb0722', '7f0e397bd097c35b0b6fc920fb0722', '9778397bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c965cc920e', '97bcf7f1487f595b0b0bb0b6fb0722', '7f0e397bd097c35b0b6fc920fb0722', '9778397bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c965cc920e', '97bcf7f1487f531b0b0bb0b6fb0722', '7f0e397bd097c35b0b6fc920fb0722', '9778397bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c965cc920e', '97bcf7f1487f531b0b0bb0b6fb0722', '7f0e397bd07f595b0b6fc920fb0722', '9778397bd097c36b0b6fc9274c91aa', '97b6b97bd19801ec9210c9274c920e', '97bcf7f0e47f531b0b0bb0b6fb0722', '7f0e397bd07f595b0b0bc920fb0722', '9778397bd097c36b0b6fc9210c91aa', '97b6b97bd197c36c9210c9274c920e', '97bcf7f0e47f531b0b0bb0b6fb0722', '7f0e397bd07f595b0b0bc920fb0722', '9778397bd097c36b0b6fc9210c8dc2', '9778397bd097c36c9210c9274c920e', '97b6b7f0e47f531b0723b0b6fb0722', '7f0e37f5307f595b0b0bc920fb0722', '7f0e397bd097c36b0b6fc9210c8dc2', '9778397bd097c36b0b70c9274c91aa', '97b6b7f0e47f531b0723b0b6fb0721', '7f0e37f1487f595b0b0bb0b6fb0722', '7f0e397bd097c35b0b6fc9210c8dc2', '9778397bd097c36b0b6fc9274c91aa', '97b6b7f0e47f531b0723b0b6fb0721', '7f0e27f1487f595b0b0bb0b6fb0722', '7f0e397bd097c35b0b6fc920fb0722', '9778397bd097c36b0b6fc9274c91aa', '97b6b7f0e47f531b0723b0b6fb0721', '7f0e27f1487f531b0b0bb0b6fb0722', '7f0e397bd097c35b0b6fc920fb0722', '9778397bd097c36b0b6fc9274c91aa', '97b6b7f0e47f531b0723b0b6fb0721', '7f0e27f1487f531b0b0bb0b6fb0722', '7f0e397bd097c35b0b6fc920fb0722', '9778397bd097c36b0b6fc9274c91aa', '97b6b7f0e47f531b0723b0b6fb0721', '7f0e27f1487f531b0b0bb0b6fb0722', '7f0e397bd07f595b0b0bc920fb0722', '9778397bd097c36b0b6fc9274c91aa', '97b6b7f0e47f531b0723b0787b0721', '7f0e27f0e47f531b0b0bb0b6fb0722', '7f0e397bd07f595b0b0bc920fb0722', '9778397bd097c36b0b6fc9210c91aa', '97b6b7f0e47f149b0723b0787b0721', '7f0e27f0e47f531b0723b0b6fb0722', '7f0e397bd07f595b0b0bc920fb0722', '9778397bd097c36b0b6fc9210c8dc2', '977837f0e37f149b0723b0787b0721', '7f07e7f0e47f531b0723b0b6fb0722', '7f0e37f5307f595b0b0bc920fb0722', '7f0e397bd097c35b0b6fc9210c8dc2', '977837f0e37f14998082b0787b0721', '7f07e7f0e47f531b0723b0b6fb0721', '7f0e37f1487f595b0b0bb0b6fb0722', '7f0e397bd097c35b0b6fc9210c8dc2', '977837f0e37f14998082b0787b06bd', '7f07e7f0e47f531b0723b0b6fb0721', '7f0e27f1487f531b0b0bb0b6fb0722', '7f0e397bd097c35b0b6fc920fb0722', '977837f0e37f14998082b0787b06bd', '7f07e7f0e47f531b0723b0b6fb0721', '7f0e27f1487f531b0b0bb0b6fb0722', '7f0e397bd097c35b0b6fc920fb0722', '977837f0e37f14998082b0787b06bd', '7f07e7f0e47f531b0723b0b6fb0721', '7f0e27f1487f531b0b0bb0b6fb0722', '7f0e397bd07f595b0b0bc920fb0722', '977837f0e37f14998082b0787b06bd', '7f07e7f0e47f531b0723b0b6fb0721', '7f0e27f1487f531b0b0bb0b6fb0722', '7f0e397bd07f595b0b0bc920fb0722', '977837f0e37f14998082b0787b06bd', '7f07e7f0e47f149b0723b0787b0721', '7f0e27f0e47f531b0b0bb0b6fb0722', '7f0e397bd07f595b0b0bc920fb0722', '977837f0e37f14998082b0723b06bd', '7f07e7f0e37f149b0723b0787b0721', '7f0e27f0e47f531b0723b0b6fb0722', '7f0e397bd07f595b0b0bc920fb0722', '977837f0e37f14898082b0723b02d5', '7ec967f0e37f14998082b0787b0721', '7f07e7f0e47f531b0723b0b6fb0722', '7f0e37f1487f595b0b0bb0b6fb0722', '7f0e37f0e37f14898082b0723b02d5', '7ec967f0e37f14998082b0787b0721', '7f07e7f0e47f531b0723b0b6fb0722', '7f0e37f1487f531b0b0bb0b6fb0722', '7f0e37f0e37f14898082b0723b02d5', '7ec967f0e37f14998082b0787b06bd', '7f07e7f0e47f531b0723b0b6fb0721', '7f0e37f1487f531b0b0bb0b6fb0722', '7f0e37f0e37f14898082b072297c35', '7ec967f0e37f14998082b0787b06bd', '7f07e7f0e47f531b0723b0b6fb0721', '7f0e27f1487f531b0b0bb0b6fb0722', '7f0e37f0e37f14898082b072297c35', '7ec967f0e37f14998082b0787b06bd', '7f07e7f0e47f531b0723b0b6fb0721', '7f0e27f1487f531b0b0bb0b6fb0722', '7f0e37f0e366aa89801eb072297c35', '7ec967f0e37f14998082b0787b06bd', '7f07e7f0e47f149b0723b0787b0721', '7f0e27f1487f531b0b0bb0b6fb0722', '7f0e37f0e366aa89801eb072297c35', '7ec967f0e37f14998082b0723b06bd', '7f07e7f0e47f149b0723b0787b0721', '7f0e27f0e47f531b0723b0b6fb0722', '7f0e37f0e366aa89801eb072297c35', '7ec967f0e37f14998082b0723b06bd', '7f07e7f0e37f14998083b0787b0721', '7f0e27f0e47f531b0723b0b6fb0722', '7f0e37f0e366aa89801eb072297c35', '7ec967f0e37f14898082b0723b02d5', '7f07e7f0e37f14998082b0787b0721', '7f07e7f0e47f531b0723b0b6fb0722', '7f0e36665b66aa89801e9808297c35', '665f67f0e37f14898082b0723b02d5', '7ec967f0e37f14998082b0787b0721', '7f07e7f0e47f531b0723b0b6fb0722', '7f0e36665b66a449801e9808297c35', '665f67f0e37f14898082b0723b02d5', '7ec967f0e37f14998082b0787b06bd', '7f07e7f0e47f531b0723b0b6fb0721', '7f0e36665b66a449801e9808297c35', '665f67f0e37f14898082b072297c35', '7ec967f0e37f14998082b0787b06bd', '7f07e7f0e47f531b0723b0b6fb0721', '7f0e26665b66a449801e9808297c35', '665f67f0e37f1489801eb072297c35', '7ec967f0e37f14998082b0787b06bd', '7f07e7f0e47f531b0723b0b6fb0721', '7f0e27f1487f531b0b0bb0b6fb0722'], nStr1: [&quot;\\u65e5&quot;, &quot;\\u4e00&quot;, &quot;\\u4e8c&quot;, &quot;\\u4e09&quot;, &quot;\\u56db&quot;, &quot;\\u4e94&quot;, &quot;\\u516d&quot;, &quot;\\u4e03&quot;, &quot;\\u516b&quot;, &quot;\\u4e5d&quot;, &quot;\\u5341&quot;], nStr2: [&quot;\\u521d&quot;, &quot;\\u5341&quot;, &quot;\\u5eff&quot;, &quot;\\u5345&quot;], nStr3: [&quot;\\u6b63&quot;, &quot;\\u4e8c&quot;, &quot;\\u4e09&quot;, &quot;\\u56db&quot;, &quot;\\u4e94&quot;, &quot;\\u516d&quot;, &quot;\\u4e03&quot;, &quot;\\u516b&quot;, &quot;\\u4e5d&quot;, &quot;\\u5341&quot;, &quot;\\u51ac&quot;, &quot;\\u814a&quot;], lYearDays: function (y) { var i, sum = 348; for (i = 0x8000; i &gt; 0x8; i &gt;&gt;= 1) { sum += (calendar.lunarInfo[y - 1900] &amp; i) ? 1 : 0; } return (sum + calendar.leapDays(y)); }, leapMonth: function (y) { return (calendar.lunarInfo[y - 1900] &amp; 0xf); }, leapDays: function (y) { if (calendar.leapMonth(y)) { return ((calendar.lunarInfo[y - 1900] &amp; 0x10000) ? 30 : 29); } return (0); }, monthDays: function (y, m) { if (m &gt; 12 || m &lt; 1) { return -1 } return ((calendar.lunarInfo[y - 1900] &amp; (0x10000 &gt;&gt; m)) ? 30 : 29); }, solarDays: function (y, m) { if (m &gt; 12 || m &lt; 1) { return -1 } var ms = m - 1; if (ms == 1) { return (((y % 4 == 0) &amp;&amp; (y % 100 != 0) || (y % 400 == 0)) ? 29 : 28); } else { return (calendar.solarMonth[ms]); } }, toGanZhi: function (offset) { return (calendar.Gan[offset % 10] + calendar.Zhi[offset % 12]); }, getTerm: function (y, n) { if (y &lt; 1900 || y &gt; 2100) { return -1; } if (n &lt; 1 || n &gt; 24) { return -1; } var _table = calendar.sTermInfo[y - 1900]; var _info = [ parseInt('0x' + _table.substr(0, 5)).toString(), parseInt('0x' + _table.substr(5, 5)).toString(), parseInt('0x' + _table.substr(10, 5)).toString(), parseInt('0x' + _table.substr(15, 5)).toString(), parseInt('0x' + _table.substr(20, 5)).toString(), parseInt('0x' + _table.substr(25, 5)).toString() ]; var _calday = [ _info[0].substr(0, 1), _info[0].substr(1, 2), _info[0].substr(3, 1), _info[0].substr(4, 2), _info[1].substr(0, 1), _info[1].substr(1, 2), _info[1].substr(3, 1), _info[1].substr(4, 2), _info[2].substr(0, 1), _info[2].substr(1, 2), _info[2].substr(3, 1), _info[2].substr(4, 2), _info[3].substr(0, 1), _info[3].substr(1, 2), _info[3].substr(3, 1), _info[3].substr(4, 2), _info[4].substr(0, 1), _info[4].substr(1, 2), _info[4].substr(3, 1), _info[4].substr(4, 2), _info[5].substr(0, 1), _info[5].substr(1, 2), _info[5].substr(3, 1), _info[5].substr(4, 2), ]; return parseInt(_calday[n - 1]); }, toChinaMonth: function (m) { if (m &gt; 12 || m &lt; 1) { return -1 } var s = calendar.nStr3[m - 1]; s += &quot;\\u6708&quot;; return s; }, toChinaDay: function (d) { var s; switch (d) { case 10: s = '\\u521d\\u5341'; break; case 20: s = '\\u4e8c\\u5341'; break; case 30: s = '\\u4e09\\u5341'; break; default: s = calendar.nStr2[Math.floor(d / 10)]; s += calendar.nStr1[d % 10]; } return (s); }, getAnimal: function (y) { return calendar.Animals[(y - 4) % 12] }, solar2lunar: function (y, m, d) { if (y &lt; 1900 || y &gt; 2100) { return -1; } if (y == 1900 &amp;&amp; m == 1 &amp;&amp; d &lt; 31) { return -1; } if (!y) { var objDate = new Date(); } else { var objDate = new Date(y, parseInt(m) - 1, d) } var i, leap = 0, temp = 0; var y = objDate.getFullYear(), m = objDate.getMonth() + 1, d = objDate.getDate(); var offset = (Date.UTC(objDate.getFullYear(), objDate.getMonth(), objDate.getDate()) - Date.UTC(1900, 0, 31)) / 86400000; for (i = 1900; i &lt; 2101 &amp;&amp; offset &gt; 0; i++) { temp = calendar.lYearDays(i); offset -= temp; } if (offset &lt; 0) { offset += temp; i--; } var isTodayObj = new Date(), isToday = false; if (isTodayObj.getFullYear() == y &amp;&amp; isTodayObj.getMonth() + 1 == m &amp;&amp; isTodayObj.getDate() == d) { isToday = true; } var nWeek = objDate.getDay(), cWeek = calendar.nStr1[nWeek]; if (nWeek == 0) { nWeek = 7; } var year = i; var leap = calendar.leapMonth(i); var isLeap = false; for (i = 1; i &lt; 13 &amp;&amp; offset &gt; 0; i++) { if (leap &gt; 0 &amp;&amp; i == (leap + 1) &amp;&amp; isLeap == false) { --i; isLeap = true; temp = calendar.leapDays(year); } else { temp = calendar.monthDays(year, i); } if (isLeap == true &amp;&amp; i == (leap + 1)) { isLeap = false; } offset -= temp; } if (offset == 0 &amp;&amp; leap &gt; 0 &amp;&amp; i == leap + 1) { if (isLeap) { isLeap = false; } else { isLeap = true; --i; } } if (offset &lt; 0) { offset += temp; --i; } var month = i; var day = offset + 1; var sm = m - 1; var term3 = calendar.getTerm(year, 3); var gzY = calendar.toGanZhi(year - 4); gzY = calendar.toGanZhi(year - 4); //modify var firstNode = calendar.getTerm(y, (m * 2 - 1)); var secondNode = calendar.getTerm(y, (m * 2)); var gzM = calendar.toGanZhi((y - 1900) * 12 + m + 11); if (d &gt;= firstNode) { gzM = calendar.toGanZhi((y - 1900) * 12 + m + 12); } var isTerm = false; var Term = null; if (firstNode == d) { isTerm = true; Term = calendar.solarTerm[m * 2 - 2]; } if (secondNode == d) { isTerm = true; Term = calendar.solarTerm[m * 2 - 1]; } var dayCyclical = Date.UTC(y, sm, 1, 0, 0, 0, 0) / 86400000 + 25567 + 10; var gzD = calendar.toGanZhi(dayCyclical + d - 1); return { 'lYear': year, 'lMonth': month, 'lDay': day, 'Animal': calendar.getAnimal(year), 'IMonthCn': (isLeap ? &quot;\\u95f0&quot; : '') + calendar.toChinaMonth(month), 'IDayCn': calendar.toChinaDay(day), 'cYear': y, 'cMonth': m, 'cDay': d, 'gzYear': gzY, 'gzMonth': gzM, 'gzDay': gzD, 'isToday': isToday, 'isLeap': isLeap, 'nWeek': nWeek, 'ncWeek': &quot;\\u661f\\u671f&quot; + cWeek, 'isTerm': isTerm, 'Term': Term }; } }; //公历节日 var _festival1 = { '0101': '元旦节', '0202': '世界湿地日', '0210': '国际气象节', '0214': '情人节', '0301': '国际海豹日', '0303': '全国爱耳日', '0305': '学雷锋纪念日', '0308': '妇女节', '0312': '植树节', '0314': '国际警察日', '0315': '消费者权益日', '0317': '中国国医节 国际航海日', '0321': '世界森林日 消除种族歧视国际日 世界儿歌日', '0322': '世界水日', '0323': '世界气象日', '0324': '世界防治结核病日', '0325': '全国中小学生安全教育日', '0401': '愚人节', '0407': '世界卫生日', '0422': '世界地球日', '0423': '世界图书和版权日', '0424': '亚非新闻工作者日', '0501': '劳动节', '0504': '青年节', '0515': '防治碘缺乏病日', '0508': '世界红十字日', '0512': '国际护士节', '0515': '国际家庭日', '0517': '世界电信日', '0518': '国际博物馆日', '0520': '全国学生营养日', '0522': '国际生物多样性日', '0531': '世界无烟日', '0601': '国际儿童节 世界牛奶日', '0605': '世界环境日', '0606': '全国爱眼日', '0617': '防治荒漠化和干旱日', '0623': '国际奥林匹克日', '0625': '全国土地日', '0626': '国际禁毒日', '0701': '建党节 香港回归纪念日', '0702': '国际体育记者日', '0711': '世界人口日 航海日', '0801': '建军节', '0808': '中国男子节(爸爸节)', '0903': '抗日战争胜利纪念日', '0908': '国际扫盲日 国际新闻工作者日', '0910': '教师节', '0916': '国际臭氧层保护日', '0918': '九·一八事变纪念日', '0920': '国际爱牙日', '0927': '世界旅游日', '1001': '国庆节 国际音乐日 国际老人节', '1002': '国际非暴力日 国际和平与民主自由斗争日', '1004': '世界动物日', '1006': '老人节', '1008': '全国高血压日', '1005': '国际教师节', '1009': '世界邮政日', '1010': '辛亥革命纪念日 世界精神卫生日', '1013': '世界保健日 国际减灾日', '1014': '世界标准日', '1015': '国际盲人节(白手杖节)', '1016': '世界粮食日', '1017': '世界消除贫困日', '1022': '世界传统医药日', '1024': '联合国日 世界发展信息日', '1031': '世界勤俭日', '1107': '十月社会主义革命纪念日', '1108': '中国记者日', '1109': '全国消防安全宣传教育日', '1110': '世界青年节', '1111': '国际科学与和平周(本日所属的一周)', '1112': '孙中山诞辰纪念日', '1114': '联合国糖尿病日', '1117': '国际大学生节', '1121': '世界问候日 世界电视日', '1129': '国际声援巴勒斯坦人民国际日', '1201': '世界艾滋病日', '1203': '世界残疾人日', '1204': '宪法日', '1205': '国际志愿人员日', '1209': '世界足球日', '1210': '世界人权日', '1212': '西安事变纪念日', '1213': '南京大屠杀纪念日', '1220': '澳门回归纪念', '1221': '国际篮球日', '1224': '平安夜', '1225': '圣诞节', '1226': '毛泽东诞辰纪念日' }; //某月的第几个星期几,第3位为5表示最后一星期 var _festival2 = { '0110': '黑人日', '0150': '世界麻风日', '0440': '世界儿童日', '0520': '国际母亲节', '0532': '国际牛奶日', '0530': '全国助残日', '0630': '父亲节', '0711': '世界建筑日', '0730': '被奴役国家周', '0936': '世界清洁地球日', '0932': '国际和平日', '0940': '国际聋人节', '1011': '国际住房日', '1024': '世界视觉日', '1144': '感恩节', '1220': '国际儿童电视广播日' }; //农历节日 var _festival3 = { '0101': '春节', '0102': '初二', '0103': '初三', '0115': '元宵节', '0202': '龙抬头节', '0323': '妈祖生辰', '0505': '端午节', '0707': '七夕节', '0715': '中元节', '0815': '中秋节', '0909': '重阳节', '1208': '腊八节', '1223': '小年', '0100': '除夕' }; //假日安排数据 var _holiday = { '2011': { '0402': 0, '0403': 1, '0404': 1, '0405': 1, '0430': 1, '0501': 1, '0502': 1, '0604': 1, '0605': 1, '0606': 1, '0910': 1, '0911': 1, '0912': 1, '1001': 1, '1002': 1, '1003': 1, '1004': 1, '1005': 1, '1006': 1, '1007': 1, '1008': 0, '1009': 0, '1231': 0 }, '2012': { '0101': 1, '0102': 1, '0103': 1, '0121': 0, '0122': 1, '0123': 1, '0124': 1, '0125': 1, '0126': 1, '0127': 1, '0128': 1, '0129': 0, '0331': 0, '0401' : 0, '0402': 1, '0403': 1, '0404': 1, '0428': 0, '0429': 1, '0430': 1, '0501': 1, '0622': 1, '0623': 1, '0624': 1, '0929': 0, '0930': 1, '1001': 1, '1002': 1, '1003': 1, '1004': 1, '1005': 1, '1006': 1, '1007': 1 }, '2013': { '0101': 1, '0102': 1, '0103': 1, '0105': 0, '0106': 0, '0209': 1, '0210': 1, '0211': 1, '0212': 1, '0213': 1, '0214': 1, '0215': 1, '0216': 0, '0217': 0, '0404': 1, '0405': 1, '0406': 1, '0407': 0, '0427': 0, '0428': 0, '0429': 1, '0430': 1, '0501': 1, '0608': 0, '0609': 0, '0610': 1, '0611': 1, '0612': 1, '0919': 1, '0920': 1, '0921': 1, '0922': 0, '0929': 0, '1001': 1, '1002': 1, '1003': 1, '1004': 1, '1005': 1, '1006': 1, '1007': 1, '1012': 0 }, '2014': { '0101': 1, '0126': 0, '0131': 1, '0201': 1, '0202': 1, '0203': 1, '0203': 1, '0204': 1, '0205': 1, '0206': 1, '0208': 0, '0405': 1, '0406': 1, '0407': 1, '0501': 1, '0502': 1, '0503': 1, '0504': 0, '0531': 1, '0601': 1, '0602': 1, '0908': 1, '0928': 0, '1001': 1, '1002': 1, '1003': 1, '1004': 1, '1005': 1, '1006': 1, '1007': 1, '1011': 0 }, '2015': { '0101': 1, '0102': 1, '0103': 1, '0104': 0, '0215': 0, '0218': 1, '0219': 1, '0220': 1, '0221': 1, '0222': 1, '0223': 1, '0224': 1, '0228': 0, '0404': 1, '0405': 1, '0406': 1, '0501': 1, '0502': 1, '0503': 1, '0620': 1, '0621': 1, '0622': 1, '0903': 1, '0904': 1, '0905': 1, '0906': 0, '0927': 1, '1001': 1, '1002': 1, '1003': 1, '1004': 1, '1005': 1, '1006': 1, '1007': 1, '1010': 0 }, '2016': { '0101': 1, '0102': 1, '0103': 1, '0206': 0, '0207': 1, '0208': 1, '0209': 1, '0210': 1, '0211': 1, '0212': 1, '0213': 1, '0214': 0, '0402': 1, '0403': 1, '0404': 1, '0430': 1, '0501': 1, '0502': 1, '0609': 1, '0610': 1, '0611': 1, '0612': 0, '0915': 1, '0916': 1, '0917': 1, '0918': 0, '1001': 1, '1002': 1, '1003': 1, '1004': 1, '1005': 1, '1006': 1, '1007': 1, '1008': 0, '1009': 0 }, '2017': { '0101': 1, '0102': 1, '0122': 0, '0127': 1, '0128': 1, '0129': 1, '0130': 1, '0131': 1, '0201': 1, '0202': 1, '0204': 0, '0401': 0, '0402': 1, '0403': 1, '0404': 1, '0429': 1, '0430': 1, '0501': 1, '0527': 0, '0528': 1, '0529': 1, '0530': 1, '0930': 0, '1001': 1, '1002': 1, '1003': 1, '1004': 1, '1005': 1, '1006': 1, '1007': 1, '1008': 1, '1230': 1, '1231': 1 }, '2018': { '0101': 1, '0211': 0, '0215': 1, '0216': 1, '0217': 1, '0218': 1, '0219': 1, '0220': 1, '0221': 1, '0224': 0, '0405': 1, '0406': 1, '0407': 1, '0408': 0, '0428': 0, '0429': 1, '0430': 1, '0501': 1, '0616': 1, '0617': 1, '0618': 1, '0922': 1, '0923': 1, '0924': 1, '0929': 0, '0930': 0, '1001': 1, '1002': 1, '1003': 1, '1004': 1, '1005': 1, '1006': 1, '1007': 1, '1229': 0, '1230': 1, '1231': 1 }, '2019': { '0101': 1, '0202': 0, '0203': 0, '0204': 1, '0205': 1, '0206': 1, '0207': 1, '0208': 1, '0209': 1, '0210': 1, '0405': 1, '0406': 1, '0407': 1, '0428': 0, '0501': 1, '0502': 1, '0503': 1, '0504': 1, '0505': 0, '0607': 1, '0608': 1, '0609': 1, '0913': 1, '0914': 1, '0915': 1, '0929': 0, '1001': 1, '1002': 1, '1003': 1, '1004': 1, '1005': 1, '1006': 1, '1007': 1, '1012': 0 } }; //获取日期数据 var getDateObj = function (year, month, day) { var date = arguments.length &amp;&amp; year ? new Date(year, month - 1, day) : new Date(); return { 'year': date.getFullYear(), 'month': date.getMonth() + 1, 'day': date.getDate(), 'week': date.getDay() }; }; //当天 var _today = getDateObj(); //获取当月天数 var getMonthDays = function (obj) { var day = new Date(obj.year, obj.month, 0); return day.getDate(); }; if (!String.prototype.trim) { String.prototype.trim = function () { return this.replace(/^\\s+|\\s+$/g, ''); }; } //获取某天日期信息 var getDateInfo = function (obj) { var info = calendar.solar2lunar(obj.year, obj.month, obj.day); var cMonth = info.cMonth &gt; 9 ? '' + info.cMonth : '0' + info.cMonth; var cDay = info.cDay &gt; 9 ? '' + info.cDay : '0' + info.cDay; var lMonth = info.lMonth &gt; 9 ? '' + info.lMonth : '0' + info.lMonth; var lDay = info.lDay &gt; 9 ? '' + info.lDay : '0' + info.lDay; var code1 = cMonth + cDay; var code2 = cMonth + Math.ceil(info.cDay / 7) + info.nWeek % 7; var code3 = lMonth + lDay; var days = getMonthDays(obj); //节日信息 info['festival'] = ''; if (_festival3[code3]) { info['festival'] += _festival3[code3]; } if (_festival1[code1]) { info['festival'] += ' ' + _festival1[code1]; } if (_festival2[code2]) { info['festival'] += ' ' + _festival2[code2]; } if (obj['day'] + 7 &gt; days) { var code4 = cMonth + 5 + info.nWeek % 7; if (code4 != code2 &amp;&amp; _festival2[code4]) { info['festival'] += ' ' + _festival2[code4]; } } info['festival'] = info['festival'].trim(); //放假、调休等标记 info['sign'] = ''; if (_holiday[info.cYear]) { var holiday = _holiday[info.cYear]; if (typeof holiday[code1] != 'undefined') { info['sign'] = holiday[code1] ? 'holiday' : 'work'; } } if (info.cYear == _today.year &amp;&amp; info.cMonth == _today.month &amp;&amp; info.cDay == _today.day) { info['sign'] = 'today'; } return info; }; //获取日历信息 return (function (date) { var date = date || _today; var first = getDateObj(date['year'], date['month'], 1); //当月第一天 var days = getMonthDays(date); //当月天数 var data = []; //日历信息 var obj = {}; //上月日期 for (var i = first['week']; i &gt; 0; i--) { obj = getDateObj(first['year'], first['month'], first['day'] - i); var info = getDateInfo(obj); info['disabled'] = 1; data.push(info); } //当月日期 for (var i = 0; i &lt; days; i++) { obj = { 'year': first['year'], 'month': first['month'], 'day': first['day'] + i, 'week': (first['week'] + i) % 7 }; var info = getDateInfo(obj); info['disabled'] = 0; data.push(info); } //下月日期 var last = obj; for (var i = 1; last['week'] + i &lt; 7; i++) { obj = getDateObj(last['year'], last['month'], last['day'] + i); var info = getDateInfo(obj); info['disabled'] = 1; data.push(info); } return { 'date': getDateInfo(date), //当前日历选中日期 'data': data }; }); })(); function test() { console.log(getData({ 'year': 2019, 'month': 5, 'day': 14 })) } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;test()&quot;&gt;日历信息&lt;/button&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2019/05/14/JavaScript%E8%AE%A1%E7%AE%97%E5%86%9C%E5%8E%86/"},{"title":"Vue相关开源项目库汇总","text":"awesome-github-vue 是由OpenDigg整理并维护的Vue相关开源项目库集合。我们会定期同步OpenDigg上的项目到这里，也欢迎各位提交项目给我们。 如果收录的项目有错误，可以通过issue反馈给我们。这里的项目Star数不是实时更新的，一般是一周更新一次。 内容 UI组件 开发框架 实用库 服务端 辅助工具 应用实例 Demo示例 ###UI组件 element ★9689 - 饿了么出品的Vue2的web UI工具套件 Vux ★6927 - 基于Vue和WeUI的组件库 mint-ui ★4870 - Vue 2的移动UI元素 iview ★4782 - 基于 Vuejs 的开源 UI 组件库 Keen-UI ★2401 - 轻量级的基本UI组件合集 vue-material ★2294 - 通过Vue Material和Vue 2建立精美的app应用 muse-ui ★2052 - 三端样式一致的响应式 UI 库 vuetify ★1745 - 为移动而生的Vue JS 2组件框架 vonic ★1546 - 快速构建移动端单页应用 eme ★1402 - 优雅的Markdown编辑器 vue-multiselect ★1193 - Vue.js选择框解决方案 vue-table ★844 - 简化数据表格 VueCircleMenu ★790 - 漂亮的vue圆环菜单 vue-chat ★755 - vuejs和vuex及webpack的聊天示例 radon-ui ★643 - 快速开发产品的Vue组件库 vue-waterfall ★615 - Vue.js的瀑布布局组件 vueAdmin ★612 - 基于vuejs2和element的简单的管理员模板 vue-carbon ★602 - 基于 vue 开发MD风格的移动端 vue-beauty ★589 - 由vue和ant design创建的优美UI组件 vue-blu ★582 - 帮助你轻松创建web应用 vue-syntax-highlight ★560 - Sublime Text语法高亮 vue-infinite-scroll ★544 - VueJS的无限滚动指令 Vue.Draggable ★536 - 实现拖放和视图模型数组同步 bootstrap-vue ★525 - 应用于Vuejs2的Twitter的Bootstrap 4组件 vue-awesome-swiper ★524 - vue.js触摸滑动组件 vue-calendar ★468 - 日期选择插件 vue-amap ★372 - 基于Vue 2和高德地图的地图组件 vue-swipe ★369 - VueJS触摸滑块 vue-chartjs ★362 - vue中的Chartjs的封装 vue-datepicker ★339 - 日历和日期选择组件 vue-echarts ★337 - VueJS的ECharts组件 Gokotta ★325 - 简单的音乐播放器 markcook ★319 - 好看的markdown编辑器 vue-sortable ★299 - 轻松添加拖拽排序 vue-google-maps ★289 - 带有双向数据绑定Google地图组件 vue-progressbar ★255 - vue轻量级进度条 vue-picture-input ★241 - 移动友好的图片文件输入组件 vue-infinite-loading ★233 - VueJS的无限滚动插件 vue-paginate ★216 - 分页数据的简约VueJS插件 vue-upload-component ★215 - Vuejs文件上传组件 vue-scroller ★212 - Vonic UI的功能性组件 vue-quill-editor ★204 - 基于Quill适用于Vue2的富文本编辑器 vue-datetime-picker ★202 - 日期时间选择控件 vue-video-player ★192 - VueJS视频及直播播放器 vue2-calendar ★184 - 支持lunar和日期事件的日期选择器 vue-fullcalendar ★179 - 基于vue.js的全日历组件 rubik ★178 - 基于Vuejs2的开源 UI 组件库 vue-mugen-scroll ★175 - 无限滚动组件 vue-tables-2 ★172 - 显示数据的bootstrap样式网格 VueStar ★172 - 带星星动画的vue点赞按钮 mint-loadmore ★171 - VueJS的双向下拉刷新组件 vue-virtual-scroller ★168 - 带任意数目数据的顺畅的滚动 vue-core-image-upload ★166 - 轻量级的vue上传插件 DataVisualization ★157 - 数据可视化 Vueditor ★147 - 所见即所得的编辑器 vue-html5-editor ★137 - html5所见即所得编辑器 vue-slider ★130 - vue 滑动组件 vue-msgbox ★128 - vuejs的消息框 vue-slide ★127 - vue轻量级滑动组件 vue-lazyload-img ★120 - 移动优化的vue图片懒加载插件 vue-dragula ★117 - 使拖放变得简单 vue-drag-and-drop-list ★115 - 创建排序列表的Vue指令 vuwe ★111 - 基于微信WeUI所开发的专用于Vue2的组件库 vue-dropzone ★110 - 用于文件上传的Vue组件 vue-progressive-image ★109 - Vue的渐进图像加载插件 vue-charts ★106 - 轻松渲染一个图表 vue-carousel-3d ★103 - VueJS的3D轮播组件 vue-swiper ★101 - 易于使用的滑块组件 vue-datasource ★98 - 创建VueJS动态表格 vue-images ★94 - 显示一组图片的lightbox组件 vue-region-picker ★94 - 选择中国的省份市和地区 vue-slider-component ★93 - 在vue1和vue2中使用滑块 vue-impression ★92 - 移动Vuejs2 UI元素 vue-typer ★89 - 模拟用户输入选择和删除文本的Vue组件 vue-loading ★89 - 元素中加载block的Vue指令 vue-instant ★88 - 轻松创建自动提示的自定义搜索控件 vue-dragging ★87 - 使元素可以拖拽 vue-datatable ★87 - 使用Vuejs创建的DataTableView vue2-loading-bar ★81 - 最简单的仿Youtube加载条视图 vue-datepicker ★76 - 漂亮的Vue日期选择器组件 vue-highcharts ★73 - HighCharts组件 vue-video ★73 - Vue.js的HTML5视频播放器 vue-tooltip ★71 - 带绑定信息提示的提示工具 vue-image-crop-upload ★70 - vue图片剪裁上传组件 vue-toast-mobile ★68 - VueJS的toast插件 vue-simplemde ★66 - VueJS的Markdown编辑器组件 vue-touch-ripple ★64 - vuejs的触摸ripple组件 vue-svgicon ★62 - 创建svg图标组件的工具 vue2-timepicker ★61 - 下拉时间选择器 coffeebreak ★61 - 实时编辑CSS组件工具 vue-date-picker ★60 - VueJS日期选择器组件 vue-scrollbar ★59 - 最简单的滚动区域组件 vue-placeholders ★57 - 处理占位符图片和乱码 vue-google-signin-button ★56 - 导入谷歌登录按钮 vue-quill ★56 - vue组件构建quill编辑器 vue-float-label ★54 - VueJS浮动标签模式 vue-baidu-map ★51 - 基于 Vue 2的百度地图组件库 vue2-editor ★49 - HTML编辑器 vue-social-sharing ★47 - 社交分享组件 vue-easy-slider ★43 - Vue 2.x的滑块组件 awesome-mask ★43 - 拥有独一无二mask的表单 vue-tagsinput ★41 - 基于VueJS的标签组件 datepicker ★38 - 基于flatpickr的时间选择组件 vue-music-master ★38 - vue手机端网页音乐播放器 vue-chart ★37 - 强大的高速的vue图表解析 handsontable ★35 - 网页表格组件 vue-popup-mixin ★35 - 用于管理弹出框的遮盖层 we-vue ★34 - Vue2及weui1开发的组件 cubeex ★33 - 包含一套完整的移动UI vue-fullcalendar ★33 - vue FullCalendar封装 vue-slick ★33 - 实现流畅轮播框的vue组件 vue-morris ★32 - Vuejs组件封装Morrisjs库 vue-material-design ★32 - Vue MD风格组件 vue-bootstrap-table ★31 - 可排序可检索的表格 vue-img-inputer ★30 - 基于Vue2的图片输入框 vue-radial-progress ★29 - Vue.js放射性进度条组件 vue-image-clip ★29 - 基于vue的图像剪辑组件 vue-form-2 ★27 - 全面的HTML表单管理的解决方案 vue-pull-to-refresh ★27 - Vue2的上拉下拉 vue-side-nav ★27 - 响应式的侧边导航 mint-indicator ★26 - VueJS移动加载指示器插件 vue-ripple ★26 - 制作谷歌MD风格涟漪效果的Vue组件 vue-lazy-background-images ★25 - 懒加载背景组件的Vue组件 vue-touch-keyboard ★24 - VueJS虚拟键盘组件 chartjs ★24 - Vue Bulma的chartjs组件 vue-scroll ★24 - vue滚动 vue-chartkick ★23 - VueJS一行代码实现优美图表 vue-ztree ★22 - 用 vue 写的树层级组件 vue-m-carousel ★21 - vue 移动端轮播组件 vue-datepicker-simple ★20 - 基于vue的日期选择器 vue-tabs ★20 - 多tab页轻型框架 vue-verify-pop ★19 - 带气泡提示的vue校验插件 vue-waves ★17 - waves的VueJS版本 vue-parallax ★15 - 整洁的视觉效果 vue-city ★14 - 城市选择器 vue-img-loader ★14 - 图片加载UI组件 vue-typewriter ★13 - vue组件类型 vue-smoothscroll ★12 - smoothscroll的VueJS版本 vue-tree ★11 - vue树视图组件 vue-laypage ★9 - 简单的VueJS分页组件 vue-ios-alertview ★8 - iOS7+ 风格的alertview服务 dd-vue-component ★7 - 订单来了的公共组件库 paco-ui-vue ★7 - PACOUI的vue组件 vue-cmap ★5 - Vue China map可视化组件 vue-button ★4 - Vue按钮组件 ###开发框架 vue.js ★46256 - 流行的轻量高效的前端组件化方案 vue-admin ★3340 - Vue管理面板框架 quasar ★1476 - 响应式网站和混合移动应用程序 vuepack ★1365 - 现代VueJS启动器 electron-vue ★1333 - Electron及VueJS快速启动样板 vue-2.0-boilerplate ★247 - Vue2单页应用样板​ vue-spa-template ★232 - 前后端分离后的单页应用开发 Framework7-Vue ★217 - VueJS与Framework7结合 vue-bulma ★139 - 轻量级高性能MVVM Admin UI框架 vue-webgulp ★101 - 仿VueJS Vue loader示例 vue-fullstack ★84 - 实时的用户友好的后台系统 vue-element-starter ★37 - vue启动页 ###实用库 vuex ★6160 - 专为 Vue.js 应用程序开发的状态管理模式 vue-validator ★1612 - vue的验证器插件 vue-loader ★1484 - Vue.js 针对Webpack的组件装载插件 vue-lazyload ★821 - 用于懒加载的Vue模块 vuelidate ★778 - 简单轻量级的基于模块的Vue.js验证 vue-i18n ★716 - VueJS的多语言切换插件 qingcheng ★680 - qingcheng主题 vue-desktop ★464 - 创建管理面板网站的UI库 Vue-Socketio ★341 - VueJS的socketio实现 vue-head ★295 - head标签的meta信息操作 vue-meta ★269 - 管理app的meta信息 meteor-vue-component ★266 - vue和meteor整合 vue-axios ★229 - 将axios整合到VueJS的封装 vue-flatpickr ★179 - 封装Flatpickr的Vue组件 avoriaz ★135 - VueJS测试实用工具库 vue-svg-icon ★116 - vue2的可变彩色svg图标方案 vue-focus ★107 - 可重用VueJS组件的焦点指令 vue-animate ★88 - 跨浏览器CSS3动画库 vue-framework7 ★83 - 结合VueJS使用的Framework7组件 vue-bootstrap-modal ★82 - vue的Bootstrap样式组件 vuep ★76 - 用实时编辑和预览来渲染Vue组件 vue-online ★68 - reactive的在线和离线组件 vue-lazy-render ★68 - 用于Vue组件的延迟渲染 vue-password-strength-meter ★67 - 交互式密码强度计 vue-clipboard ★64 - VueJS的剪贴板 element-admin ★62 - 支持 vuecli 的 Element UI 的后台模板 portal-vue ★56 - 在组件外部渲染DOM vue-events ★55 - 简化事件的VueJS插件 vue-electron ★55 - 将选择的API封装到Vue对象中的插件 cleave ★55 - 基于cleave.js的Cleave组件 vue-cordova ★54 - Cordova的VueJS插件 vue-shortkey ★53 - 应用于Vue.js的Vue-ShortKey 插件 vue-router-transition ★52 - 页面过渡插件 vue-gesture ★50 - VueJS的手势事件插件 vue-property-decorator ★49 - VueJS和属性Decorator vue-qart ★49 - 用于qartjs的Vue2指令 vue-recyclist ★48 - vuejs无限滚动列表 http-vue-loader ★47 - 从html及js环境加载vue文件 vuemit ★47 - 处理VueJS事件 vue-websocket ★46 - VueJS的Websocket插件 vue-local-storage ★45 - 具有类型支持的Vuejs本地储存插件 vuedeux ★43 - 轻量级开源实用用层 vue-scrollTo ★42 - 滚动到元素的VueJS指令 lazy-vue ★42 - 懒加载图片 vue-bus ★39 - VueJS的事件总线 vue-reactive-storage ★35 - vue插件的Reactive层 vue-helmet ★34 - HTML标题管理器 voir ★33 - 保持mutation与视图组件的分离 vue-lazy-component ★33 - 懒加载组件或者元素的Vue指令 v-media-query ★33 - vue中添加用于配合媒体查询的方法 vue-notifications ★32 - 非阻塞通知库 vue-observe-visibility ★32 - 当元素在页面上可见或隐藏时检测 vue-ts-loader ★32 - 在Vue装载机检查脚本 vue-pagination-2 ★30 - 简单通用的分页组件 Vue.resize ★27 - 检测HTML调整大小事件的vue指令 vuex-i18n ★26 - 定位插件 vuex-shared-mutations ★25 - 分享某种Vuex mutations vue-acl ★24 - VueJS访问控制列表插件 modal ★17 - Vue Bulma的modal组件 vue-file-base64 ★16 - 将文件转换为Base64的vue组件 vue-drag-zone ★15 - 适用于Vue2的dom拖动组件 Famous-Vue ★15 - Famous库的vue组件 leo-vue-validator ★13 - 异步的表单验证组件 Vue.ImagesLoaded ★12 - 检测图片加载的VueJS指令 vue-titlecase ★12 - 用于字符串titlecased的VueJS过滤器 Vue-Easy-Validator ★11 - 简单的表单验证 vue-truncate-filter ★9 - 截断字符串的VueJS过滤器 vue-zoombox ★9 - 一个高级zoombox vue-input-autosize ★5 - 基于内容自动调整文本输入的大小 vue-lazyloadImg ★4 - 图片懒加载插件 ###服务端 nuxt.js ★2810 - 用于服务器渲染Vue app的最小化框架 express-vue ★152 - 简单的使用服务器端渲染vue.js vue-ssr ★70 - 非常简单的VueJS服务器端渲染模板 vue-ssr ★57 - 结合Express使用Vue2服务端渲染 vue-easy-renderer ★25 - Nodejs服务端渲染 ###辅助工具 DejaVue ★559 - Vuejs可视化及压力测试 vue-play ★461 - 展示Vue组件的最小化框架 vscode-VueHelper ★194 - 目前vscode最好的vue代码提示插件 vue-generate-component ★40 - 轻松生成Vue js组件的CLI工具 vue-multipage-cli ★33 - 简单的多页CLI VuejsStarterKit ★26 - vuejs starter套件 ###应用实例 koel ★7214 - 基于网络的个人音频流媒体服务 pagekit ★4037 - 轻量级的CMS建站系统 vuedo ★1059 - 博客平台 jackblog-vue ★965 - 个人博客系统 [PJ Blog](https://github.com/jcc/PJ Blog) ★732 - 开源博客 vue-cnode ★628 - 重写vue版cnode社区 CMS-of-Blog ★415 - 博客内容管理器 rss-reader ★328 - 简单的rss阅读器 vue-ghpages-blog ★211 - 依赖GitHub Pages无需本地生成的静态博客 tomato5 ★112 - 实时的协作工具 swoole-vue-webim ★99 - Web版的聊天应用 vue-dashing-js ★70 - nuvo-dashing-js的fork fewords ★53 - 功能极其简单的笔记本 vue-blog ★40 - 使用Vue2.0 和Vuex的vue-blog ###Demo示例 vue2-elm ★2965 - 重写饿了么webapp Vue-cnodejs ★2156 - 基于vue重写Cnodejs.org的webapp NeteaseCloudWebApp ★1208 - 高仿网易云音乐的webapp vue-zhihu-daily ★885 - 知乎日报 with Vuejs vue-wechat ★777 - vue.js开发微信app界面 vue2-demo ★725 - 从零构建vue2 + vue-router + vuex 开发环境 eleme ★639 - 高仿饿了么app商家详情 vue-demo ★590 - vue简易留言板 spa-starter-kit ★514 - 单页应用启动套件 maizuo ★511 - vue/vuex/redux仿卖座网 vue-music ★502 - Vue 音乐搜索播放 vue-Meizi ★413 - vue最新实战项目 douban ★403 - 模仿豆瓣前端 zhihudaily-vue ★391 - 知乎日报web版 vue-shopping ★339 - 蘑菇街移动端 VueDemo_Sell_Eleme ★332 - Vue2高仿饿了么外卖平台 vue-demo-kugou ★327 - vuejs仿写酷狗音乐webapp vue2.0-taopiaopiao ★256 - vue2.0与express构建淘票票页面 vue-leancloud-blog ★242 - 一个前后端完全分离的单页应用 node-vue-server-webpack ★241 - Node.js+Vue.js+webpack快速开发框架 mi-by-vue ★227 - VueJS仿小米官网 easy-vue ★216 - 使用Vue实现简易web vue2.x-douban ★211 - Vue2实现简易豆瓣电影webApp vue-fis3 ★201 - 流行开源工具集成demo vue-demo-maizuo ★192 - 使用Vue2全家桶仿制卖座电影 vue-zhihudaily ★171 - 知乎日报 Web 版本 vue-axios-github ★170 - 登录拦截登出功能 vue-adminLte-vue-router ★167 - vue和adminLte整合应用 xyy-vue ★141 - 大学生交流平台 Zhihu-Daily-Vue.js ★139 - Vuejs单页网页应用 hello-vue-django ★116 - 使用带有Django的vuejs的样板项目 gouyan-movie-vue ★107 - 基于vue的在线电影影讯网站 x-blog ★105 - 开源的个人blog项目 vue-express-mongodb ★104 - 简单的前后端分离案例 vue-cnode ★104 - vue单页应用demo notepad ★95 - 本地存储的记事本 websocket_chat ★95 - 基于vue和websocket的多人在线聊天室 photoShare ★90 - 基于图片分享的社交平台 vueBlog ★82 - 前后端分离博客 vue-zhihudaily-2.0 ★82 - 使用Vue2.0+vue-router+vuex创建的zhihudaily vue-ruby-china ★73 - VueJS框架搭建的rubychina平台 Zhihu_Daily ★70 - 基于Vue和Nodejs的Web单页应用 vue-koa-demo ★64 - 使用Vue2和Koa1的全栈demo vue2.x-Cnode ★55 - 基于vue全家桶的Cnode社区 vue-trip ★49 - vue2做的出行webapp life-app-vue ★49 - 使用vue2完成多功能集合到小webapp github-explorer ★49 - 寻找最有趣的GitHub库 vue-ssr-boilerplate ★47 - 精简版的ofvue-hackernews-2 vue-bushishiren ★46 - 不是诗人应用 houtai ★45 - 基于vue和Element的后台管理系统 ios7-vue ★38 - 使用vue2.0 vue-router vuex模拟ios7 Framework7-VueJS ★38 - 使用移动框架的示例 vue-cli-multipage-bootstrap ★37 - 将vue官方在线示例整合到组件中 cnode-vue ★37 - 基于vue和vue-router构建的cnodejs web网站SPA vue-cnode ★34 - 用 Vue 做的 CNode 官网 seeMusic ★32 - 跨平台云音乐播放器 HyaReader ★31 - 移动友好的阅读器 zhihu-daily ★28 - 轻松查看知乎日报内容 vue-music163 ★26 - 音乐VueJS项目 vue-cnode ★22 - 使用cNode社区提供的接口 sls-vuex2-demo ★21 - vuex2商城购物车demo zhihu-daily-vue ★20 - 知乎日报 vue-cnode-mobile ★20 - 搭建cnode社区 gank ★18 - gankio资源的阅读应用 vue-dropload ★18 - 用以测试下拉加载与简单路由 Vuejs-SalePlatform ★17 - vuejs搭建的售卖平台demo Todos_Vuejs ★17 - vuejs2搭建的极简的todolist v-notes ★17 - 简单美观的记事本 vue-starter ★16 - VueJs项目的简单启动页 vue-memo ★10 - 用 vue写的记事本应用 simply-calculator-vuejs ★7 - 用VueJS实现简易计算器","link":"/2017/03/21/Vue%E7%9B%B8%E5%85%B3%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%BA%93%E6%B1%87%E6%80%BB/"},{"title":"Go 简易教程","text":"关于本书授权许可本书中的内容使用 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享4.0许可协议）授权。你不必为此书付费。你可以免费的复制、发布、修改或者展示此书。但是，这本书的版权归原作者Karl Seguin所有，不要将此书用于商业目的。 关于许可证的全部内容你可以浏览以下网站： http://creativecommons.org/licenses/by-nc-sa/4.0/ 最新版本这本书的最新版本可以在以下网站获得:http://github.com/karlseguin/the-little-go-book 前言每次提起学习一门新语言，我真的是又爱又恨。一方面，语言是我们的行事之本，即使一些小的变化都会对事情有重大的影响。可能有时一闪而过的 灵感 就会对你如何编程产生长久的影响力，并重新定义你对其他语言的期望。而头疼的是，语言的设计是呈增量式的，要学习新的关键字、类型系统、代码风格以及新的库、社区和范例真的是难言其苦。相比于所有其他必须学习的事情，花时间在一门新的语言上貌似真的是很糟糕的投资。 即便如此，我们还是得走下去。我们 必须 得乐于每天一点点地进步，因为“语言是我们的行事之本”。虽然语言的变化往往会是循序渐进的，但它影响范围仍然很广，包括了有生产率、可读性、性能、可测试性、依赖性管理、错误处理、文档、简要、社区、标准库等等。所以，有好点的说法来形容 千刀万剐 么？ 留给我们一个重要问题就是：为什么选择 Go? 。对于我来说，有两条原因。第一条，它是一种相对简单的语言，且具有相对简单的标准库。在很多方面，Go 的特性语法是为了简化我们在过去几十年中添加到编程语言中的一些复杂特性。另外一条原因就是对于许多开发者来说，它将补充您的知识面。 Go 是作为系统语言（例如：操作系统，设备驱动程序）创建的，因此它针对的是 C 和 C++ 开发人员。按照 Go 团队的说法，应用程序开发人员已经成为 Go 的主要用户而不是系统开发人员了，这个说法我也是相信的。为什么？我不能权威的代表系统开发人员说话，但对于我们这些构建网站，服务，桌面应用程序等的人来说，它可以部分的归结为对一类系统的新兴需求，这类系统介于低级系统应用程序和更高级的应用程序之间。 可能 Go 语言有消息传递机制，缓存，重计算数据分析，命令行接口，体制和监控，我不知道给 Go 语言什么样的标签，但是在我的职业生涯中，随着系统的复杂性不断增加，以及动辄成千上万的并发，显然对定制基础类型系统的需求不断增加。你可以使用 Ruby 或者 Python 构建这样的系统（大多人都这样做），但这些类型的系统可以从更严格的类型系统和更高的性能中受益。类似地，你可以使用 Go 来构建网站（很多人都愿意这样做），但我仍然喜欢 Node 或者 Ruby 对这类系统展现出的表现力。 Go 语言还擅长其他领域。比如，当运行一个编译过的 Go 程序时，他没有依赖性。你不必担心用户是安装了 Ruby 或者 JVM，如果这样，你还要考虑版本。出于这个原因，Go 作为命令行程序以及其他并发类型的工具（日志收集器）的开发语言变得越来越流行。 坦白来说，学习 Go 可以有效利用你的时间。你不必担心会花费很长时间学习 Go 甚至掌握它，你最终会从你的努力中得到一些实用的东西。 作者注解对于写这本书我犹豫再三，主要有两个原因。第一个是 Go 有自己的文档，特别是 Effective Go。 另一个是在写一本关于语言类的书的时候我会有点不安。当我们写 《 The Little MongoDB Book》 这本书的时候，我完全假设大多数读者已经理解了关系型数据库和建模的基本知识。在写 《The Little Redis Book》这本书的时候，你也可以同样假设读者已经熟悉键值存储。 在我考虑未来的某些章节的时候，我知道不能再做出同样的假设。你花多长时间学习并理解接口，这是个新的概念，我希望你从中学到的不仅仅是 Go 有提供接口，并且还有如何使用它们。最终，我希望你向我反馈本书的哪部分讲得太细或者太粗，我会感到很欣慰，也算是我对读者们的小小要求了。 第一章 · 基础入门如果你想去尝试运行 Go 的代码，你可以去看看 Go Playground ,它可以在线运行你的代码并且不要安装任何东西。这也是你在 Go 的论坛区和 StackOverflow 等地方寻求帮助时分享 Go 代码的最常用方法。 Go 的安装很简单。你可以用源码去安装，但是我还是建议你使用其中一个预编译的二进制文件。当你 跳转到下载页面，你将会看到 Go 语言的在各个平台上的安装包。我们会避免这些东西并且学会如何在自己的平台上安装好 Go。正如你所看到的的那样，安装 Go 并不是很难。 除了一些简单的例子， Go 被设计成代码在工作区内运行。工作区是一个文件夹，这个文件夹由 bin ，pkg，以及src子文件夹组成的。你可能会试图强迫 Go 遵循自己的风格-不要这么去做。 一般，我把我的项目放在 ~/code 文件夹下。比如，~/code/blog 目录就包含了我的 blog 项目。对于 Go 来说，我的工作区域就是 ~/code/go ，然后我的 Go 写的项目代码就在 ~/code/go/src/blog 文件夹下。 简单来说，无论你希望把你的项目放在哪里，你最好创建一个 go 的文件夹，再在里面创建一个 src 的子文件夹。 OSX / Linux 系统安装 Go下载适合你自己电脑系统的 tar.gz 文件。对于 OSX 系统来说，你可能会对 go#.#.#.darwin-amd64-osx10.8.tar.gz 感兴趣，其中 #.#.# 代表 Go 的最新版本号。 通过 tar -C /usr/local -xzf go#.#.#.darwin-amd64-osx10.8.tar.gz 命令将文件加压缩到 /usr/local 目录下 设置两个环境变量： 1.GOPATH 指向的是你的工作目录，对我来说，那个目录就是 $HOME/code/go2.我们需要将 Go 的二进制文件添加到的 PATH变量中。 你可以通过下面的 shell 去设置这两个环境变量： echo 'export GOPATH=$HOME/code/go' &gt;&gt; $HOME/.profile echo 'export PATH=$PATH:/usr/local/go/bin' &gt;&gt; $HOME/.profile 你需要将这些环境变量激活。你可以关掉 shell 终端，然后在打开 shell 终端，或者你可以在 shell 终端运行 source $HOME/.profile。 在命令终端输入 go version，你将会得到一个 go version go1.3.3 darwin / amd64 的输出，Go 就安装完成了。 Windows 系统下载最新的 zip 文件。如果你的电脑是 64 位的系统，你将需要 go#.#.#.windows-amd64.zip ，这里的 #.#.# 是 Go 的最新版本号。 解压缩 go#.#.#.windows-amd64.zip 文件到你选择的位置。 c:\\Go这个位置是个不错的选择。 在系统中设置两个环境变量： GOPATH 同样的指向的是你的工作目录。这个变量看起来像c:\\users\\goku\\work\\go 这个样子。 添加 c:\\Go\\bin 到系统的 PATH 环境变量。 你可以通过「系统」 控制面板的 「高级」 选项卡上的 「环境变量」按钮设置环境变量。 某些版本的 Windows 通过「系统」控制面板中的「高级系统选项」选项此控制面板。 打开一个 cmd 命令终端，输入 go version。 你会得到一个 go version go1.3.3 windows/amd64 的输出，即表示 Go 安装完成。 Go 是一门编译型，具有静态类型和类 C 语言语法的语言，并且有垃圾回收（GC）机制。这是什么意思？ 编译编译是将源代码翻译为更加低级的语言的过程——翻译成汇编语言（例如 Go），或是翻译成其他中间语言（如 Java 和 C#）。 编译型语言可能会让你很不爽，因为编译过程实在是太慢了。如果每次都需要花好几分钟甚至好几个小时去等待代码编译的话，很难进行快速迭代。而编译速度是 Go 的主要优化目标之一。这对我们这些从事大型项目开发或者是习惯用解释型快速看到程序结果的人来说，确实是一件好事。 编译型语言注重于运行速度和无依赖执行程序（至少对于 C/C++ 和 Go 来说是这样的，直接将依赖编译到程序中）。 静态类型静态类型意味着变量必须是特定的类型（如：int, string, bool, []byte 等等），这可以通过在声明变量的时候，指定变量的类型来实现，或者让编译器自行推断变量的类型（我们将很快可以看到实例）。 关于静态类型的东西，可以说的还有很多，但是我相信通过看代码能更好的理解静态类型是什么。如果你习惯于动态类型语言， 你可能会发现这很麻烦。这种想法没错，但是静态类型语言也有优点，特别是当你将静态类型和编译配对使用时。这两者经常混为一谈。确实当你有其中一个的时候，通常也会有另一个，但是这不是硬性规定的。使用强类型系统，编译器能够检测除语法错误之外的问题从而进一步优化。 类 C 语法当说到一门语言是类 C 语法的时候，通常意味着如果你用过其他类 C 语言如：C，C++，Java，JavaScript 和 C#，你会觉得 Go 的语法很熟悉——最少表面上是这样的。举个例子，&amp;&amp; 用于逻辑 AND，== 用于判断是否相等，{ 和 } 是块的开始和结束，数组下标的起始值为 0。 类 Ｃ 语法也倾向于用分号表示作为语句结束符，并将条件写在括号中。Go 不支持这些，但是仍然使用括号来控制优先级。例如，一个 if 语句是这样的： 123if name == &quot;Leto&quot; { print(&quot;the spice must flow&quot;)} 在很多复杂系统中，括号符还是很有用的： 123if (name == &quot;Goku&quot; &amp;&amp; power &gt; 9000) || (name == &quot;gohan&quot; &amp;&amp; power &lt; 4000) { print(&quot;super Saiyan&quot;)} 除此之外，Go 要比 C# 或 Java 更接近 C - 不仅是语法方面，还有目的方面。这反映在语言的简洁和简单上，希望你在学习它的时候能慢慢体会这一点。 变量和申明如果我们用 x = 4 来申明和赋值变量，那么我们就可以同时开始和结束对变量的查看了。遗憾的是，Go 更为复杂些。我们将通过简单的示例来开始我们的学习。然后，在下一章中，我们会在创建和使用结构体时，进一步扩展。尽管如此，你可能还得花一段时间来适应，才能感受到它带给你的舒适感。 你可能会想：“哇！这有什么复杂的？”。 让我们开始一个例子。 下面的例子是 Go 中，申明变量和赋值最为明确的方法，但也是最为冗长的方法： 1234567891011package mainimport ( &quot;fmt&quot;)func main() { var power int power = 9000 fmt.Printf(&quot;It's over %d\\n&quot;, power)} 这里我们定义了一个 int 类型的变量 power。默认情况下，Go 会为变量分配默认值。Integers 的默认值是 0，booleans 默认值是 false，strings 默认值是 &quot;&quot; 等等。下面，我们创建一个值为 9000 的名为 power 的变量。我们可以将定义和赋值两行代码合并起来： 1var power int = 9000 不过，这么写太长了。Go 提供了一个方便的短变量声明运算符 := ，它可以自动推断变量类型： 1power := 9000 这非常方便，它可以跟函数结合使用，就像这样： 1234567func main() { power := getPower()}func getPower() int { return 9001} 值得注意的是要用 := 来声明变量以及给变量赋值。相同变量不能被声明两次（在相同作用域下），如果你尝试这样，会收到错误提示。 123456789func main() { power := 9000 fmt.Printf(&quot;It's over %d\\n&quot;, power) // 编译器错误： // := 左侧不是新的变量 power := 9001 fmt.Printf(&quot;It's also over %d\\n&quot;, power)} 编辑器会告诉你 * := 左侧不是新的变量*。这就意味着当我们首次声明一个变量时应该使用 := ，后面再给变量赋值时应该使用 =。这似乎很有道理，但是凭空来记忆且需要根据情况来切换却是很难的事。 如果你仔细阅读代码的错误信息，你会发现 variables 单词是个复数，即有多个变量，那是因为go支持多个变量同时赋值（使用 = 或者 :=）： 1234func main() { name, power := &quot;Goku&quot;, 9000 fmt.Printf(&quot;%s's power is over %d\\n&quot;, name, power)} 另外，多个变量赋值的时候，只要其中有一个变量是新的，就可以使用:=。例如： 1234567func main() { power := 1000 fmt.Printf(&quot;default power is %d\\n&quot;, power) name, power := &quot;Goku&quot;, 9000 fmt.Printf(&quot;%s's power is over %d\\n&quot;, name, power)} 尽管变量 power 使用了两次:=，但是编译器不会在第 2 次使用 :=时报错，因为这里有一个新的 name变量，它可以使用:=。然后你不能改变 power 变量的类型，它已经被声明成一个整型，所以只能赋值整数。 到目前为止，你最后需要了解的一件事是，Go 会像 import 一样，不允许你在程序中拥有未使用的变量。例如： 1234func main() { name, power := &quot;Goku&quot;, 1000 fmt.Printf(&quot;default power is %d\\n&quot;, power)} 这将不会通过编译，因为 name 是一个被申明但是未被使用的变量，就像 import 的包未被使用时，也将会导致编译失败，但总的来说，我认为这有助于提高代码的清洁度和可读性。 还有更多关于的申明和赋值的技巧。初始化一个变量时，请使用： var NAME TYPE；给变量申明及赋值时，请使用： NAME := VALUE ； 给之前已经申明过的变量赋值时，请使用： NAME = VALUE 垃圾回收一些变量，在创建的时候，就拥有一个简单定义的生命周期。对于函数中的变量，会在函数执行完后进行销毁。在别的语言中，对于编译器而言，这不会很明显。例如：函数返回的变量，或者由其他变量和对象所调用的变量，它们的生命周期是很难确定的。 如果没有垃圾回收机制，那么开发人员就得知道有哪些不需要用到的变量，并将它们释放。就像 C 语言，你需要使用 free(str); 来释放变量。 语言的垃圾回收机制（像：Ruby, Python, Java, JavaScript, C# , Go）是会对变量进行跟踪，并在没有使用它们的时候，进行释放。垃圾回收会增加一些额外的开销，但是也减少了一些致命性的 BUG。 运行 go 代码创建一个简单的程序然后学习如何编译和运行它。打开你的文本编辑器写入下面的代码： 12345package mainfunc main() { println(&quot;it's over 9000!&quot;)} 保存文件并命名为 main.go 。 你可以将文件保存在任何地方；不必将这些琐碎的例子放在 go 的工作空间内。 接下来，打开一个 shell 或者终端提示符，进入到文件保存的目录内， 对于我而言， 应该输入 cd ~/code 进入到文件保存目录。 最后，通过敲入以下命令来运行程序： 1go run main.go 如果一切正常(即你的 golang 环境配置的正确)，你将看到 it’s over 9000! 。 但是编译步骤是怎么样的呢？ go run 命令已经包含了编译和运行。它使用一个临时目录来构建程序，执行完然后清理掉临时目录。你可以执行以下命令来查看临时文件的位置： 1go run --work main.go 明确要编译代码的话，使用 go build: 1go build main.go 这将产生一个可执行文件，名为 main ，你可以执行该文件。如果是在 Linux / OSX 系统中，别忘了使用 ./ 前缀来执行，也就是输入 ./main 。 在开发中，你既可以使用 go run 也可以使用 go build 。但当你正式部署代码的时候，你应该部署通过 go build 产生的二进制文件并且执行它。 入口函数 Main希望刚才执行的代码是可以理解的。我们刚刚创建了一个函数，并且使用内置函数 println 打印出了字符串。难道仅因为这里只有一个选择，所以 go run 知道执行什么吗？？不。在 go 中程序入口必须是 main 函数，并且在 main 包内。 我们将在后面的章节中详细介绍包。目前，我们将专注于理解 go 基础，一直会在 main 包中写代码。 如果你想尝试，你可以修改代码并且可以更改包名。使用 go run 执行程序将出现一个错误。 接着你可以将包名改回 main ，换一个不同的方法名，你会看到一个不同的错误。尝试使用 go build 代替 go run 来执行刚才的代码，注意代码编译时，没有入口点可以执行。但当你构建一个库时，确实完全正确的。 导入包Go 有很多内建函数，例如 println，可以在没有引用情况下直接使用。但是，如果不使用 Go 的标准库直接使用第三方库，我们就无法走的更远。import 关键字被用于去声明文件中代码要使用的包。 修改下我们的程序： 12345678910111213package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() { if len(os.Args) != 2 { os.Exit(1) } fmt.Println(&quot;It's over&quot;, os.Args[1])} 你可以这样运行： 1go run main.go 9000 我们现在用了 Go 的两个标准包：fmt 和 os 。我们也介绍了另一个内建函数 len 。len 返回字符串的长度，字典值的数量，或者我们这里看到的，它返回了数组元素的数量。如果你想知道我们这里为什么期望得到两个参数，它是因为第一个参数 – 索引0处 – 总是当前可运行程序的路径。（更改程序将它打印出来亲自看看就知道了） 你可能注意到了，我们在函数名称前加上了前缀包名，例如，fmt.PrintLn。这是不同于其他很多语言的。后续的章节中我们将学习到更多关于包的知识。现在，知道如何导入以及使用一个包就是一个好的开始。 在 Go 中，关于导包是很严格的。如果你导入了一个包却没有使用将会导致编译不通过。尝试运行下面的程序： 123456789package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() {} 你应该会得到两个关于 fmt 和 os 被导入却没有被使用的错误。这很烦人的是不是呀？绝对是这样的，不过随着时间的推移，你将慢慢习惯它（虽然仍然烦人，不过要以 Go 的思维写 Go）。Go 如此严格是因为没用的导入会降低编译速度；诚然，我们大多数人不会关注这个问题。 另一个需要记住的事情是 Go 的标准库已经有了很好的文档。你可以访问 https://golang.org/pkg/fmt/#Println 去看更多关于 PrintLn 函数的信息。你可以点击那个部分的头去看源代码。另外，也可以滚动到顶部查看关于 Go 格式化功能的更多消息。 如果没有互联网，你可以这样在本地获取文档： 1godoc -http=:6060 然后浏览器中访问 http://localhost:6060 函数声明这是个好时机指出函数是可以返回多个值的。让我们看三个函数：一个没有返回值，一个有一个返回值，一个有两个返回值。 12345678func log(message string) {}func add(a int, b int) int {}func power(name string) (int, bool) {} 我们可以像这样使用最后一个： 1234value, exists := power(&quot;goku&quot;)if exists == false { // 处理错误情况} 有时候，你仅仅关注其中一个返回值。这个情况下，你可以将其他的返回值赋值给空白符_： 1234_, exists := power(&quot;goku&quot;)if exists == false { // handle this error case} 这不仅仅是一个惯例。_ ，空白标识符，特殊在于实际上返回值并没有赋值。这让你可以一遍又一遍地使用 _ 而不用管它的类型。 最后，关于函数声明还有些要说的。如果参数有相同的类型，您可以用这样一个简洁的用法： 123func add(a, b int) int {} 返回多个值可能是你经常使用的，你也可能会频繁地使用 _ 丢弃一个值。命名返回值和稍微冗长的参数声明不太常用。尽管如此，你将很快遇到他们，所以了解他们很重要。 继续之前我们之前看了很多小的独立片段，在这点上，可能会感到有点脱节。我们将慢慢地构建更大的例子，将这些小的片段组合在一起。 如果你之前用的是动态类型语言，那么类型和声明的复杂性看起来像是在倒退。我并没有不同意你，在某些系统中动态语言可能更加有效。 如果你来自静态类型的语言，你可能对 Go 感到满意。类型推断以及多值返回的设计非常棒?（尽管这不是 Go 独有）。希望随着我们了解更多，你将会慢慢爱上这干净简洁的语法。 第二章 · 结构体Go 不是像 C ++，Java，Ruby和C＃一样的面向对象的（OO）语言。它没有对象和继承的概念，也没有很多与面向对象相关的概念，例如多态和重载。 Go所具有的是结构体的概念，可以将一些方法和结构体关联。Go 还支持一种简单但有效的组合形式。 总的来说，它会使代码变的更简单，但在某一些场合，你会错过面向对象提供的一些特性。（值得指出的是，通过组合实现继承是一场古老的战斗呐喊，Go 是我用过的第一种坚定立场的语言，在这个问题上。） 虽然 Go 不会像你以前使用的面向对象语言一样，但是你会注意到结构的定义和类的定义之间有很多相似之处。下面的代码定义了一个简单的 Saiyan 结构体： 1234type Saiyan struct { Name string Power int} 我们将看明白怎么往这个结构体添加一个方法，就像面向对象类，会有方法作为 它的一部分。在这之前，我们先要知道如何申明结构体。 声明和初始化当我们第一次看到变量和声明时，我们只看了内置类型，比如整数和字符串。既然现在我们要讨论结构，那么我们需要扩展讨论范围到指针。 创建结构的值的最简单的方式是： 1234goku := Saiyan{ Name: &quot;Goku&quot;, Power: 9000,} 注意： 上述结构末尾的逗号 , 是必需的。没有它的话，编译器就会报错。你将会喜欢上这种必需的一致性，尤其当你使用一个与这种风格相反的语言或格式的时候。 我们不必设置所有或哪怕一个字段。下面这些都是有效的： 123456goku := Saiyan{}// orgoku := Saiyan{Name: &quot;Goku&quot;}goku.Power = 9000 就像未赋值的变量其值默认为 0 一样，字段也是如此。 此外，你可以不写字段名，依赖字段顺序去初始化结构体 （但是为了可读性，你应该把字段名写清楚）： 1goku := Saiyan{&quot;Goku&quot;, 9000} 以上所有的示例都是声明变量 goku 并赋值。 许多时候，我们并不想让一个变量直接关联到值，而是让它的值为一个指针，通过指针关联到值。一个指针就是内存中的一个地址；指针的值就是实际值的地址。这是间接地获取值的方式。形象地来说，指针和实际值的关系就相当于房子和指向该房子的方向之间的关系。 为什么我们想要一个指针指向值而不是直接包含该值呢？这归结为 Go 中传递参数到函数的方式：就像复制。知道了这个，尝试理解一下下面的代码呢？ 123456789func main() { goku := Saiyan{&quot;Goku&quot;, 9000} Super(goku) fmt.Println(goku.Power)}func Super(s Saiyan) { s.Power += 10000} 上面程序运行的结果是 9000，而不是 19000,。为什么？因为 Super 修改了原始值 goku 的复制版本，而不是它本身，所以，Super 中的修改并不影响上层调用者。现在为了达到你的期望，我们可以传递一个指针到函数中： 123456789func main() { goku := &amp;Saiyan{&quot;Goku&quot;, 9000} Super(goku) fmt.Println(goku.Power)}func Super(s *Saiyan) { s.Power += 10000} 这一次，我们修改了两处代码。第一个是使用了 &amp; 操作符以获取值的地址（它就是 取地址 操作符）。然后，我们修改了 Super 参数期望的类型。它之前期望一个 Saiyan 类型，但是现在期望一个地址类型 *Saiyan，这里 *X 意思是 指向类型 X 值的指针 。很显然类型 Saiyan 和 *Saiyan 是有关系的，但是他们是不同的类型。 这里注意到我们仍然传递了一个 goku 的值的副本给 Super，但这时 goku 的值其实是一个地址。所以这个副本值也是一个与原值相等的地址，这就是我们间接传值的方式。想象一下，就像复制一个指向饭店的方向牌。你所拥有的是一个方向牌的副本，但是它仍然指向原来的饭店。 我们可以证实一下这是一个地址的副本，通过修改其指向的值（尽管这可能不是你真正想做的事情）： 123456789func main() { goku := &amp;Saiyan{&quot;Goku&quot;, 9000} Super(goku) fmt.Println(goku.Power)}func Super(s *Saiyan) { s = &amp;Saiyan{&quot;Gohan&quot;, 1000}} 上面的代码，又一次地输出 9000。就像许多语言表现的那样，包括 Ruby，Python， Java 和 C#，Go 以及部分的 C#，只是让这个事实变得更明显一些。 同样很明显的是，复制一个指针比复制一个复杂的结构的消耗小多了。在 64 位的机器上面，一个指针占据 64 bit 的空间。如果我们有一个包含很多字段的结构，创建它的副本将会是一个很昂贵的操作。指针的真正价值在于能够分享它所指向的值。我们是想让 Super 修改 goku 的副本还是修改共享的 goku 值本身呢？ 所有这些并不是说你总应该使用指针。这章末尾，在我们见识了结构的更多功能以后，我们将重新检视 指针与值这个问题。 结构体上的函数我们可以把一个方法关联在一个结构体上： 12345678type Saiyan struct { Name string Power int}func (s *Saiyan) Super() { s.Power += 10000} 在上面的代码中，我们可以这么理解，*Saiyan 类型是 Super 方法的接受者。然后我们可以通过下面的代码去调用 Super 方法： 123goku := &amp;Saiyan{&quot;Goku&quot;, 9001}goku.Super()fmt.Println(goku.Power) // 将会打印出 19001 构造器结构体没有构造器。但是，你可以创建一个返回所期望类型的实例的函数（类似于工厂）： 123456func NewSaiyan(name string, power int) *Saiyan { return &amp;Saiyan{ Name: name, Power: power, }} 这种模式以错误的方式惹恼了很多开发人员。一方面，这里有一点轻微的语法变化；另一方面，它确实感觉有点不那么明显。 我们的工厂不必返回一个指针；下面的形式是完全有效的： 123456func NewSaiyan(name string, power int) Saiyan { return Saiyan{ Name: name, Power: power, }} 结构体的字段到目前为止的例子中，Saiyan 有两个字段 Name 和 Power，其类型分别为 string 和 int。字段可以是任何类型 – 包括其他结构体类型以及目前我们还没有提及的 array，maps，interfaces 和 functions 等类型。 例如，我们可以扩展 Saiyan 的定义： 12345type Saiyan struct { Name string Power int Father *Saiyan} 然后我们通过下面的方式初始化： 123456789gohan := &amp;Saiyan{ Name: &quot;Gohan&quot;, Power: 1000, Father: &amp;Saiyan { Name: &quot;Goku&quot;, Power: 9001, Father: nil, },} New尽管缺少构造器，Go 语言却有一个内置的 new 函数，使用它来分配类型所需要的内存。 new(X) 的结果与 &amp;X{} 相同。 123goku := new(Saiyan)// same asgoku := &amp;Saiyan{} 如何使用取决于你，但是你会发现大多数人更偏爱后一种写法无论是否有字段需要初始化，因为这看起来更具可读性： 12345678910goku := new(Saiyan)goku.name = &quot;goku&quot;goku.power = 9001//vsgoku := &amp;Saiyan { Name: &quot;goku&quot;, Power: 9000,} 无论你选择哪一种，如果你遵循上述的工厂模式，就可以保护剩余的代码而不必知道或担心内存分配细节 组合Go 支持组合， 这是将一个结构包含进另一个结构的行为。在某些语言中，这种行为叫做 特质 或者 混合。 没有明确的组合机制的语言总是可以做到这一点。在 Java 中， 可以使用 继承 来扩展结构。但是在脚本中并没有这种选项， 混合将会被写成如下形式： 123456789101112131415161718public class Person { private String name; public String getName() { return this.name; }}public class Saiyan { // Saiyan 中包含着 person 对象 private Person person; // 将请求转发到 person 中 public String getName() { return this.person.getName(); } ...} 这可能会非常繁琐。Person 的每个方法都需要在 Saiyan 中重复。Go 避免了这种复杂性： 12345678910111213141516171819type Person struct { Name string}func (p *Person) Introduce() { fmt.Printf(&quot;Hi, I'm %s\\n&quot;, p.Name)}type Saiyan struct { *Person Power int}// 使用它goku := &amp;Saiyan{ Person: &amp;Person{&quot;Goku&quot;}, Power: 9001,}goku.Introduce() Saiyan 结构体有一个 Person 类型的字段。由于我们没有显示地给它一个字段名，所以我们可以隐式地访问组合类型的字段和函数。然而，Go 编译器确实给了它一个字段，下面这样完全有效： 12345goku := &amp;Saiyan{ Person: &amp;Person{&quot;Goku&quot;},}fmt.Println(goku.Name)fmt.Println(goku.Person.Name) 上面两个都打印 「Goku」。 组合比继承更好吗？许多人认为它是一种更好的组织代码的方式。当使用继承的时候，你的类和超类紧密耦合在一起，你最终专注于结构而不是行为。 指针类型和值类型当你写 Go 代码的时候，很自然就会去问自己 应该是值还是指向值的指针呢？ 这儿有两个好消息，首先，无论我们讨论下面哪一项，答案都是一样的： 局部变量赋值 结构体指针 函数返回值 函数参数 方法接收器 第二，如果你不确定，那就用指针咯。 正如我们已经看到的，传值是一个使数据不可变的好方法（函数中改变它不会反映到调用代码中）。有时，这是你想要的行为，但是通常情况下，不是这样的。 即使你不打算改变数据，也要考虑创建大型结构体副本的成本。相反，你可能有一些小的结构： 1234type Point struct { X int Y int} 这种情况下，复制结构的成本能够通过直接访问 X 和 Y 来抵消，而没有其它任何间接操作。 还有，这些案例都是很微妙的，除非你迭代成千上万个这样的指针，否则你不会注意到差异。 继续之前从实际的角度看，这章介绍了结构体，如何使一个结构体的实例成为函数的接收者，以及添加指针到现有的 Go 类型系统知识中。下面的章节将建立在我们已经了解了什么是结构体以及其内部工作原理之上。 第三章 · 映射、数组和切片至此，我们已经学了一部分简单的类型和结构。现在，让我们开始学习 Arrays （数组）, Slices （切片） 和 Maps （映射） 吧。 数组如果你学过 Python , Ruby , Perl , JavaScript 或者 PHP （或者更多其它的语言），那么你肯定习惯 动态数组 编程啦。这些数组的长度可以在添加数据的时候自行调整的。在 Go 中，像其它大部分语言一样，数据的长度是固定的。我们在声明一个数组时需要指定它的长度，一旦指定了长度，那么它的长度值是不可以改变的了： 12var scores [10]intscores[0] = 339 上面的数组最多可以容纳 10 个元素，索引是从 scores[0] 到 scores[9] 。试图访问超过界限的索引系统将会抛出编译或运行时错误。 我们可以在初始化数组的时候指定值： 1scores := [4]int{9001, 9333, 212, 33} 我们可以使用 len 函数来获取数组的长度。range 函数在遍历迭代的时候使用： 123for index, value := range scores {} 数组非常高效但是很死板。很多时候，我们在事前并不知道数组的长多是多少。针对这个情况，slices （切片） 出来了。 切片在Go语言中，我们很少直接使用数组。取而代之的是使用切片。切片是轻量的包含并表示数组的一部分的结构。 这里有几种创建切片的方式，我们来看看什么情况下使用它们。首先在数组的基础之上进行一点点变化: 1scores := []int{1,4,293,4,9} 和数组申明不同的是，我们的切片没有在方括号中定义长度。为了理解两者的不同，我们来看看另一种使用make来创建切片的方式: 1scores := make([]int, 10) 我们使用 make 关键字代替 new， 是因为创建一个切片不仅是只分配一段内存（这个是 new关键字的功能）。具体来讲，我们必须要为一个底层数组分配一段内存，同时也要初始化这个切片。在上面的代码中，我们初始化了一个长度是 10 ，容量是 10 的切片。长度是切片的长度，容量是底层数组的长度。在使用 make 创建切片时，我们可以分别的指定切片的长度和容量： 1scores := make([]int, 0, 10) 上面的代码创建了一个长度是 0 ，容量是 10 的切片。（如果你仔细观察的话，你会注意到 make 和 len 被重载了。Go 的一些特性没有暴露出来给开发者使用，这也许会让你感到沮丧。） 为了更好的理解切片的长度和容量之间的关系，我们来看下面的的例子： 12345func main() { scores := make([]int, 0, 10) scores[7] = 9033 fmt.Println(scores)} 我们上面的这个例子不能运行，为什么呢？因为切片的长度是 0 。没错，底层数组可以放 10 个元素，但是我们需要显式的扩展切片，才能访问到底层数组的元素。一种扩展切片的方式是通过 append的关键字来实现： 12345func main() { scores := make([]int, 0, 10) scores = append(scores, 5) fmt.Println(scores) // prints [5]} 但是那并没有改变原始代码的意图。追加一个值到长度为0的切片中将会设置第一个元素。无论什么原因，我们崩溃的代码想去设置索引为7的元素值。为了实现这个，我们可以重新切片： 123456func main() { scores := make([]int, 0, 10) scores = scores[0:8] scores[7] = 9033 fmt.Println(scores)} 我们可以调整的切片大小最大范围是多少呢？达到它的容量，这个例子中，是10。你可能在想 这实际上并没有解决数组固定长度的问题。但是 append 是相当特别的。如果底层数组满了，它将创建一个更大的数组并且复制所有原切片中的值（这个就很像动态语言 PHP，Python，Ruby，JavaScript 的工作方式）。这就是为什么上面的例子中我们必须重新将 append 返回的值赋值给 scores 变量：append 可能在原有底层数组空间不足的情况下创建了新值。 如果我告诉你 Go 使用 2x 算法来增加数组长度，你猜下面将会打印什么？ 12345678910111213141516func main() { scores := make([]int, 0, 5) c := cap(scores) fmt.Println(c) for i := 0; i &lt; 25; i++ { scores = append(scores, i) // 如果容量改变了 // Go 必须增加数组长度来容纳新的数据 if cap(scores) != c { c = cap(scores) fmt.Println(c) } }} 初始 scores 的容量是5。为了存储25个值，它必须扩展三次容量，分别是 10，20，最终是40。 最后一个例子，考虑这个： 12345func main() { scores := make([]int, 5) scores = append(scores, 9332) fmt.Println(scores)} 这里输出是 [0, 0, 0, 0, 0, 9332]，可能你觉得是[9332, 0, 0, 0, 0]？对一个用户而言，这可能逻辑上是正确的。然而，对于一个编译器，你告诉他的是追加一个值到一个已经有5个值的切片。 最终，这有四种方式初始化一个切片： 1234names := []string{&quot;leto&quot;, &quot;jessica&quot;, &quot;paul&quot;}checks := make([]bool, 10)var names []stringscores := make([]int, 0, 20) 什么时候该用哪个呢？第一个不用过多解释。当你事先知道数组中的值的时候，你可以使用这个方式。 当你想要写入切片具体的索引时，第二个方法很有用，例如： 1234567func extractPowers(saiyans []*Saiyans) []int { powers := make([]int, len(saiyans)) for index, saiyan := range saiyans { powers[index] = saiyan.Power } return powers} 第三个版本是指向空的切片，用于当元素数量未知时与 append 连接。 最后一个版本是让我们声明一个初始的容量。如果我们大概知道元素的数量将是很有用的。 即使当你知道大小的时候，append 也可以使用，取决于个人偏好： 1234567func extractPowers(saiyans []*Saiyans) []int { powers := make([]int, 0, len(saiyans)) for _, saiyan := range saiyans { powers = append(powers, saiyan.Power) } return powers} 切片作为数组的包装是一个很强大的概念。许多语言有切片数组的概念。JavaScript 和 Ruby 数组都有一个 slice 方法。Ruby 中你可以使用 [START..END] 获取一个切片，或者 Python 中可以通过 [START:END] 实现。然而，在这些语言中，一个切片实际上是复制了原始值的新数组。如果我们使用 Ruby，下面这段代码的输出是什么呢？ 1234scores = [1,2,3,4,5]slice = scores[2..4]slice[0] = 999puts scores 答案是 [1, 2, 3, 4, 5] 。那是因为 slice 是一个新数组，并且复制了原有的值。现在，考虑 Go 中的情况： 1234scores := []int{1,2,3,4,5}slice := scores[2:4]slice[0] = 999fmt.Println(scores) 输出是 [1, 2, 999, 4, 5]。 这改变了你编码的方式。例如，许多函数采用一个位置参数。JavaScript 中，如果你想去找到字符串中前五个字符后面的第一个空格（当然，在Go中切片也可以用于字符串），我们会这样写： 12haystack = &quot;the spice must flow&quot;;console.log(haystack.indexOf(&quot; &quot;, 5)); 在 Go 中，我们这样使用切片： 1strings.Index(haystack[5:], &quot; &quot;) 我们可以从上面的例子中看到，[X:] 是 从 X 到结尾 的简写，然而 [:X] 是 从开始到 X 的简写。不像其他的语言，Go 不支持负数索引。如果我们想要切片中除了最后一个元素的所有值，可以这样写： 12scores := []int{1, 2, 3, 4, 5}scores = scores[:len(scores)-1] 上面是从未排序的切片中移除元素的有效方法的开始： 12345678910111213func main() { scores := []int{1, 2, 3, 4, 5} scores = removeAtIndex(scores, 2) fmt.Println(scores) // [1 2 5 4]}// 不会保持顺序func removeAtIndex(source []int, index int) []int { lastIndex := len(source) - 1 // 交换最后一个值和想去移除的值 source[index], source[lastIndex] = source[lastIndex], source[index] return source[:lastIndex]} 最后，我们已经了解了切片，我们再看另一个通用的内建函数：copy。正常情况下，将值从一个数组复制到另一个数组的方法有5个参数，source， sourceStart，count,，destination 和 destinationStart。使用切片，我们仅仅需要两个： 1234567891011121314151617import ( &quot;fmt&quot; &quot;math/rand&quot; &quot;sort&quot;)func main() { scores := make([]int, 100) for i := 0; i &lt; 100; i++ { scores[i] = int(rand.Int31n(1000)) } sort.Ints(scores) worst := make([]int, 5) copy(worst, scores[:5]) fmt.Println(worst)} 花点时间试试上面的代码，并尝试改动。去看看如果你这么做 copy(worst[2:4], scores[:5]) 或者复制多于或少于 5 个值给 worst 会发什么？ 映射Go语言中的映射，就好比其他语言中的hash表或者字典。它们的工作方式就是：定义键和值，并且可以获取，设置和删除其中的值。 映射和切片一样，使用 make 方法来创建。让我们来看看一个例子： 123456789func main() { lookup := make(map[string]int) lookup[&quot;goku&quot;] = 9001 power, exists := lookup[&quot;vegeta&quot;] // prints 0, false // 0 is the default value for an integer fmt.Println(power, exists)} 我们使用 len方法类获取映射的键的数量。使用delete方法来删除一个键对应的值： 12345// returns 1total := len(lookup)// has no return, can be called on a non-existing keydelete(lookup, &quot;goku&quot;) 映射是动态变化的。然而我们可以通过传递第二个参数到 make方法来设置一个初始大小： 1lookup := make(map[string]int, 100) 如果你事先知道映射会有多少键值，定义一个初始大小将会帮助改善性能。 当你需要将映射作为结构体字段的时候，你可以这样定义它： 1234type Saiyan struct { Name string Friends map[string]*Saiyan} 初始上述结构体的一种方式是： 12345goku := &amp;Saiyan{ Name: &quot;Goku&quot;, Friends: make(map[string]*Saiyan),}goku.Friends[&quot;krillin&quot;] = ... //加载或者创建 Krillin Go 还有一种定义和初始化值的方式。像 make，这种特定用于映射和数组。我们可以定义为复合方式： 1234lookup := map[string]int{ &quot;goku&quot;: 9001, &quot;gohan&quot;: 2044,} 我们可以使用 for 组合 range 关键字迭代映射： 123for key, value := range lookup { ...} 迭代映射是没有顺序的。每次迭代查找将会随机返回键值对。 指针和值第二章我们讨论了到底是传值还是传指针。现在我们有相同的问题在映射和数组上，到底该使用他们哪个？ 123a := make([]Saiyan, 10)// 或者b := make([]*Saiyan, 10) 许多开发者认为应该传递 b 或者返回它在一个函数中会更加高效。然而，传递/返回的是切片的副本，但是切片本身就是一个引用。所以传递返回切片本身，没有什么区别。 当你改变切片或者映射值的时候，你将看到不同。这一点上，和我们在第二章看到的逻辑相同。所以决定使用指针数组还是值数组归结为你如何使用单个值，而不是你用数组还是映射。 继续之前Go 中数组和映射的工作方式类似于其他语言。如果你习惯了使用动态数组，这可能就有点小的调整，但是 append 应该能解决你大多的不适应。如果我们超越数组的表面语法，将会发现切片。切片功能强大，并且他们对代码的清晰度产生了巨大的影响。 还有一些边缘情况没有覆盖到，不过你不太可能遇到他们。即使遇到了，希望我们在这里建立的基础帮助你理解正在发生的事情。 第四章 · 代码组织和接口现在来看一下如何组织我们的代码。 包管理为了组织复杂的库和系统代码，我们需要学习关于包的知识。在 Go 语言中，包名遵循 Go 项目的目录结构。如果我们建立一个购物系统，我们可能以 “shopping” 包名作为一个开始，然后把所有源代码文件放到 $GOPATH/src/shopping/ 目录中。 我们不会去想把所有东西都放在这个文件夹中。例如，我们可能想单独把数据库逻辑放在它自己的目录中。为了实现这个，我们创建一个子目录 $GOPATH/src/shopping/db 。子目录中文件的包名就是 db，但是为了从另一个包访问它，包括 shopping 包，我们需要导入 shopping/db。 换句话说，当你想去命名一个包的时候，可以通过 package 关键字，提供一个值，而不是完整的层次结构（例如：「shopping」或者 「db」）。当你想去导入一个包的时候，你需要指定完整路径。 接下来，我们去尝试下。在你的 Go 的工作目录 src 文件夹下（我们已经在基础那一章节中介绍了），创建一个新的文件夹叫做 shopping ，然后在 shopping 文件夹下创建一个 db 文件夹。 在 shopping/db 文件夹下，创建一个叫做 db.go 的文件，然后在 db.go 文件中添加如下的代码： 1234567891011package dbtype Item struct { Price float64}func LoadItem(id int) *Item { return &amp;Item{ Price: 9.001, }} 需要注意包名和文件夹名是一样的。而且很明显我们实际并没有连接数据库。这里使用这个例子只是为了展示如何组织代码。 现在，创建在主目录 shopping 下创建一个叫 pricecheck.go 的文件。它的内容是： 12345678910111213package shoppingimport ( &quot;shopping/db&quot;)func PriceCheck(itemId int) (float64, bool) { item := db.LoadItem(itemId) if item == nil { return 0, false } return item.Price, true} 很有可能认为导入 shopping/db 有点特别，因为我们已经在 shopping 包/目录中。实际上，我们正在导入 $GOPATH/src/shopping/db，这意味着只要你在你的工作区间 src/test 目录中有一个名为 db 的包，你就可以轻松导入它。 你正在构建一个包，除了我们看到的你不再需要任何东西。为了构建一个可执行程序，你仍然需要 main 包。我比较喜欢的方式是在 shopping 目录下创建一个 main 子目录，然后再创建一个叫 main.go 的文件，下面是它的内容： 12345678910package mainimport ( &quot;shopping&quot; &quot;fmt&quot;)func main() { fmt.Println(shopping.PriceCheck(4343))} 现在，你可以进入你的 shopping 项目运行代码，输入： 1go run main/main.go 循环导入当你编写更复杂的系统的时，你必然会遇到循环导入。例如，当 A 包导入 B 包，B 包又导入 A 包（间接或者直接导入）。这是编译器不能允许的。 让我们改变我们的 shopping 结构以复现这个错误。 将 Item 定义从 shopping/db/db.go 移到 shopping/pricecheck.go。你的 pricecheck.go 文件像下面这样： 1234567891011121314151617package shoppingimport ( &quot;shopping/db&quot;)type Item struct { Price float64}func PriceCheck(itemId int) (float64, bool) { item := db.LoadItem(itemId) if item == nil { return 0, false } return item.Price, true} 如果你尝试运行代码，你会从 db/db.go 得到两个关于 Item 未定义的错误。这看起来是说 Item 不存在 db 包中。它已经被移动到 shopping 包中，我们需要将 shopping/db/db.go 改变成： 1234567891011package dbimport ( &quot;shopping&quot;)func LoadItem(id int) *shopping.Item { return &amp;shopping.Item{ Price: 9.001, }} 现在但你尝试运行代码的时候，你将会得到 不允许循环导入 的错误。我们可以通过引入另一个包含共享结构体的包来解决这个问题。你的目录现在看起来像这个样子： 123456789$GOPATH/src - shopping pricecheck.go - db db.go - models item.go - main main.go pricecheck.go 将仍然导入 shopping/db，但是 db.go 现在导入 shopping/models 而不是 shopping，因此打破了循环。因为我们将共享的 Item 结构体移动到 shopping/models/item.go，我们现在需要去改变 shopping/db/db.go 从 models 包中引用 Item 结构体。 1234567891011package dbimport ( &quot;shopping/models&quot;)func LoadItem(id int) *models.Item { return &amp;models.Item{ Price: 9.001, }} 你经常需要共享某些代码，不止 models，所以你可能有其他类似叫做 utilities 的目录，这些共享包的重要原则是他们不从 shopping 包或者任何子包中导入任何东西。在后面的章节中，我们将介绍可以帮助我们解决这些类型依赖关系的接口。 可见性Go 用了一个简单的规则去定义什么类型和函数可以包外可见。如果类型或者函数名称以一个大写字母开始，它就具有了包外可见性。如果以一个小写字母开始，它就不可以。 这也可以应用到结构体字段。如果一个字段名以一个小写字母开始，只有包内的代码可以访问他们。 例如，我们的 items.go 文件中有个这样的函数： 123func NewItem() *Item { // ...} 它可以通过 models.NewItem() 这样被调用。但是如果函数命名为 newItem，我们将不能从不同的包访问它了。 去试试更改 shopping 代码中的函数，类型以及字段的名称。例如，如果你将 Item 的 Price 字段命名为 price，你应该会获得一个错误。 包管理我们用来 build 和 run 的 go 命令有一个 get 子命令，用于获取第三方库。go get 支持除了这个例子中的各种协议，我们可以从 Github 中获取一个库，意味着，你需要在你的电脑中安装 git。 假设你已经安装了 Git，在 shell 中输入命令： 1go get github.com/mattn/go-sqlite3 go get 获取远端的文件并把它们存储在你的工作区间中。去看看你的 $GOPATH/src 目录，你会发现除了我们创建的 shopping 项目之外，还有一个 github.com 目录，在里面，你会看到一个包含了 go-sqlite3 目录的 mattn 目录。 我们刚才只是讨论了如何导入我们工作区间的包。为了导入新安装的 go-sqlite3 包，我们要这样导入： 123import ( &quot;github.com/mattn/go-sqlite3&quot;) 我知道这看起来像一个 URL，实际上，它只是希望导入在 $GOPATH/src/github.com/mattn/go-sqlite3 找到的 go-sqlite3 包。 依赖管理go get 还有一些其他的技巧。如果我们在一个项目内使用 go get，它将浏览所有文件，查找 imports 的第三方库然后下载他们。某种程度上，我们的源代码变成了 Gemfile 或者 package.json。 如果你调用 go get -u ，它将更新所有包（或者你可以通过 go get -u FULL_PACKAGE_NAME 更新一个具体的包）。 最后，你可能发现了 go get 的不足。一方面，这儿没有办法指定一个版本。他总是指向 master/head/trunk/default。这是一个较大的问题如果你有两个项目需要同一个库的不同版本。 为了解决这个问题，你可以使用一个第三方的依赖管理工具。他们仍然很年轻，但 goop 和 godep 是可信的。更多完整的列表在 go-wiki。 接口接口是定义了合约但并没有实现的类型。举个例子： 123type Logger interface { Log(message string)} 那这样做有什么作用呢？其实，接口有助于将代码与特定的实现进行分离。例如，我们可能有各种类型的日志记录器： 123type SqlLogger struct { ... }type ConsoleLogger struct { ... }type FileLogger struct { ... } 针对接口而不是具体实现的编程会使我们很轻松的修改（或者测试）任何代码都不会产生影响。 你会怎么用？就像任何其它类型一样，它结构可以这样： 123type Server struct { logger Logger} 或者是一个函数参数（或者返回值）： 123func process(logger Logger) { logger.Log(&quot;hello!&quot;)} 在像 C# 或者 Java 这类语言中，当类实现接口时，我们必须显式的： 12345public class ConsoleLogger : Logger { public void Logger(message string) { Console.WriteLine(message) }} 在 Go 中，下面的情况是隐式发生的。如果你的结构体有一个函数名为 Log 且它有一个 string 类型的参数并没有返回值，那么这个结构体被视为 Logger 。这减少了使用接口的冗长： 1234type ConsoleLogger struct {}func (l ConsoleLogger) Log(message string) { fmt.Println(message)} Go 倾向于使用小且专注的接口。Go 的标准库基本上由接口组成。像 io 包有一些常用的接口诸如 io.Reader ， io.Writer ， io.Closer 等。如果你编写的函数只需要一个能调用 Close() 的参数，那么你应该接受一个 io.Closer 而不是像 io 这样的父类型。接口可以成为其他接口的一部分，也就是说接口也可以与其他接口组成新的接口。例如， io.ReadCLoser 的接口是由 io.Reader 接口和 io.Closer 接口组成的。 最后，接口通常用于避免循环导入。由于它们没有具体的实现，因此它们的依赖是有限的。 继续之前最后，如何围绕 Go 的工作区间构建你的代码，你只有在写了几个非测试的项目之后才会适应。最重要的是记着包名和目录结构之间的紧密关系（不仅仅在一个项目之内，而是整个工作区间）。 Go 处理类型可见性也是简单有效，而且也是一致的。有一些我们没看过的东西，比如常量和全局变量，但是放心，他们的可见性仍有相同的命名规则决定。 最后，如果你初次接触接口，你可能需要花点时间理解他们。然而，当你第一次看到一个期望类似 io.Reader 的函数时，你会发现自己很感谢作者没有要求他或者她需要的东西。 第五章 · 花絮这章中，我们将讨论 Go 功能杂记，放在其他地方都不太合适。 错误处理Go 首选错误处理方式是返回值，而不是异常。考虑 strconv.Atoi 函数，它将接受一个字符串然后将它转换为一个整数。 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;strconv&quot;)func main() { if len(os.Args) != 2 { os.Exit(1) } n, err := strconv.Atoi(os.Args[1]) if err != nil { fmt.Println(&quot;not a valid number&quot;) } else { fmt.Println(n) }} 你可以创建你自己的错误类型。唯一的要求是你必须实现内建 error 接口的契约： 123type error interface { Error() string} 更一般地，我们可以通过导入 error 包然后使用它的 New 函数创建我们自己的错误： 123456789101112import ( &quot;errors&quot;)func process(count int) error { if count &lt; 1 { return errors.New(&quot;Invalid count&quot;) } ... return nil} Go 标准库中有一个使用 error 变量的通用模式。例如， io 包中有一个 EOF 变量它是这样定义的： 1var EOF = errors.New(&quot;EOF&quot;) 这是一个包级别的变量（被定义在函数之外），可以被其他包访问（首字母大写）。各种函数可以返回这个错误，例如，当我们从一个文件或者 STDIN 读取时。如果它具有上下文意义，那么您应该使用此错误。作为调用者，我们可以这样使用： 1234567891011121314package mainimport ( &quot;fmt&quot; &quot;io&quot;)func main() { var input int _, err := fmt.Scan(&amp;input) if err == io.EOF { fmt.Println(&quot;no more input!&quot;) }} 作为最后一点，Go 确实有 panic 和 recover 函数。 panic 就像抛出异常，而 recover 就像 catch，它们很少使用。 Defer尽管 Go 有一个垃圾回收器，一些资源仍然需要我们显示地释放他们。例如，我们需要在使用完文件之后 Close() 他们。这种代码总是很危险。一方面来说，当我们在写一个函数的时候，很容易忘记关闭我们声明了 10 行的东西。另一方面，一个函数可能有多个返回点。Go 给出的解决方案是使用 defer 关键字： 12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() { file, err := os.Open(&quot;a_file_to_read&quot;) if err != nil { fmt.Println(err) return } defer file.Close() // 读取文件} 如果你尝试运行上面的代码，你将会得到错误（文件不存在）。这里只是演示 defer 如何工作。无论什么情况，在函数返回之后（本例中为 main() ），defer 将被执行。这使您可以在初始化的位置附近释放资源并处理多个返回点。 go语言风格大多数 Go 程序遵循相同的格式化规则，换句话说，一个 tab 键用于缩进，左括号和他们的声明语句在同一行。 我知道，你可能有自己的风格，并且想坚持它。这也是我长期以来所做的事情，但我很高兴我最终放弃了。一个大原因是 go fmt 命令。它易于使用而且具有权威性（所以就没有人争论无意义的偏好）。 当你在一个项目内的时候，你可以运用格式化规则到这个项目及其所有子目录： 1go fmt ./... 试一试，它不仅缩进你的代码，也对齐了声明的字段和按字母书序导入。 初始化的 ifGo 对 if 语句做了稍微修改，支持在条件语句被求值之前先进行初始化： 123if x := 10; count &gt; x { ...} 这是一个比较蠢的例子，更现实的是，你可能会像下面这样做： 123if err := process(); err != nil { return err} 有意思的是，虽然 err 不能在 if 语句之外使用，但他可以在任何 else if 或者 else 之内使用。 空接口和转化在大多数面向对象的语言中，经常有一个内建的叫 object 的基类，是所有其他类的超类。Go 没有继承，也没有这样一个超类。不过他确实有一个没有任何方法的空接口： interface{}。因为空接口没有方法，可以说所有类型都实现了空接口，并且由于空接口是隐式实现的，因此每种类型都满足空接口契约。 如果我们像，我们可以定义如下签名的 add 函数： 123func add(a interface{}, b interface{}) interface{} { ...} 为了将一个接口变量转化为一个显式的类型，又可以用 .(TYPE)： 1return a.(int) + b.(int) 提醒，如果底层类型不是 int，上面的结果将是 error。 你也可以访问强大的类型转换： 12345678switch a.(type) { case int: fmt.Printf(&quot;a is now an int and equals %d\\n&quot;, a) case bool, string: // ... default: // ...} 你将会看到，使用空接口可能超出了你的期望。但是虽然它将让代码看起来不那么好看，来回转换代码有时看起来也很丑陋并且危险，但在一个静态语言中，它是唯一的选择。 字符串和字节数组字符串和字节数组是紧密相关的。我们可以轻松地在他们之间转换： 123stra := &quot;the spice must flow&quot;byts := []byte(stra)strb := string(byts) 实际上，这种转换方式在各种类型之间是通用的。一些函数显示地需要一个 int32 或者 int64 或者它们的无符号部分。你可能发现你必须这样做： 1int64(count) 然而，当它涉及到字节和字符串时，这可能是你经常做的事情。一定记着当你使用 []byte(X) 或者 string(X) 时，你实际上创建了数据的副本。这是必要的，因为字符串是不可变的。 那些由 Unicode 码点 runes 构成的字符串，如果你获取字符串的长度，你可能不能得到你期望的。下面的结果是3： fmt.Println(len(&quot;椒&quot;)) 如果你用 range 迭代一个字符串，你将得到 runes，而不是字节。当然，当你将字符串转换为 []byte 类型时，你将得到正确的数据。 函数类型函数是一种类型： 1type Add func(a int, b int) int 它可以用在任何地方 – 作为字段类型，参数或者返回值。 1234567891011121314151617package mainimport ( &quot;fmt&quot;)type Add func(a int, b int) intfunc main() { fmt.Println(process(func(a int, b int) int{ return a + b }))}func process(adder Add) int { return adder(1, 2)} 这样使用函数会帮助我们从具实现中解耦代码，更像在使用接口实现。 继续之前我们研究了使用 Go 编程的各个方面，最值得注意的是，我们看到了错误的处理行为以及如何释放连接和打开的文件资源。许多人不喜欢 Go 的错误处理方法。这感觉像是倒退了一步。 有时，我同意。然而，我也发现这会让代码更容易理解。 defer 是一种不寻常但是实用的资源管理方法。事实上，它不仅限于资源管理。您可以将 defer 用于任何目的， 比如函数退出时的日志记录。 当然，我们还没有看到 Go 提供的所有花絮，但在你解决遇到的任何问题时你应该感到足够舒服。 第六章 · 并发Go 通常被描述为一种并发友好的语言。 原因是它提供了两种强大机制的简单语法： 协程 和 通道 Go协程 协程 类似于一个线程，但是由 Go 而不是操作系统预定。在 协程 中运行的代码可以与其他代码同时运行。我们来看一个例子： 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { fmt.Println(&quot;start&quot;) go process() time.Sleep(time.Millisecond * 10) // this is bad, don't do this! fmt.Println(&quot;done&quot;)}func process() { fmt.Println(&quot;processing&quot;)} 这里有一些有趣的事情， 但最重要的是我们如何开始一个 协程 。 我们只需使用 go 关键字，然后使用我们想要执行的函数。如果我们只想运行一部分代码， 如上所述， 我们可以使用匿名函数。需要注意的是，匿名函数不只是可以在 协程 中使用，其他地方也可以。 123go func() { fmt.Println(&quot;processing&quot;)}() 协程 易于创建且开销很小。最终多个 协程 将会在同一个底层的操作系统线程上运行。这通常也称为 M:N 线程模型，因为我们有 M 个应用线程（ 协程 ）运行在 N 个操作系统线程上。结果就是，一个 协程 的开销和系统线程比起来相对很低（几KB）。在现代的硬件上，有可能拥有数百万个 协程 。 此外，这里还隐藏了映射和调度的复杂性。我们只需要说 这段代码需要同时并发执行 然后让 Go 自己去实现它。 如果我们回到我们的例子中，你将会注意到我们使用 Sleep 让程序等了几毫秒。这是因为主进程在退出前 协程 才会有机会去执行（主进程在退出前不会等待全部 协程 执行完毕）。要解决这个问题，我们需要协调我们的代码。 同步创建一个协程是微不足道的， 它们开销很小我们可以启动很多； 但是，需要协调并发代码。为了解决这个问题， Go 提供了 通道。 在我们学习 通道 之前，我认为了解并发编程的基础知识非常重要。 编写并发代码要求您特别注意在哪里读取和写入一个值。 在某些方面， 例如没有垃圾回收的语言 – 它需要您从一个新的角度去考虑您的数据，始终警惕着可能存在的危险。 例如： 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;time&quot;)var counter = 0func main() { for i := 0; i &lt; 20; i++ { go incr() } time.Sleep(time.Millisecond * 10)}func incr() { counter++ fmt.Println(counter)} 你觉得将会输出什么呢？ 如果你认为输出的是 1, 2, ... 20 这既不对也没错。如果你运行了以上的代码确实可能得到这个输出。可是，这个操作就很让人懵逼的。 啥？因为我们可能有多个 (这个情况下两个) 协程 同时写入一个相同变量 counter 。或者，同样糟糕的是，一个协程要读取 counter 时，另一个协程正在写入。 这个真的很危险吗？当然啦！ counter++ 看起来可能是一行很简单的代码，但它是实际上被拆分为多个汇编语句 – 确切的性质依赖于你跑程序的平台。如果你运行这个例子，你将经常看到那些数字是以一种乱七八糟的顺序打印的，亦或数字是重复的/丢失的。别着急还会有更糟糕的情况， 比方说系统崩溃或者访问并增加任意区块的数据！ 从变量中读取变量是唯一安全的并发处理变量的方式。 你可以有想要多少就多少的读取者， 但是写操作必须要得同步。 有太多的方法可以做到这个了，包括使用一些依赖于特殊的 CPU 指令集的真原子操作。然而, 常用的操作还是使用互斥量（译者注：mutex）: 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;time&quot; &quot;sync&quot;)var ( counter = 0 lock sync.Mutex)func main() { for i := 0; i &lt; 20; i++ { go incr() } time.Sleep(time.Millisecond * 10)}func incr() { lock.Lock() defer lock.Unlock() counter++ fmt.Println(counter)} 互斥量序列化会锁住锁下的代码访问。因为默认的的 sync.Mutex 是未锁定状态，这儿我们就得先定义 lock sync.Mutex。 这操作是不看着超简单？ 这个例子是具有欺骗性的。当我们进行并发编程时会产生一系列严重的 Bug。 首先，并不是经常能很明显知道什么代码需要保护。使用这样粗糙的锁操作（覆盖着大量代码的锁操作）确实很诱人，这就违背了我们当初进行并发编程的初心了。 我们肯定是需要个优雅的锁操作； 否则，我们最终会把多条快速通道走成单车道的。 另外一个问题是与死锁有关。 使用单个锁时，这没有问题，但是如果你在代码中使用两个或者更多的锁，很容易出现一种危险的情况，当协程A拥有锁 lockA **，想去访问锁 **lockB **，同时协程B拥有锁 **lockB 并需要访问锁 lockA 。 实际上我们使用一个锁时也有可能发生死锁的问题，就是当我们忘记释放它时。 但是这和多个锁引起的死锁行为相比起来，这并不像多锁死锁那样危险（因为这真的 很难发现），当你试着运行下面的代码时，您可以看见发生了什么： 12345678910111213141516package mainimport ( &quot;time&quot; &quot;sync&quot;)var ( lock sync.Mutex)func main() { go func() { lock.Lock() }() time.Sleep(time.Millisecond * 10) lock.Lock()} 到现在为止还有很多并发编程我们没有看到过。 首先，有一个常见的锁叫读写互斥锁。它主要提供了两种锁功能: 一个锁定读取和一个锁定写入。它的区别是允许多个同时读取，同时确保写入是独占的。在 Go 中， sync.RWMutex 就是这种锁。另外 sync.Mutex 结构不但提供了Lock 和 Unlock 方法 ，也提供了RLock 和 RUnlock 方法；其中 R 代表 Read.。虽然读写锁很常用，它也给开发人员带来了额外的负担：我们不但要关注我们正在访问的数据，还要注意如何访问。 此外，部分并发编程不只是通过为数不多的代码按顺序的访问变量； 它也需要协调多个协程。 例如，休眠10毫秒并不是一个特别优雅的解决方案。如果一个协程消耗的时间需要超过10毫秒怎么办？如果协程消耗更少的时间而我们浪费周期怎么办？又或者可以等待协程运行完毕， 我们想另外一个协程 嗨， 我有新的数据需要你处理? 这些事在没有 通道 的情况下都是可以完成的。当然对于更简单的情况，我相信你应该 应该 使用基本的功能比如 sync.Mutex 和 sync.RWMutex， 但正如我们将会在下一节中看到的那样， 通道 旨在让并发编程更简洁和不容易出错。 通道并发编程的最大调整源于数据的共享。如果你的协程间不存在数据共享，你完全没必要担心同步问题。但是并非所有系统都是如此简单。现实中，许多系统考虑了相反的目的：跨多个请求共享数据。内存缓存和数据库就是最好的例证。这种情况已经成为一个日趋增长的现实。 通道在共享不相关数据的情况下，让并发编程变得更健壮。通道是协程之间用于传递数据的共享管道。换而言之，一个协程可以通过一个通道向另外一个协程传递数据。因此，在任意时间点，只有一个协程可以访问数据。 一个通道，和其他任何变量一样，都有一个类型。这个类型是在通道中传递的数据的类型。例如，创建一个通道用于传递一个整数，我们要这样做： 1c := make(chan int) 这个通道的类型是 chan int。因此，要将通道传递给函数，我们的函数签名看起来是这个样子的： 1func worker(c chan int) { ... } 通道只支持两个操作：接收和发送。可以这样往通道发送一个数据： 1CHANNEL &lt;- DATA 这样从通道接收数据： 1VAR := &lt;-CHANNEL 箭头预示着数据流向。当发送的时候，数据流向通道。接收的时候，数据流出通道。 在我们开始第一个例子之前还需要知道的是，接收和发送操作是阻塞的。也就是，当我们从一个通道接收的时候， goroutine 将会直到数据可用才会继续执行。类似地，当我们往通道发送数据的时候，goroutine 会等到数据接收到之后才会继续执行。 考虑这样一个系统，我们希望在各个 goroutine 中处理即将到来的数据。这是一个很平常的需求。如果我们在接收数据的 goroutine 上进行数据密集型处理，那么我们可能导致客户端超时。首先，我们先实现我们的 worker。这可能是一个简单的函数，但是我们让它成为结构的一部分，因此我们之前没有看到这样的 goroutines： 12345678910type Worker struct { id int}func (w Worker) process(c chan int) { for { data := &lt;-c fmt.Printf(&quot;worker %d got %d\\n&quot;, w.id, data) }} 我们的 worker 是简单的。他一直等到数据可用然后处理它。尽职尽责，它一直在一个循环中做这个，永远等待更多的数据去处理。 为了去用这个，第一件事情是启动一些 workers： 12345c := make(chan int)for i := 0; i &lt; 5; i++ { worker := &amp;Worker{id: i} go worker.process(c)} 然后，给这些 worker 一些活干： 1234for { c &lt;- rand.Int() time.Sleep(time.Millisecond * 50)} 这里有一个完整的可运行代码： 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot; &quot;time&quot; &quot;math/rand&quot;)func main() { c := make(chan int) for i := 0; i &lt; 5; i++ { worker := &amp;Worker{id: i} go worker.process(c) } for { c &lt;- rand.Int() time.Sleep(time.Millisecond * 50) }}type Worker struct { id int}func (w *Worker) process(c chan int) { for { data := &lt;-c fmt.Printf(&quot;worker %d got %d\\n&quot;, w.id, data) }} 我们不知道哪个 worker 将得到什么数据。但我们能确保的是 Go 保证了发送到通道的数据只会被一个接收器接收。 记着，唯一的共享状态时通道，我们可以安全地同时从它接收和发送数据。通道提供了所有我们需要的同步代码保证，在任何时间只有一个 goroutine 可以访问特定的数据。 缓冲通道上面给出的代码中，如果有超过能处理的数据到来会发什么？你可以通过更改 worker 接收到数据之后的暂停时间来模拟这个。 12345for { data := &lt;-c fmt.Printf(&quot;worker %d got %d\\n&quot;, w.id, data) time.Sleep(time.Millisecond * 500)} 我们的主代码中发生的是，接收用户数据的代码（刚刚使用随机数生成器模拟的）是阻塞，因为没有接收器可用。 在某些情况下，你可能需要担保数据被处理掉，这个时候就需要开始阻塞客户端。在某些情况下，你可能会降低这种担保。这有几种常用的策略实现它。第一个就是缓冲数据。如果没有worker可用，我们想去临时存储数据在某些队列中。通道内建这种缓冲容量，当我们使用 make 创建通道的时候，可以设置通道的长度： 1c := make(chan int, 100) 你可以对此更改进行更改，但你会注意到处理仍然不稳定。缓冲通道不会增加容量，他们只提供待处理工作的队列，以及处理突然飙升的任务量的好方法。在我们的示例中，我们不断推送比 worker 可以处理的数据更多的数据。 然而，我们实际上可以通过查看通道的 len 来理解缓冲通道是什么。 12345for { c &lt;- rand.Int() fmt.Println(len(c)) time.Sleep(time.Millisecond * 50)} 你可以看到通道长度一直增加直到满了，这个时候往我们的通道发送数据将再一次阻塞。 Select即使有缓冲，在某些时候我们需要开始删除消息。我们不能为了让 worker 轻松而耗尽所有内存。为了实现这个，我们使用 Go 的 select： 语法上，select 看起来有一点像 switch。使用它，我们提供当通道不能发送数据的时候处理代码。首先，让我们移除通道缓冲来看看 select 如何工作： 1c := make(chan int) 接下来，改变我们的 for 循环： 12345678910for { select { case c &lt;- rand.Int(): // 可选的代码在这里 default: // 这里可以留空以静默删除数据 fmt.Println(&quot;dropped&quot;) } time.Sleep(time.Millisecond * 50)} 我们将每秒推送20条消息，但是我们的 worker 每秒仅仅能处理10条。也就是说，一般的消息，将被丢掉。 这只是我们能使用 select 实现的一个开始。select 的主要目的是管理多个通道，select 将阻塞直到第一个通道可用。如果没有通道可用，如果提供了 default ，那么他就会被执行。如果多个通道都可用了，随机挑选一个。 很难用一个简单的例子来证明这个行为，因为它是一个相当高级的功能。下一节可能有助于证明这个。 超时我们看过了缓冲消息以及简单地将他们丢弃。另一个通用的选择是去超时。我们将阻塞一段时间，但不会永远。这在 Go 中也是很容易实现的。虽然，语法很难遵循，但是这样一个简洁有用的功能我不能将它排除在外。 为了阻塞最长时间，我们可以用 time.After 函数。我们来一起看看它并试着超越魔法。为了去用这个，我们的发送器将变成： 12345678for { select { case c &lt;- rand.Int(): case &lt;-time.After(time.Millisecond * 100): fmt.Println(&quot;timed out&quot;) } time.Sleep(time.Millisecond * 50)} time.After 返回了一个通道，所以我们在 select 中使用它。这个通道可以在指定时间之后被写入。就这样，没有其他魔法了。如果你比较好奇，这里有一个 after 的实现，看起来大概就是这个样子咯： 12345678func after(d time.Duration) chan bool { c := make(chan bool) go func() { time.Sleep(d) c &lt;- true }() return c} 回到我们的 select，还有两个东西可以试试。首先，如果添加回 default 会发生什么？能猜到吗？试试它。如果你不确定，记着如果没有可用的通道，default 将会立即触发。 还有，time.After 是一个 chan time.Time 类型的通道。上面的例子中，我们仅仅是简单地丢弃掉了发送到通道的值。如果你想要，你可以接受它： 12case t := &lt;-time.After(time.Millisecond * 100): fmt.Println(&quot;timed out at&quot;, t) 注意力重新回到我们的 select，可以看到我们发送给 c 但是却从 time.After 接收。无论我们从哪里接收，发送给谁，或者任何通道的组合，select 工作方式是相同的： 第一个可用的通道被选择。 如果多个通道可用，随机选择一个。 如果没有通道可用，default 情况将被执行。 如果没有 default，select 将会阻塞。 最后，在 for 中看到一个 select 是很常见的： 123456789for { select { case data := &lt;-c: fmt.Printf(&quot;worker %d got %d\\n&quot;, w.id, data) case &lt;-time.After(time.Millisecond * 10): fmt.Println(&quot;Break time&quot;) time.Sleep(time.Second) }} 继续之前如果你是并发编程的新手，那么看起来似乎都是压倒性的。 它绝对需要非常多的关注。Go旨在让它变得更容易。 Goroutines 有效的抽象了我们需要并发执行的代码。通道帮助消除数据共享时共享数据可能发生的一些严重错误。这不仅可以消除错误， 还可以改变并发编程的方式。你只用考虑通过信息传递实现并发编程，而不是危险的代码区域。 话虽如此，我仍然广泛使用 sync 和 sync / atomic 包中的各种同步原语。我觉得比较重要的是通过使用这两种方式比较舒适。我建议你首先关注通道，但是当你遇到一个需要短暂锁的简单示例时，请考虑使用互斥锁或读写互斥锁。 总结我最近听说 Go 被描述为一个枯燥的语言。枯燥是因为很容易去学，很容易写，以及最重要的，易读。或许，我确实认为这个实现不太好，毕竟，我确实花了三章讨论类型和如何声明变量。 如果你有静态类型语言的工作经历，我们所看到的内容仅仅只是一个复习。Go 使得指针可用性增强，并且切片是数组的包装，对于经验丰富的 Java 或 C＃开发人员来说可能并不算是压倒性优势。 如果你曾经大多在使用动态语言，你可能会感到有点不同。它是一个值得学习的东西。其中最重要的是声明和各种初始化的语法。尽管我是 Go 的粉丝，Go 尽管也在简单性方面取得了一些进展，但它并不简单。不过，它归纳为一些基本的规则（比如你只能声明变量一次以及 := 确实声明了变量）以及基本理解（比如 new(X) 或者 &amp;X{} 仅仅只是分配内存，但是切片，映射以及通道需要更多的初始化，所以用 make）。 除了这些，Go 给了我们简单但有效的方式组织我们的代码。接口，基于返回的错误处理，用于资源管理的 defer以及实现组合的简单方式。 最后但也最重要的是内置并发支持。关于 协程 ，除了有效和简单（无论如何简单易用）之外，几乎没有什么可说的了。这是一个很好的抽象。 通道 更为复杂。我一直认为在使用高级包装器之前先理解最基本使用方法。我认为不通过 通道 学习并发编程是很有用的。但是，对我来说，我觉得 通道 的实现方式不像一个简单的抽象。它们几乎都是自己的基本构件。我这样说是因为它们改变了你编写和思考并发编程的方式。 鉴于并发编程有多么困难，这绝对是一件好事。 以及实现组合的简单方式。 最后但也最重要的是内置并发支持。关于 协程 ，除了有效和简单（无论如何简单易用）之外，几乎没有什么可说的了。这是一个很好的抽象。 通道 更为复杂。我一直认为在使用高级包装器之前先理解最基本使用方法。我认为不通过 通道 学习并发编程是很有用的。但是，对我来说，我觉得 通道 的实现方式不像一个简单的抽象。它们几乎都是自己的基本构件。我这样说是因为它们改变了你编写和思考并发编程的方式。 鉴于并发编程有多么困难，这绝对是一件好事。","link":"/2019/04/28/the-little-go-book/"},{"title":"Go 语言实战:  编写可维护 Go 语言代码建议","text":"介绍大家好,我在接下来的两个会议中的目标是向大家提供有关编写 Go 代码最佳实践的建议。 这是一个研讨会形式的演讲，不会有幻灯片,而是直接从文档开始。 贴士: 在这里有最新的文章链接https://dave.cheney.net/practical-go/presentations/qcon-china.html 编者的话 终于翻译完了 Dave 大神的这一篇《Go 语言最佳实践》 耗时两周的空闲时间 翻译的同时也对 Go 语言的开发与实践有了更深层次的了解 有兴趣的同学可以翻阅 Dave 的另一篇博文《SOLID Go 语言设计》(第六章节也会提到) 同时在这里也推荐一个 Telegram Docker 群组(分享/交流): https://t.me/dockertutorial 正文1. 指导原则如果我要谈论任何编程语言的最佳实践，我需要一些方法来定义“什么是最佳”。如果你昨天来到我的主题演讲，你会看到 Go 团队负责人 Russ Cox 的这句话： Software engineering is what happens to programming when you add time and other programmers. (软件工程就是你和其他程序员花费时间在编程上所发生的事情。) — Russ Cox Russ 作出了软件编程与软件工程的区分。 前者是你自己写的一个程序。 后者是很多人会随着时间的推移而开发的产品。 工程师们来来去去，团队会随着时间增长与缩小，需求会发生变化，功能会被添加，错误也会得到修复。 这是软件工程的本质。 我可能是这个房间里 Go 最早的用户之一，但要争辩说我的资历给我的看法更多是假的。相反，今天我要提的建议是基于我认为的 Go 语言本身的指导原则： 简单性 可读性 生产力 注意:你会注意到我没有说性能或并发。 有些语言比 Go 语言快一点，但它们肯定不像 Go 语言那么简单。 有些语言使并发成为他们的最高目标，但它们并不具有可读性及生产力。性能和并发是重要的属性，但不如简单性，可读性和生产力那么重要。 1.1. 简单性我们为什么要追求简单？ 为什么 Go 语言程序的简单性很重要？ 我们都曾遇到过这样的情况: “我不懂这段代码”，不是吗？ 我们都做过这样的项目:你害怕做出改变，因为你担心它会破坏程序的另一部分; 你不理解的部分，不知道如何修复。 这就是复杂性。 复杂性把可靠的软件中变成不可靠。 复杂性是杀死软件项目的罪魁祸首。 简单性是 Go 语言的最高目标。 无论我们编写什么程序，我们都应该同意这一点:它们很简单。 1.2. 可读性 Readability is essential for maintainability. (可读性对于可维护性是至关重要的。) — Mark Reinhold (2018 JVM 语言高层会议) 为什么 Go 语言的代码可读性是很重要的？我们为什么要争取可读性？ Programs must be written for people to read, and only incidentally for machines to execute. (程序应该被写来让人们阅读，只是顺便为了机器执行。) — Hal Abelson 与 Gerald Sussman (计算机程序的结构与解释) 可读性很重要，因为所有软件不仅仅是 Go 语言程序，都是由人类编写的，供他人阅读。执行软件的计算机则是次要的。 代码的读取次数比写入次数多。一段代码在其生命周期内会被读取数百次，甚至数千次。 The most important skill for a programmer is the ability to effectively communicate ideas. (程序员最重要的技能是有效沟通想法的能力。) — Gastón Jorquera [1] 可读性是能够理解程序正在做什么的关键。如果你无法理解程序正在做什么，那你希望如何维护它？如果软件无法维护，那么它将被重写;最后这可能是你的公司最后一次投资 Go 语言。 如果你正在为自己编写一个程序，也许它只需要运行一次，或者你是唯一一个曾经看过它的人，然后做任何对你有用的事。但是，如果是一个不止一个人会贡献编写的软件，或者在很长一段时间内需求、功能或者环境会改变，那么你的目标必须是你的程序可被维护。 编写可维护代码的第一步是确保代码可读。 1.3. 生产力 Design is the art of arranging code to work today, and be changeable forever. (设计是安排代码到工作的艺术，并且永远可变。)— Sandi Metz 我要强调的最后一个基本原则是生产力。开发人员的工作效率是一个庞大的主题，但归结为此; 你花多少时间做有用的工作，而不是等待你的工具或迷失在一个外国的代码库里。 Go 程序员应该觉得他们可以通过 Go 语言完成很多工作。 有人开玩笑说， Go 语言是在等待 C++ 语言程序编译时设计的。快速编译是 Go 语言的一个关键特性，也是吸引新开发人员的关键工具。虽然编译速度仍然是一个持久的战场，但可以说，在其他语言中需要几分钟的编译，在 Go 语言中只需几秒钟。这有助于 Go 语言开发人员感受到与使用动态语言的同行一样的高效，而且没有那些语言固有的可靠性问题。 对于开发人员生产力问题更为基础的是，Go 程序员意识到编写代码是为了阅读，因此将读代码的行为置于编写代码的行为之上。Go 语言甚至通过工具和自定义强制执行所有代码以特定样式格式化。这就消除了项目中学习特定格式的摩擦，并帮助发现错误，因为它们看起来不正确。 Go 程序员不会花费整天的时间来调试不可思议的编译错误。他们也不会将浪费时间在复杂的构建脚本或在生产中部署代码。最重要的是，他们不用花费时间来试图了解他们的同事所写的内容。 当他们说语言必须扩展时，Go 团队会谈论生产力。 2. 标识符我们要讨论的第一个主题是标识符。 标识符是一个用来表示名称的花哨单词; 变量的名称，函数的名称，方法的名称，类型的名称，包的名称等。 Poor naming is symptomatic of poor design. (命名不佳是设计不佳的症状。) — Dave Cheney 鉴于 Go 语言的语法有限，我们为程序选择的名称对我们程序的可读性产生了非常大的影响。 可读性是良好代码的定义质量，因此选择好名称对于 Go 代码的可读性至关重要。 2.1. 选择标识符是为了清晰，而不是简洁 Obvious code is important. What you can do in one line you should do in three. (清晰的代码很重要。在一行可以做的你应当分三行做。(if/else 吗?))— Ukiah Smith Go 语言不是为了单行而优化的语言。 Go 语言不是为了最少行程序而优化的语言。我们没有优化源代码的大小，也没有优化输入所需的时间。 Good naming is like a good joke. If you have to explain it, it’s not funny. (好的命名就像一个好笑话。如果你必须解释它，那就不好笑了。)— Dave Cheney 清晰的关键是在 Go 语言程序中我们选择的标识名称。让我们谈一谈所谓好的名字： 好的名字很简洁。 好的名字不一定是最短的名字，但好的名字不会浪费在无关的东西上。好名字具有高的信噪比。 好的名字是描述性的。 好的名字会描述变量或常量的应用，而不是它们的内容。好的名字应该描述函数的结果或方法的行为，而不是它们的操作。好的名字应该描述包的目的而非它的内容。描述东西越准确的名字就越好。 好的名字应该是可预测的。 你能够从名字中推断出使用方式。这是选择描述性名称的功能，但它也遵循传统。这是 Go 程序员在谈到习惯用语时所谈论的内容。 让我们深入讨论以下这些属性。 2.2. 标识符长度有时候人们批评 Go 语言推荐短变量名的风格。正如 Rob Pike 所说，“ Go 程序员想要正确的长度的标识符”。 [1] Andrew Gerrand 建议通过对某些事物使用更长的标识，向读者表明它们具有更高的重要性。 The greater the distance between a name’s declaration and its uses, the longer the name should be. (名字的声明与其使用之间的距离越大，名字应该越长。) — Andrew Gerrand [2] 由此我们可以得出一些指导方针： 短变量名称在声明和上次使用之间的距离很短时效果很好。 长变量名称需要证明自己的合理性; 名称越长，需要提供的价值越高。冗长的名称与页面上的重量相比，信号量较小。 请勿在变量名称中包含类型名称。 常量应该描述它们持有的值，而不是该如何使用。 对于循环和分支使用单字母变量，参数和返回值使用单个字，函数和包级别声明使用多个单词 方法、接口和包使用单个词。 请记住，包的名称是调用者用来引用名称的一部分，因此要好好利用这一点。 我们来举个栗子: 12345678910111213141516171819type Person struct { Name string Age int}// AverageAge returns the average age of people.func AverageAge(people []Person) int { if len(people) == 0 { return 0 } var count, sum int for _, p := range people { sum += p.Age count += 1 } return sum / count} 在此示例中，变量 p 的在第 10 行被声明并且也只在接下来的一行中被引用。 p 在执行函数期间存在时间很短。如果要了解 p 的作用只需阅读两行代码。 相比之下，people 在函数第 7 行参数中被声明。sum 和 count 也是如此，他们用了更长的名字。读者必须查看更多的行数来定位它们，因此他们名字更为独特。 我可以选择 s 替代 sum 以及 c（或可能是 n）替代 count，但是这样做会将程序中的所有变量份量降低到同样的级别。我可以选择 p 来代替 people，但是用什么来调用 for ... range 迭代变量。如果用 person 的话看起来很奇怪，因为循环迭代变量的生命时间很短，其名字的长度超出了它的值。 贴士:与使用段落分解文档的方式一样用空行来分解函数。 在 AverageAge 中，按顺序共有三个操作。 第一个是前提条件，检查 people 是否为空，第二个是 sum 和 count 的累积，最后是平均值的计算。 2.2.1. 上下文是关键重要的是要意识到关于命名的大多数建议都是需要考虑上下文的。 我想说这是一个原则，而不是一个规则。 两个标识符 i 和 index 之间有什么区别。 我们不能断定一个就比另一个好，例如 123for index := 0; index &lt; len(s); index++ { //} 从根本上说，上面的代码更具有可读性 123for i := 0; i &lt; len(s); i++ { //} 我认为它不是，因为就此事而论, i 和 index 的范围很大可能上仅限于 for 循环的主体，后者的额外冗长性(指 index)几乎没有增加对于程序的理解。 但是，哪些功能更具可读性？ 1func (s *SNMP) Fetch(oid []int, index int) (int, error) 或 1func (s *SNMP) Fetch(o []int, i int) (int, error) 在此示例中，oid 是 SNMP 对象 ID 的缩写，因此将其缩短为 o 意味着程序员必须要将文档中常用符号转换为代码中较短的符号。 类似地将 index 替换成 i，模糊了 i 所代表的含义，因为在 SNMP 消息中，每个 OID 的子值称为索引。 贴士: 在同一声明中长和短形式的参数不能混搭。 2.3. 不要用变量类型命名你的变量你不应该用变量的类型来命名你的变量, 就像您不会将宠物命名为“狗”和“猫”。 出于同样的原因，您也不应在变量名字中包含类型的名字。 变量的名称应描述其内容，而不是内容的类型。 例如： 1var usersMap map[string]*User 这个声明有什么好处？ 我们可以看到它是一个 map，它与 *User 类型有关。 但是 usersMap 是一个 map，而 Go 语言是一种静态类型的语言，如果没有定义变量,不会让我们意外地使用到它，因此 Map 后缀是多余的。 接下来, 如果我们像这样来声明其他变量： 1234var ( companiesMap map[string]*Company productsMap map[string]*Products) usersMap，companiesMap 和 productsMap 三个 map 类型变量，所有映射字符串都是不同的类型。 我们知道它们是 map，我们也知道我们不能使用其中一个来代替另一个 - 如果我们在需要 map[string]*User 的地方尝试使用 companiesMap, 编译器将抛出错误异常。 在这种情况下，很明显变量中 Map 后缀并没有提高代码的清晰度，它只是增加了要输入的额外样板代码。 我的建议是避免使用任何类似变量类型的后缀。 贴士:如果 users 的描述性都不够用，那么 usersMap 也不会。 此建议也适用于函数参数。 例如： 12345type Config struct { //}func WriteConfig(w io.Writer, config *Config) 命名 *Config 参数 config 是多余的。 我们知道它是 *Config 类型，就是这样。 在这种情况下，如果变量的生命周期足够短，请考虑使用 conf 或 c。 如果有更多的 *Config，那么将它们称为 original 和 updated 比 conf1 和 conf2 会更具描述性，因为前者不太可能被互相误解。 贴士:不要让包名窃取好的变量名。导入标识符的名称包括其包名称。 例如，context 包中的 Context 类型将被称为 context.Context。 这使得无法将 context 用作包中的变量或类型。 1func WriteLog(context context.Context, message string) 上面的栗子将会编译出错。 这就是为什么 context.Context 类型的通常的本地声明是 ctx，例如： 1func WriteLog(ctx context.Context, message string) 2.4. 使用一致的命名方式一个好名字的另一个属性是它应该是可预测的。 在第一次遇到该名字时读者就能够理解名字的使用。 当他们遇到常见的名字时，他们应该能够认为自从他们上次看到它以来它没有改变意义。 例如，如果您的代码在处理数据库请确保每次出现参数时，它都具有相同的名称。 与其使用 d * sql.DB，dbase * sql.DB，DB * sql.DB 和 database * sql.DB 的组合，倒不如统一使用: 1db *sql.DB 这样做使读者更为熟悉; 如果你看到db，你知道它就是 *sql.DB 并且它已经在本地声明或者由调用者为你提供。 类似地，对于方法接收器: 在该类型的每个方法上使用相同的接收者名称。 在这种类型的方法内部可以使读者更容易使用。 注意:Go 语言中的短接收者名称惯例与目前提供的建议不一致。 这只是早期做出的选择之一，已经成为首选的风格，就像使用 CamelCase 而不是 snake_case 一样。 贴士:Go 语言样式规定接收器具有单个字母名称或从其类型派生的首字母缩略词。 你可能会发现接收器的名称有时会与方法中参数的名称冲突。 在这种情况下，请考虑将参数名称命名稍长，并且不要忘记一致地使用此新参数名称。 最后，某些单字母变量传统上与循环和计数相关联。 例如，i，j 和 k 通常是简单 for 循环的循环归纳变量。n 通常与计数器或累加器相关联。v 是通用编码函数中值的常用简写，k 通常用于 map 的键，s 通常用作字符串类型参数的简写。 与上面的 db 示例一样，程序员认为 i 是一个循环归纳变量。 如果确保 i 始终是循环变量，而且不在 for 循环之外的其他地方中使用。 当读者遇到一个名为 i 或 j 的变量时，他们知道循环就在附近。 贴士:如果你发现自己有如此多的嵌套循环，i，j 和 k 变量都无法满足时，这个时候可能就是需要将函数分解成更小的函数。 2.5. 使用一致的声明样式Go 至少有六种不同的方式来声明变量 var x int = 1 var x = 1 var x int; x = 1 var x = int(1) x := 1 我确信还有更多我没有想到的。 这可能是 Go 语言的设计师意识到的一个错误，但现在改变它为时已晚。 通过所有这些不同的方式来声明变量，我们如何避免每个 Go 程序员选择自己的风格？ 我想就如何在程序中声明变量提出建议。 这是我尽可能使用的风格。 声明变量但没有初始化时，请使用 var。 当声明变量稍后将在函数中初始化时，请使用 var 关键字。 123456var players int // 0var things []Thing // an empty slice of Thingsvar thing Thing // empty Thing structjson.Unmarshall(reader, &amp;thing) var 表示此变量已被声明为指定类型的零值。 这也与使用 var 而不是短声明语法在包级别声明变量的要求一致 - 尽管我稍后会说你根本不应该使用包级变量。 在声明和初始化时，使用 :=。 在同时声明和初始化变量时，也就是说我们不会将变量初始化为零值，我建议使用短变量声明。 这使得读者清楚地知道 := 左侧的变量是初始化过的。 为了解释原因，让我们看看前面的例子，但这次是初始化每个变量： 123456var players int = 0var things []Thing = nilvar thing *Thing = new(Thing)json.Unmarshall(reader, thing) 在第一个和第三个例子中，因为在 Go 语言中没有从一种类型到另一种类型的自动转换; 赋值运算符左侧的类型必须与右侧的类型相同。 编译器可以从右侧的类型推断出声明的变量的类型，上面的例子可以更简洁地写为： 123456var players = 0var things []Thing = nilvar thing = new(Thing)json.Unmarshall(reader, thing) 我们将 players 初始化为 0，但这是多余的，因为 0 是 players 的零值。 因此，要明确地表示使用零值, 我们将上面例子改写为: 1var players int 第二个声明如何？ 我们不能省略类型而写作: 1var things = nil 因为 nil 没有类型。 [2]相反，我们有一个选择，如果我们要使用切片的零值则写作: 1var things []Thing 或者我们要创建一个有零元素的切片则写作: 1var things = make([]Thing, 0) 如果我们想要后者那么这不是切片的零值，所以我们应该向读者说明我们通过使用简短的声明形式做出这个选择： 1things := make([]Thing, 0) 这告诉读者我们已选择明确初始化事物。 下面是第三个声明， 1var thing = new(Thing) 既是初始化了变量又引入了一些 Go 程序员不喜欢的 new 关键字的罕见用法。 如果我们用推荐地简短声明语法，那么就变成了: 1thing := new(Thing) 这清楚地表明 thing 被初始化为 new(Thing) 的结果 - 一个指向 Thing 的指针 - 但依旧我们使用了 new 地罕见用法。 我们可以通过使用紧凑的文字结构初始化形式来解决这个问题， 1thing := &amp;Thing{} 与 new(Thing) 相同，这就是为什么一些 Go 程序员对重复感到不满。 然而，这意味着我们使用指向 Thing{} 的指针初始化了 thing，也就是 Thing 的零值。 相反，我们应该认识到 thing 被声明为零值，并使用地址运算符将 thing 的地址传递给 json.Unmarshall 12var thing Thingjson.Unmarshall(reader, &amp;thing) 贴士:当然，任何经验法则，都有例外。 例如，有时两个变量密切相关，这样写会很奇怪: 12var min intmax := 1000 如果这样声明可能更具可读性 1min, max := 0, 1000 综上所述： 在没有初始化的情况下声明变量时，请使用 var 语法。 声明并初始化变量时，请使用 :=。 贴士:使复杂的声明显而易见。当事情变得复杂时，它看起来就会很复杂。例如 1var length uint32 = 0x80 这里 length 可能要与特定数字类型的库一起使用，并且 length 明确选择为 uint32 类型而不是短声明形式： 1length := uint32(0x80) 在第一个例子中，我故意违反了规则, 使用 var 声明带有初始化变量的。 这个决定与我的常用的形式不同，这给读者一个线索,告诉他们一些不寻常的事情将会发生。 2.6. 成为团队合作者我谈到了软件工程的目标，即编写可读及可维护的代码。 因此，您可能会将大部分职业生涯用于你不是唯一作者的项目。 我在这种情况下的建议是遵循项目自身风格。 在文件中间更改样式是不和谐的。 即使不是你喜欢的方式，对于维护而言一致性比你的个人偏好更有价值。 我的经验法则是: 如果它通过了 gofmt，那么通常不值得再做代码审查。 贴士:如果要在代码库中进行重命名，请不要将其混合到另一个更改中。 如果有人使用 git bisect，他们不想通过数千行重命名来查找您更改的代码。 3. 注释在我们继续讨论更大的项目之前，我想花几分钟时间谈论一下注释。 Good code has lots of comments, bad code requires lots of comments.(好的代码有很多注释，坏代码需要很多注释。) — Dave Thomas and Andrew Hunt (The Pragmatic Programmer) 注释对 Go 语言程序的可读性非常重要。 注释应该做的三件事中的一件： 注释应该解释其作用。 注释应该解释其如何做的。 注释应该解释其原因。 第一种形式是公共符号注释的理想选择： 12// Open opens the named file for reading.// If successful, methods on the returned file can be used for reading. 第二种形式非常适合在方法中注释： 12345// queue all dependant actionsvar results []chan errorfor _, dep := range a.Deps { results = append(results, execute(seen, dep))} 第三种形式是独一无二的，因为它不会取代前两种形式，但与此同时它并不能代替前两种形式。 此形式的注解用以解释代码的外部因素。 这些因素脱离上下文后通常很难理解，此注释的为了提供这种上下文。 123456return &amp;v2.Cluster_CommonLbConfig{ // Disable HealthyPanicThreshold HealthyPanicThreshold: &amp;envoy_type.Percent{ Value: 0, },} 在此示例中，无法清楚地明白 HealthyPanicThreshold 设置为零百分比的效果。 需要注释 0 值将禁用 panic 阀值。 3.1. 关于变量和常量的注释应描述其内容而非其目的我之前谈过，变量或常量的名称应描述其目的。 向变量或常量添加注释时，该注释应描述变量内容，而不是变量目的。 1const randomNumber = 6 // determined from an unbiased die 在此示例中，注释描述了为什么 randomNumber 被赋值为6，以及6来自哪里。 注释没有描述 randomNumber 的使用位置。 还有更多的栗子： 123456const ( StatusContinue = 100 // RFC 7231, 6.2.1 StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2 StatusProcessing = 102 // RFC 2518, 10.1 StatusOK = 200 // RFC 7231, 6.3.1 在HTTP的上下文中，数字 100 被称为 StatusContinue，如 RFC 7231 第 6.2.1 节中所定义。 贴士:对于没有初始值的变量，注释应描述谁负责初始化此变量。 123// sizeCalculationDisabled indicates whether it is safe// to calculate Types' widths and alignments. See dowidth.var sizeCalculationDisabled bool 这里的注释让读者知道 dowidth 函数负责维护 sizeCalculationDisabled 的状态。 隐藏在众目睽睽下这个提示来自Kate Gregory[3]。有时你会发现一个更好的变量名称隐藏在注释中。 12// registry of SQL driversvar registry = make(map[string]*sql.Driver) 注释是由作者添加的，因为 registry 没有充分解释其目的 - 它是一个注册表，但注册的是什么？ 通过将变量重命名为 sqlDrivers，现在可以清楚地知道此变量的目的是保存SQL驱动程序。 1var sqlDrivers = make(map[string]*sql.Driver) 之前的注释就是多余的，可以删除。 3.2. 公共符号始终要注释godoc 是包的文档，所以应该始终为包中声明的每个公共符号 —​ 变量、常量、函数以及方法添加注释。 以下是 Google Style 指南中的两条规则: 任何既不明显也不简短的公共功能必须予以注释。 无论长度或复杂程度如何，对库中的任何函数都必须进行注释1234567package ioutil// ReadAll reads from r until an error or EOF and returns the data it read.// A successful call returns err == nil, not err == EOF. Because ReadAll is// defined to read from src until EOF, it does not treat an EOF from Read// as an error to be reported.func ReadAll(r io.Reader) ([]byte, error) 这条规则有一个例外; 您不需要注释实现接口的方法。 具体不要像下面这样做：12// Read implements the io.Reader interfacefunc (r *FileReader) Read(buf []byte) (int, error) 这个注释什么也没说。 它没有告诉你这个方法做了什么，更糟糕是它告诉你去看其他地方的文档。 在这种情况下，我建议完全删除该注释。 这是 io 包中的一个例子 12345678910111213141516171819202122232425// LimitReader returns a Reader that reads from r// but stops with EOF after n bytes.// The underlying implementation is a *LimitedReader.func LimitReader(r Reader, n int64) Reader { return &amp;LimitedReader{r, n} }// A LimitedReader reads from R but limits the amount of// data returned to just N bytes. Each call to Read// updates N to reflect the new amount remaining.// Read returns EOF when N &lt;= 0 or when the underlying R returns EOF.type LimitedReader struct { R Reader // underlying reader N int64 // max bytes remaining}func (l *LimitedReader) Read(p []byte) (n int, err error) { if l.N &lt;= 0 { return 0, EOF } if int64(len(p)) &gt; l.N { p = p[0:l.N] } n, err = l.R.Read(p) l.N -= int64(n) return} 请注意，LimitedReader 的声明就在使用它的函数之前，而 LimitedReader.Read 的声明遵循 LimitedReader 本身的声明。 尽管 LimitedReader.Read 本身没有文档，但它清楚地表明它是 io.Reader 的一个实现。 贴士:在编写函数之前，请编写描述函数的注释。 如果你发现很难写出注释，那么这就表明你将要编写的代码很难理解。 3.2.1. 不要注释不好的代码，将它重写 Don’t comment bad code — rewrite it — Brian Kernighan 粗劣的代码的注释高亮显示是不够的。 如果你遇到其中一条注释，则应提出问题，以提醒您稍后重构。 只要技术债务数额已知，它是可以忍受的。 标准库中的惯例是注意到它的人用 TODO(username) 的样式来注释。 1// TODO(dfc) this is O(N^2), find a faster way to do this. 注释 username 不是该人承诺要解决该问题，但在解决问题时他们可能是最好的人选。 其他项目使用 TODO 与日期或问题编号来注释。 3.2.2. 与其注释一段代码，不如重构它 Good code is its own best documentation. As you’re about to add a comment, ask yourself, ‘How can I improve the code so that this comment isn’t needed?’ Improve the code and then document it to make it even clearer.好的代码是最好的文档。 在即将添加注释时，请问下自己，“如何改进代码以便不需要此注释？’ 改进代码使其更清晰。 — Steve McConnell 函数应该只做一件事。 如果你发现自己在注释一段与函数的其余部分无关的代码，请考虑将其提取到它自己的函数中。 除了更容易理解之外，较小的函数更易于隔离测试，将代码隔离到函数中，其名称可能是所需的所有文档。 4. 包的设计 Write shy code - modules that don’t reveal anything unnecessary to other modules and that don’t rely on other modules’ implementations.编写谨慎的代码 - 不向其他模块透露任何不必要的模块，并且不依赖于其他模块的实现。 — Dave Thomas 每个 Go 语言的包实际上都是它一个小小的 Go 语言程序。 正如函数或方法的实现对调用者而言并不重要一样，包的公共API-其函数、方法以及类型的实现对于调用者来说也并不重要。 一个好的 Go 语言包应该具有低程度的源码级耦合，这样，随着项目的增长，对一个包的更改不会跨代码库级联。 这些世界末日的重构严格限制了代码库的变化率以及在该代码库中工作的成员的生产率。 在本节中，我们将讨论如何设计包，包括包的名称，命名类型以及编写方法和函数的技巧。 4.1. 一个好的包从它的名字开始编写一个好的 Go 语言包从包的名称开始。将你的包名用一个词来描述它。 正如我在上一节中谈到变量的名称一样，包的名称也非常重要。我遵循的经验法则不是“我应该在这个包中放入什么类型的？”。相反，我要问是“该包提供的服务是什么？”通常这个问题的答案不是“这个包提供 X 类型”，而是“这个包提供 HTTP”。 贴士:以包所提供的内容来命名，而不是它包含的内容。 4.1.1. 好的包名应该是唯一的。在项目中，每个包名称应该是唯一的。包的名称应该描述其目的的建议很容易理解 - 如果你发现有两个包需要用相同名称，它可能是: 包的名称太通用了。 该包与另一个类似名称的包重叠了。在这种情况下，您应该检查你的设计，或考虑合并包。 4.2. 避免使用类似 base，common 或 util 的包名称不好的包名的常见情况是 utility 包。这些包通常是随着时间的推移一些帮助程序和工具类的包。由于这些包包含各种不相关的功能，因此很难根据包提供的内容来描述它们。这通常会导致包的名称来自包含的内容 - utilities。 像 utils 或 helper 这样的包名称通常出现在较大的项目中，这些项目已经开发了深层次包的结构，并且希望在不遇到导入循环的情况下共享 helper 函数。通过将 utility 程序函数提取到新的包中，导入循环会被破坏，但由于该包源于项目中的设计问题，因此其包名称不反映其目的，仅反映其为了打破导入循环。 我建议改进 utils 或 helpers 包的名称是分析它们的调用位置，如果可能的话，将相关的函数移动到调用者的包中。即使这涉及复制一些 helper 程序代码，这也比在两个程序包之间引入导入依赖项更好。 [A little] duplication is far cheaper than the wrong abstraction.([一点点]重复比错误的抽象的性价比高很多。) — Sandy Metz 在使用 utility 程序的情况下，最好选多个包，每个包专注于单个方面，而不是选单一的整体包。 贴士:使用复数形式命名 utility 包。例如 strings 来处理字符串。 当两个或多个实现共有的功能或客户端和服务器的常见类型被重构为单独的包时，通常会找到名称类似于 base 或 common 的包。我相信解决方案是减少包的数量，将客户端，服务器和公共代码组合到一个以包的功能命名的包中。 例如，net/http 包没有 client 和 server 的分包，而是有一个 client.go 和 server.go 文件，每个文件都有各自的类型，还有一个 transport.go 文件，用于公共消息传输代码。 贴士:标识符的名称包括其包名称。重要的是标识符的名称包括其包的名称。 当由另一个包引用时，net/http 包中的 Get 函数变为 http.Get。 当导入到其他包中时，strings 包中的 Reader 类型变为 strings.Reader。 net 包中的 Error 接口显然与网络错误有关。 4.3. 尽早 return 而不是深度嵌套由于 Go 语言的控制流不使用 exception，因此不需要为 try 和 catch 块提供顶级结构而深度缩进代码。Go 语言代码不是成功的路径越来越深地嵌套到右边，而是以一种风格编写，其中随着函数的进行，成功路径继续沿着屏幕向下移动。 我的朋友 Mat Ryer 将这种做法称为“视线”编码。[4] 这是通过使用 guard clauses 来实现的; 在进入函数时是具有断言前提条件的条件块。 这是一个来自 bytes 包的例子: 12345678910func (b *Buffer) UnreadRune() error { if b.lastRead &lt;= opInvalid { return errors.New(&quot;bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune&quot;) } if b.off &gt;= int(b.lastRead) { b.off -= int(b.lastRead) } b.lastRead = opInvalid return nil} 进入 UnreadRune 后，将检查 b.lastRead 的状态，如果之前的操作不是 ReadRune，则会立即返回错误。 之后，函数的其余部分继续进行 b.lastRead 大于 opInvalid 的断言。 与没有 guard clause 的相同函数进行比较， 12345678910func (b *Buffer) UnreadRune() error { if b.lastRead &gt; opInvalid { if b.off &gt;= int(b.lastRead) { b.off -= int(b.lastRead) } b.lastRead = opInvalid return nil } return errors.New(&quot;bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune&quot;)} 最常见的执行成功的情况是嵌套在第一个if条件内，成功的退出条件是 return nil，而且必须通过仔细匹配大括号来发现。 函数的最后一行是返回一个错误，并且被调用者必须追溯到匹配的左括号，以了解何时执行到此点。 对于读者和维护程序员来说，这更容易出错，因此 Go 语言更喜欢使用 guard clauses 并尽早返回错误。 4.4. 让零值更有用假设变量没有初始化，每个变量声明都会自动初始化为与零内存的内容相匹配的值。 这就是零值。 值的类型决定了其零值; 对于数字类型，它为 0，对于指针类型为 nil，slices、map 和 channel 同样是 nil。 始终设置变量为已知默认值的属性对于程序的安全性和正确性非常重要，并且可以使 Go 语言程序更简单、更紧凑。 这就是 Go 程序员所说的“给你的结构一个有用的零值”。 对于 sync.Mutex 类型。sync.Mutex 包含两个未公开的整数字段，它们用来表示互斥锁的内部状态。 每当声明 sync.Mutex 时，其字段会被设置为 0 初始值。sync.Mutex 利用此属性来编写，使该类型可直接使用而无需初始化。 12345678910111213type MyInt struct { mu sync.Mutex val int}func main() { var i MyInt // i.mu is usable without explicit initialisation. i.mu.Lock() i.val++ i.mu.Unlock()} 另一个利用零值的类型是 bytes.Buffer。您可以声明 bytes.Buffer 然后就直接写入而无需初始化。 12345func main() { var b bytes.Buffer b.WriteString(&quot;Hello, world!\\n&quot;) io.Copy(os.Stdout, &amp;b)} 切片的一个有用属性是它们的零值 nil。如果我们看一下切片运行时 header 的定义就不难理解: 12345type slice struct { array *[...]T // pointer to the underlying array len int cap int} 此结构的零值意味着 len 和 cap 的值为 0，而 array（指向保存切片的内容数组的指针）将为 nil。这意味着你不需要 make 切片，你只需声明它即可。 123456789func main() { // s := make([]string, 0) // s := []string{} var s []string s = append(s, &quot;Hello&quot;) s = append(s, &quot;world&quot;) fmt.Println(strings.Join(s, &quot; &quot;))} 注意:var s []string 类似于它上面的两条注释行，但并不完全相同。值为 nil 的切片与具有零长度的切片就可以来相互比较。以下代码将输出 false。 12345func main() { var s1 = []string{} var s2 []string fmt.Println(reflect.DeepEqual(s1, s2))} nil pointers – 未初始化的指针变量的一个有用属性是你可以在具有 nil 值的类型上调用方法。它可以简单地用于提供默认值。 123456789101112131415161718type Config struct { path string}func (c *Config) Path() string { if c == nil { return &quot;/usr/home&quot; } return c.path}func main() { var c1 *Config var c2 = &amp;Config{ path: &quot;/export&quot;, } fmt.Println(c1.Path(), c2.Path())} 4.5. 避免包级别状态编写可维护程序的关键是它们应该是松散耦合的 - 对一个程序包的更改应该很少影响另一个不直接依赖于第一个程序包的程序包。 在 Go 语言中有两种很好的方法可以实现松散耦合 使用接口来描述函数或方法所需的行为。 避免使用全局状态。 在 Go 语言中，我们可以在函数或方法范围以及包范围内声明变量。当变量是公共的时，给定一个以大写字母开头的标识符，那么它的范围对于整个程序来说实际上是全局的 - 任何包都可以随时观察该变量的类型和内容。 可变全局状态引入程序的独立部分之间的紧密耦合，因为全局变量成为程序中每个函数的不可见参数！如果该变量的类型发生更改，则可以破坏依赖于全局变量的任何函数。如果程序的另一部分更改了该变量，则可以破坏依赖于全局变量状态的任何函数。 如果要减少全局变量所带来的耦合， 将相关变量作为字段移动到需要它们的结构上。 使用接口来减少行为与实现之间的耦合。 5. 项目结构我们来谈谈如何将包组合到项目中。 通常一个项目是一个 git 仓库，但在未来 Go 语言开发人员会交替地使用 module 和 project。 就像一个包，每个项目都应该有一个明确的目的。 如果你的项目是一个库，它应该提供一件事，比如 XML 解析或记录。 您应该避免在一个包实现多个目的，这将有助于避免成为 common 库。 贴士:据我的经验，common 库最终会与其最大的调用者紧密相连，在没有升级该库与最大调用者的情况下是很难修复的，还会带来了许多无关的更改以及API破坏。 如果你的项目是应用程序，如 Web 应用程序，Kubernetes 控制器等，那么项目中可能有一个或多个 main 程序包。 例如，我编写的 Kubernetes 控制器有一个 cmd/contour 包，既可以作为部署到 Kubernetes 集群的服务器，也可以作为调试目的的客户端。 5.1. 考虑更少，更大的包对于从其他语言过渡到 Go 语言的程序员来说，我倾向于在代码审查中提到的一件事是他们会过度使用包。 Go 语言没有提供有关可见性的详细方法; Java有 public、protected、private 以及隐式 default 的访问修饰符。 没有 C++ 的 friend 类概念。 在 Go 语言中，我们只有两个访问修饰符，public 和 private，由标识符的第一个字母的大小写表示。 如果标识符是公共的，则其名称以大写字母开头，该标识符可用于任何其他 Go 语言包的引用。 注意:你可能会听到人们说 exported 与 not exported, 跟 public 和 private 是同义词。 鉴于包的符号的访问有限控件，Go 程序员应遵循哪些实践来避免创建过于复杂的包层次结构？ 贴士:除 cmd/ 和 internal/ 之外的每个包都应包含一些源代码。 我的建议是选择更少，更大的包。 你应该做的是不创建新的程序包。 这将导致太多类型被公开，为你的包创建一个宽而浅的API。 以下部分将更为详细地探讨这一建议。 贴士:来自 Java？如果您来自 Java 或 C#，请考虑这一经验法则 – Java 包相当于单个 .go 源文件。 - Go 语言包相当于整个 Maven 模块或 .NET 程序集。 5.1.1. 通过 import 语句将代码排列到文件中如果你按照包提供的内容来安排你的程序包，是否需要对 Go 包中的文件也执行相同的操作？什么时候应该将 .go 文件拆分成多个文件？什么时候应该考虑整合 .go 文件？ 以下是我的经验法则： 开始时使用一个 .go 文件。为该文件指定与文件夹名称相同的名称。例如: package http 应放在名为 http 的目录中名为 http.go 的文件中。 随着包的增长，您可能决定将各种职责任务拆分为不同的文件。例如：messages.go 包含 Request 和 Response 类型，client.go 包含 Client 类型，server.go包含 Server 类型。 如果你的文件中 import 的声明类似，请考虑将它们组合起来。或者确定 import 集之间的差异并移动它们。 不同的文件应该负责包的不同区域。messages.go 可能负责网络的 HTTP 请求和响应，http.go 可能包含底层网络处理逻辑，client.go 和 server.go 实现 HTTP 业务逻辑请求的实现或路由等等。 贴士: 首选名词为源文件命名。 注意:Go编译器并行编译每个包。 在一个包中，编译器并行编译每个函数（方法只是 Go 语言中函数的另一种写法）。 更改包中代码的布局不会影响编译时间。 5.1.2. 优先内部测试再到外部测试go tool 支持在两个地方编写 testing 包测试。假设你的包名为 http2，您可以编写 http2_test.go 文件并使用包 http2 声明。这样做会编译 http2_test.go 中的代码，就像它是 http2 包的一部分一样。这就是内部测试。 go tool 还支持一个特殊的包声明，以 test 为结尾，即 package http_test。这允许你的测试文件与代码一起存放在同一个包中，但是当编译时这些测试不是包的代码的一部分，它们存在于自己的包中。就像调用另一个包的代码一样来编写测试。这被称为外部测试。 我建议在编写单元测试时使用内部测试。这样你就可以直接测试每个函数或方法，避免外部测试干扰。 但是，你应该将 Example 测试函数放在外部测试文件中。这确保了在 godoc 中查看时，示例具有适当的包名前缀并且可以轻松地进行复制粘贴。 贴士:避免复杂的包层次结构，抵制应用分类法Go 语言包的层次结构对于 go tool 没有任何意义除了下一节要说的。 例如，net/http 包不是一个子包或者 net 包的子包。 如果在项目中创建了不包含 .go 文件的中间目录，则可能无法遵循此建议。 5.1.3. 使用 internal 包来减少公共API如果项目包含多个包，可能有一些公共的函数，这些函数旨在供项目中的其他包使用，但不打算成为项目的公共API的一部分。 如果你发现是这种情况，那么 go tool 会识别一个特殊的文件夹名称 - 而非包名称 - internal/ 可用于放置对项目公开的代码，但对其他项目是私有的。 要创建此类包，请将其放在名为 internal/ 的目录中，或者放在名为 internal/ 的目录的子目录中。 当 go 命令在其路径中看到导入包含 internal 的包时，它会验证执行导入的包是否位于 internal 目录。 例如，.../a/b/c/internal/d/e/f 的包只能通过以 .../a/b/c/ 为根目录的代码被导入。 它无法通过 .../a/b/g 或任何其他仓库中的代码导入。[5] 5.2. 确保 main 包内容尽可能的少main 函数和 main 包的内容应尽可能少。 这是因为 main.main 充当单例; 程序中只能有一个 main 函数，包括 tests。 因为 main.main 是一个单例，假设 main 函数中需要执行很多事情,main.main 只会在 main.main 或 main.init 中调用它们并且只调用一次。 这使得为 main.main 编写代码测试变得很困难，因此你应该将所有业务逻辑从 main 函数中移出，最好是从 main 包中移出。 贴士:main 应该做解析 flags，开启数据库连接、开启日志等，然后将执行交给更高一级的对象。 6. API 设计我今天要给出的最后一条建议是设计, 我认为也是最重要的。 到目前为止我提出的所有建议都是建议。 这些是我尝试编写 Go 语言的方式，但我不打算在代码审查中拼命推广。 但是，在审查 API 时, 我就不会那么宽容了。 这是因为到目前为止我所谈论的所有内容都是可以修复而且不会破坏向后兼容性; 它们在很大程度上是实现的细节。 当涉及到软件包的公共 API 时，在初始设计中投入大量精力是值得的，因为稍后更改该设计对于已经使用 API 的人来说会是破坏性的。 6.1. 设计难以被误用的 API APIs should be easy to use and hard to misuse.(API 应该易于使用且难以被误用) — Josh Bloch [3] 如果你从这个演讲中带走任何东西，那应该是 Josh Bloch 的建议。 如果一个 API 很难用于简单的事情，那么 API 的每次调用都会很复杂。 当 API 的实际调用很复杂时，它就会便得不那么明显，而且会更容易被忽视。 6.1.1. 警惕采用几个相同类型参数的函数简单, 但难以正确使用的 API 是采用两个或更多相同类型参数的 API。 让我们比较两个函数签名： 12func Max(a, b int) intfunc CopyFile(to, from string) error 这两个函数有什么区别？ 显然，一个返回两个数字最大的那个，另一个是复制文件，但这不重要。 12Max(8, 10) // 10Max(10, 8) // 10 Max 是可交换的; 参数的顺序无关紧要。 无论是 8 比 10 还是 10 比 8，最大的都是 10。 但是，却不适用于 CopyFile。 12CopyFile(&quot;/tmp/backup&quot;, &quot;presentation.md&quot;)CopyFile(&quot;presentation.md&quot;, &quot;/tmp/backup&quot;) 这些声明中哪一个备份了 presentation.md，哪一个用上周的版本覆盖了 presentation.md？ 没有文档，你无法分辨。 如果没有查阅文档，代码审查员也无法知道你写对了顺序。 一种可能的解决方案是引入一个 helper 类型，它会负责如何正确地调用 CopyFile。 12345678910type Source stringfunc (src Source) CopyTo(dest string) error { return CopyFile(dest, string(src))}func main() { var from Source = &quot;presentation.md&quot; from.CopyTo(&quot;/tmp/backup&quot;)} 通过这种方式，CopyFile 总是能被正确调用 - 还可以通过单元测试 - 并且可以被设置为私有，进一步降低了误用的可能性。 贴士: 具有多个相同类型参数的API难以正确使用。 6.2. 为其默认用例设计 API几年前，我就对 functional options[7] 进行过讨论[6]，使 API 更易用于默认用例。 本演讲的主旨是你应该为常见用例设计 API。 另一方面， API 不应要求调用者提供他们不在乎参数。 6.2.1. 不鼓励使用 nil 作为参数本章开始时我建议是不要强迫提供给 API 的调用者他们不在乎的参数。 这就是我要说的为默认用例设计 API。 这是 net/http 包中的一个例子 12345678910package http// ListenAndServe listens on the TCP network address addr and then calls// Serve with handler to handle requests on incoming connections.// Accepted connections are configured to enable TCP keep-alives.//// The handler is typically nil, in which case the DefaultServeMux is used.//// ListenAndServe always returns a non-nil error.func ListenAndServe(addr string, handler Handler) error { ListenAndServe 有两个参数，一个用于监听传入连接的 TCP 地址，另一个用于处理 HTTP 请求的 http.Handler。Serve 允许第二个参数为 nil，需要注意的是调用者通常会传递 nil，表示他们想要使用 http.DefaultServeMux 作为隐含参数。 现在，Serve 的调用者有两种方式可以做同样的事情。 12http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil)http.ListenAndServe(&quot;0.0.0.0:8080&quot;, http.DefaultServeMux) 两者完全相同。 这种 nil 行为是病毒式的。 http 包也有一个 http.Serve 帮助类，你可以合理地想象一下 ListenAndServe 是这样构建的 12345678func ListenAndServe(addr string, handler Handler) error { l, err := net.Listen(&quot;tcp&quot;, addr) if err != nil { return err } defer l.Close() return Serve(l, handler)} 因为 ListenAndServe 允许调用者为第二个参数传递 nil，所以 http.Serve 也支持这种行为。 事实上，http.Serve 实现了如果 handler 是nil，使用 DefaultServeMux 的逻辑。 参数可为 nil 可能会导致调用者认为他们可以为两个参数都使用 nil。 像下面这样: 1http.Serve(nil, nil) 会导致 panic。 贴士:不要在同一个函数签名中混合使用可为 nil 和不能为 nil 的参数。 http.ListenAndServe 的作者试图在常见情况下让使用 API 的用户更轻松些，但很可能会让该程序包更难以被安全地使用。 使用 DefaultServeMux 或使用 nil 没有什么区别。 123const root = http.Dir(&quot;/htdocs&quot;)http.Handle(&quot;/&quot;, http.FileServer(root))http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil) 对比 123const root = http.Dir(&quot;/htdocs&quot;)http.Handle(&quot;/&quot;, http.FileServer(root))http.ListenAndServe(&quot;0.0.0.0:8080&quot;, http.DefaultServeMux) 这种混乱值得拯救吗？ 1234const root = http.Dir(&quot;/htdocs&quot;)mux := http.NewServeMux()http.Handle(&quot;/&quot;, http.FileServer(root))http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux) 贴士: 认真考虑 helper 函数会节省不少时间。 清晰要比简洁好。 贴士:避免公共 API 使用测试参数避免在公开的 API 上使用仅在测试范围上不同的值。 相反，使用 Public wrappers 隐藏这些参数，使用辅助方式来设置测试范围中的属性。 6.2.2. 首选可变参数函数而非 []T 参数编写一个带有切片参数的函数或方法是很常见的。 1func ShutdownVMs(ids []string) error 这只是我编的一个例子，但它与我所写的很多代码相同。 这里的问题是他们假设他们会被调用于多个条目。 但是很多时候这些类型的函数只用一个参数调用，为了满足函数参数的要求，它必须打包到一个切片内。 另外，因为 ids 参数是切片，所以你可以将一个空切片或 nil 传递给该函数，编译也没什么错误。 但是这会增加额外的测试负载，因为你应该涵盖这些情况在测试中。 举一个这类 API 的例子，最近我重构了一条逻辑，要求我设置一些额外的字段，如果一组参数中至少有一个非零。 逻辑看起来像这样： 123if svc.MaxConnections &gt; 0 || svc.MaxPendingRequests &gt; 0 || svc.MaxRequests &gt; 0 || svc.MaxRetries &gt; 0 { // apply the non zero parameters} 由于 if 语句变得很长，我想将签出的逻辑拉入其自己的函数中。 这就是我提出的： 123456789// anyPostive indicates if any value is greater than zero.func anyPositive(values ...int) bool { for _, v := range values { if v &gt; 0 { return true } } return false} 这就能够向读者明确内部块的执行条件： 123if anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) { // apply the non zero parameters} 但是 anyPositive 还存在一个问题，有人可能会这样调用它: 1if anyPositive() { ... } 在这种情况下，anyPositive 将返回 false，因为它不会执行迭代而是立即返回 false。对比起如果 anyPositive 在没有传递参数时返回 true, 这还不算世界上最糟糕的事情。 然而，如果我们可以更改 anyPositive 的签名以强制调用者应该传递至少一个参数，那会更好。我们可以通过组合正常和可变参数来做到这一点，如下所示： 123456789101112// anyPostive indicates if any value is greater than zero.func anyPositive(first int, rest ...int) bool { if first &gt; 0 { return true } for _, v := range rest { if v &gt; 0 { return true } } return false} 现在不能使用少于一个参数来调用 anyPositive。 6.3. 让函数定义它们所需的行为假设我需要编写一个将 Document 结构保存到磁盘的函数的任务。 12// Save writes the contents of doc to the file f.func Save(f *os.File, doc *Document) error 我可以指定这个函数 Save，它将 *os.File 作为写入 Document 的目标。但这样做会有一些问题 Save 的签名排除了将数据写入网络位置的选项。假设网络存储可能在以后成为需求，则此功能的签名必须改变，从而影响其所有调用者。 Save 测试起来也很麻烦，因为它直接操作磁盘上的文件。因此，为了验证其操作，测试时必须在写入文件后再读取该文件的内容。 而且我必须确保 f 被写入临时位置并且随后要将其删除。 *os.File 还定义了许多与 Save 无关的方法，比如读取目录并检查路径是否是符号链接。 如果 Save 函数的签名只用 *os.File 的相关内容，那将会很有用。 我们能做什么 ？ 123// Save writes the contents of doc to the supplied// ReadWriterCloser.func Save(rwc io.ReadWriteCloser, doc *Document) error 使用 io.ReadWriteCloser，我们可以应用接口隔离原则来重新定义 Save 以获取更通用文件形式。 通过此更改，任何实现 io.ReadWriteCloser 接口的类型都可以替换以前的 *os.File。 这使 Save 在其应用程序中更广泛，并向 Save 的调用者阐明 *os.File 类型的哪些方法与其操作有关。 而且，Save 的作者也不可以在 *os.File 上调用那些不相关的方法，因为它隐藏在 io.ReadWriteCloser 接口后面。 但我们可以进一步采用接口隔离原则。 首先，如果 Save 遵循单一功能原则，它不可能读取它刚刚写入的文件来验证其内容 - 这应该是另一段代码的功能。 123// Save writes the contents of doc to the supplied// WriteCloser.func Save(wc io.WriteCloser, doc *Document) error 因此，我们可以将我们传递给 Save 的接口的规范缩小到只写和关闭。 其次，通过向 Save 提供一个关闭其流的机制，使其看起来仍然像一个文件，这就提出了在什么情况下关闭 wc 的问题。 可能 Save 会无条件地调用 Close，或者在成功的情况下调用 Close。 这给 Save 的调用者带来了问题，因为它可能希望在写入文档后将其他数据写入流。 123// Save writes the contents of doc to the supplied// Writer.func Save(w io.Writer, doc *Document) error 一个更好的解决方案是重新定义 Save 仅使用 io.Writer，它只负责将数据写入流。 将接口隔离原则应用于我们的 Save 功能，同时, 就需求而言, 得出了最具体的一个函数 - 它只需要一个可写的东西 - 并且它的功能最通用，现在我们可以使用 Save 将我们的数据保存到实现 io.Writer 的任何事物中。 [译注: 不理解设计原则部分的同学可以阅读 Dave 大神的另一篇《Go 语言 SOLID 设计》] 7. 错误处理我已经给出了几个关于错误处理的演示文稿[8]，并在我的博客上写了很多关于错误处理的文章。我在昨天的会议上也讲了很多关于错误处理的内容，所以在这里不再赘述。 https://dave.cheney.net/2014/12/24/inspecting-errors https://dave.cheney.net/2016/04/07/constant-errors 相反，我想介绍与错误处理相关的两个其他方面。 7.1. 通过消除错误来消除错误处理如果你昨天在我的演讲中，我谈到了改进错误处理的提案。但是你知道有什么比改进错误处理的语法更好吗？那就是根本不需要处理错误。 注意:我不是说“删除你的错误处理”。我的建议是，修改你的代码，这样就不用处理错误了。 本节从 John Ousterhout 最近的著作“软件设计哲学”[9]中汲取灵感。该书的其中一章是“定义不存在的错误”。我们将尝试将此建议应用于 Go 语言。 7.1.1. 计算行数让我们编写一个函数来计算文件中的行数。 1234567891011121314151617181920func CountLines(r io.Reader) (int, error) { var ( br = bufio.NewReader(r) lines int err error ) for { _, err = br.ReadString('\\n') lines++ if err != nil { break } } if err != io.EOF { return 0, err } return lines, nil} 由于我们遵循前面部分的建议，CountLines 需要一个 io.Reader，而不是一个 *File；它的任务是调用者为我们想要计算的内容提供 io.Reader。 我们构造一个 bufio.Reader，然后在一个循环中调用 ReadString 方法，递增计数器直到我们到达文件的末尾，然后我们返回读取的行数。 至少这是我们想要编写的代码，但是这个函数由于需要错误处理而变得更加复杂。 例如，有这样一个奇怪的结构: 12345_, err = br.ReadString('\\n')lines++if err != nil { break} 我们在检查错误之前增加了行数，这样做看起来很奇怪。 我们必须以这种方式编写它的原因是，如果在遇到换行符之前就读到文件结束，则 ReadString 将返回错误。如果文件中没有换行符，同样会出现这种情况。 为了解决这个问题，我们重新排列逻辑增来加行数，然后查看是否需要退出循环。 注意:这个逻辑仍然不完美，你能发现错误吗？ 但是我们还没有完成检查错误。当 ReadString 到达文件末尾时，预期它会返回 io.EOF。ReadString 需要某种方式在没有什么可读时来停止。因此，在我们将错误返回给 CountLine 的调用者之前，我们需要检查错误是否是 io.EOF，如果不是将其错误返回，否则我们返回 nil 说一切正常。 我认为这是 Russ Cox 观察到错误处理可能会模​​糊函数操作的一个很好的例子。我们来看一个改进的版本。 123456789func CountLines(r io.Reader) (int, error) { sc := bufio.NewScanner(r) lines := 0 for sc.Scan() { lines++ } return lines, sc.Err()} 这个改进的版本从 bufio.Reader 切换到 bufio.Scanner。 在 bufio.Scanner 内部使用 bufio.Reader，但它添加了一个很好的抽象层，它有助于通过隐藏 CountLines 的操作来消除错误处理。 注意:bufio.Scanner 可以扫描任何模式，但默认情况下它会查找换行符。 如果扫描程序匹配了一行文本并且没有遇到错误，则 sc.Scan() 方法返回 true 。因此，只有当扫描仪的缓冲区中有一行文本时，才会调用 for 循环的主体。这意味着我们修改后的 CountLines 正确处理没有换行符的情况，并且还处理文件为空的情况。 其次，当 sc.Scan 在遇到错误时返回 false，我们的 for 循环将在到达文件结尾或遇到错误时退出。bufio.Scanner 类型会记住遇到的第一个错误，一旦我们使用 sc.Err() 方法退出循环，我们就可以获取该错误。 最后， sc.Err() 负责处理 io.EOF 并在达到文件末尾时将其转换为 nil，而不会遇到其他错误。 贴士:当遇到难以忍受的错误处理时，请尝试将某些操作提取到辅助程序类型中。 7.1.2. WriteResponse我的第二个例子受到了 Errors are values 博客文章[10]的启发。 在本章前面我们已经看过处理打开、写入和关闭文件的示例。错误处理是存在的，但是接收范围内的，因为操作可以封装在诸如 ioutil.ReadFile 和 ioutil.WriteFile 之类的辅助程序中。但是，在处理底层网络协议时，有必要使用 I/O 原始的错误处理来直接构建响应，这样就可能会变得重复。看一下构建 HTTP 响应的 HTTP 服务器的这个片段。 1234567891011121314151617181920212223242526272829type Header struct { Key, Value string}type Status struct { Code int Reason string}func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error { _, err := fmt.Fprintf(w, &quot;HTTP/1.1 %d %s\\r\\n&quot;, st.Code, st.Reason) if err != nil { return err } for _, h := range headers { _, err := fmt.Fprintf(w, &quot;%s: %s\\r\\n&quot;, h.Key, h.Value) if err != nil { return err } } if _, err := fmt.Fprint(w, &quot;\\r\\n&quot;); err != nil { return err } _, err = io.Copy(w, body) return err} 首先，我们使用 fmt.Fprintf 构造状态码并检查错误。 然后对于每个标题，我们写入键值对，每次都检查错误。 最后，我们使用额外的 \\r\\n 终止标题部分，检查错误之后将响应主体复制到客户端。 最后，虽然我们不需要检查 io.Copy 中的错误，但我们需要将 io.Copy 返回的两个返回值形式转换为 WriteResponse 的单个返回值。 这里很多重复性的工作。 我们可以通过引入一个包装器类型 errWriter 来使其更容易。 errWriter 实现 io.Writer 接口，因此可用于包装现有的 io.Writer。 errWriter 写入传递给其底层 writer，直到检测到错误。 从此时起，它会丢弃任何写入并返回先前的错误。 1234567891011121314151617181920212223242526type errWriter struct { io.Writer err error}func (e *errWriter) Write(buf []byte) (int, error) { if e.err != nil { return 0, e.err } var n int n, e.err = e.Writer.Write(buf) return n, nil}func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error { ew := &amp;errWriter{Writer: w} fmt.Fprintf(ew, &quot;HTTP/1.1 %d %s\\r\\n&quot;, st.Code, st.Reason) for _, h := range headers { fmt.Fprintf(ew, &quot;%s: %s\\r\\n&quot;, h.Key, h.Value) } fmt.Fprint(ew, &quot;\\r\\n&quot;) io.Copy(ew, body) return ew.err} 将 errWriter 应用于 WriteResponse 可以显着提高代码的清晰度。 每个操作不再需要自己做错误检查。 通过检查 ew.err 字段，将错误报告移动到函数末尾，从而避免转换从 io.Copy 的两个返回值。 7.2. 错误只处理一次最后，我想提一下你应该只处理错误一次。 处理错误意味着检查错误值并做出单一决定。 1234// WriteAll writes the contents of buf to the supplied writer.func WriteAll(w io.Writer, buf []byte) { w.Write(buf)} 如果你做出的决定少于一个，则忽略该错误。 正如我们在这里看到的那样， w.WriteAll 的错误被丢弃。 但是，针对单个错误做出多个决策也是有问题的。 以下是我经常遇到的代码。 12345678func WriteAll(w io.Writer, buf []byte) error { _, err := w.Write(buf) if err != nil { log.Println(&quot;unable to write:&quot;, err) // annotated error goes to log file return err // unannotated error returned to caller } return nil} 在此示例中，如果在 w.Write 期间发生错误，则会写入日志文件，注明错误发生的文件与行数，并且错误也会返回给调用者，调用者可能会记录该错误并将其返回到上一级，一直回到程序的顶部。 调用者可能正在做同样的事情 123456789101112func WriteConfig(w io.Writer, conf *Config) error { buf, err := json.Marshal(conf) if err != nil { log.Printf(&quot;could not marshal config: %v&quot;, err) return err } if err := WriteAll(w, buf); err != nil { log.Println(&quot;could not write config: %v&quot;, err) return err } return nil} 因此你在日志文件中得到一堆重复的内容， 12unable to write: io.EOFcould not write config: io.EOF 但在程序的顶部，虽然得到了原始错误，但没有相关内容。 12err := WriteConfig(f, &amp;conf)fmt.Println(err) // io.EOF 我想深入研究这一点，因为作为个人偏好, 我并没有看到 logging 和返回的问题。 123456789101112func WriteConfig(w io.Writer, conf *Config) error { buf, err := json.Marshal(conf) if err != nil { log.Printf(&quot;could not marshal config: %v&quot;, err) // oops, forgot to return } if err := WriteAll(w, buf); err != nil { log.Println(&quot;could not write config: %v&quot;, err) return err } return nil} 很多问题是程序员忘记从错误中返回。正如我们之前谈到的那样，Go 语言风格是使用 guard clauses 以及检查前提条件作为函数进展并提前返回。 在这个例子中，作者检查了错误，记录了它，但忘了返回。这就引起了一个微妙的错误。 Go 语言中的错误处理规定，如果出现错误，你不能对其他返回值的内容做出任何假设。由于 JSON 解析失败，buf 的内容未知，可能它什么都没有，但更糟的是它可能包含解析的 JSON 片段部分。 由于程序员在检查并记录错误后忘记返回，因此损坏的缓冲区将传递给 WriteAll，这可能会成功，因此配置文件将被错误地写入。但是，该函数会正常返回，并且发生问题的唯一日志行是有关 JSON 解析错误，而与写入配置失败有关。 7.2.1. 为错误添加相关内容发生错误的原因是作者试图在错误消息中添加 context 。 他们试图给自己留下一些线索，指出错误的根源。 让我们看看使用 fmt.Errorf 的另一种方式。 123456789101112131415161718func WriteConfig(w io.Writer, conf *Config) error { buf, err := json.Marshal(conf) if err != nil { return fmt.Errorf(&quot;could not marshal config: %v&quot;, err) } if err := WriteAll(w, buf); err != nil { return fmt.Errorf(&quot;could not write config: %v&quot;, err) } return nil}func WriteAll(w io.Writer, buf []byte) error { _, err := w.Write(buf) if err != nil { return fmt.Errorf(&quot;write failed: %v&quot;, err) } return nil} 通过将注释与返回的错误组合起来，就更难以忘记错误的返回来避免意外继续。 如果写入文件时发生 I/O 错误，则 error 的 Error() 方法会报告以下类似的内容; 1could not write config: write failed: input/output error 7.2.2. 使用 github.com/pkg/errors 包装 errorsfmt.Errorf 模式适用于注释错误 message，但这样做的代价是模糊了原始错误的类型。 我认为将错误视为不透明值对于松散耦合的软件非常重要，因此如果你使用错误值做的唯一事情是原始错误的类型应该无关紧要的面孔 检查它是否为 nil。 输出或记录它。 但是在某些情况下，我认为它们并不常见，您需要恢复原始错误。 在这种情况下，使用类似我的 errors 包来注释这样的错误, 如下 123456789101112131415161718192021222324252627func ReadFile(path string) ([]byte, error) { f, err := os.Open(path) if err != nil { return nil, errors.Wrap(err, &quot;open failed&quot;) } defer f.Close() buf, err := ioutil.ReadAll(f) if err != nil { return nil, errors.Wrap(err, &quot;read failed&quot;) } return buf, nil}func ReadConfig() ([]byte, error) { home := os.Getenv(&quot;HOME&quot;) config, err := ReadFile(filepath.Join(home, &quot;.settings.xml&quot;)) return config, errors.WithMessage(err, &quot;could not read config&quot;)}func main() { _, err := ReadConfig() if err != nil { fmt.Println(err) os.Exit(1) }} 现在报告的错误就是 K＆D [11]样式错误， 1could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory 并且错误值保留对原始原因的引用。 12345678func main() { _, err := ReadConfig() if err != nil { fmt.Printf(&quot;original error: %T %v\\n&quot;, errors.Cause(err), errors.Cause(err)) fmt.Printf(&quot;stack trace:\\n%+v\\n&quot;, err) os.Exit(1) }} 因此，你可以恢复原始错误并打印堆栈跟踪; 123456789101112131415original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directorystack trace:open /Users/dfc/.settings.xml: no such file or directoryopen failedmain.ReadFile /Users/dfc/devel/practical-go/src/errors/readfile2.go:16main.ReadConfig /Users/dfc/devel/practical-go/src/errors/readfile2.go:29main.main /Users/dfc/devel/practical-go/src/errors/readfile2.go:35runtime.main /Users/dfc/go/src/runtime/proc.go:201runtime.goexit /Users/dfc/go/src/runtime/asm_amd64.s:1333could not read config 使用 errors 包，你可以以人和机器都可检查的方式向错误值添加上下文。 如果昨天你来听我的演讲，你会知道这个库在被移植到即将发布的 Go 语言版本的标准库中。 8. 并发由于 Go 语言的并发功能，经常被选作项目编程语言。 Go 语言团队已经竭尽全力以廉价（在硬件资源方面）和高性能来实现并发，但是 Go 语言的并发功能也可以被用来编写性能不高同时也不太可靠的代码。在结尾，我想留下一些建议，以避免 Go 语言的并发功能带来的一些陷阱。 Go 语言以 channels 以及 select 和 go 语句来支持并发。如果你已经从书籍或培训课程中正式学习了 Go 语言，你可能已经注意到并发部分始终是这些课程的最后一部分。这个研讨会也没有什么不同，我选择最后覆盖并发，好像它是 Go 程序员应该掌握的常规技能的额外补充。 这里有一个二分法; Go 语言的最大特点是简单、轻量级的并发模型。作为一种产品，我们的语言几乎只推广这个功能。另一方面，有一种说法认为并发使用起来实际上并不容易，否则作者不会把它作为他们书中的最后一章，我们也不会遗憾地来回顾其形成过程。 本节讨论了 Go 语言的并发功能的“坑”。 8.1. 保持自己忙碌或做自己的工作这个程序有什么问题？ 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;) }) go func() { if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil { log.Fatal(err) } }() for { }} 该程序实现了我们的预期，它提供简单的 Web 服务。 然而，它同时也做了其他事情，它在无限循环中浪费 CPU 资源。 这是因为 main 的最后一行上的 for {} 将阻塞 main goroutine，因为它不执行任何 IO、等待锁定、发送或接收通道数据或以其他方式与调度器通信。 由于 Go 语言运行时主要是协同调度，该程序将在单个 CPU 上做无效地旋转，并可能最终实时锁定。 我们如何解决这个问题？ 这是一个建议。 1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;runtime&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;) }) go func() { if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil { log.Fatal(err) } }() for { runtime.Gosched() }} 这看起来很愚蠢，但这是我看过的一种常见解决方案。 这是不了解潜在问题的症状。 现在，如果你有更多的经验，你可能会写这样的东西。 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;) }) go func() { if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil { log.Fatal(err) } }() select {}} 空的 select 语句将永远阻塞。 这是一个有用的属性，因为现在我们不再调用 runtime.GoSched() 而耗费整个 CPU。 但是这也只是治疗了症状，而不是病根。 我想向你提出另一种你可能在用的解决方案。 与其在 goroutine 中运行 http.ListenAndServe，会给我们留下处理 main goroutine 的问题，不如在 main goroutine 本身上运行 http.ListenAndServe。 贴士:如果 Go 语言程序的 main.main 函数返回，无论程序在一段时间内启动的其他 goroutine 在做什么, Go 语言程序会无条件地退出。 12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;) }) if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil { log.Fatal(err) }} 所以这是我的第一条建议：如果你的 goroutine 在得到另一个结果之前无法取得进展，那么让自己完成此工作而不是委托给其他 goroutine 会更简单。 这通常会消除将结果从 goroutine 返回到其启动程序所需的大量状态跟踪和通道操作。 贴士:许多 Go 程序员过度使用 goroutine，特别是刚开始时。与生活中的所有事情一样，适度是成功的关键。 8.2. 将并发性留给调用者以下两个 API 有什么区别？ 12// ListDirectory returns the contents of dir.func ListDirectory(dir string) ([]string, error) 1234// ListDirectory returns a channel over which// directory entries will be published. When the list// of entries is exhausted, the channel will be closed.func ListDirectory(dir string) chan string 首先，最明显的不同: 第一个示例将目录读入切片然后返回整个切片，如果出错则返回错误。这是同步发生的，ListDirectory 的调用者会阻塞，直到读取了所有目录条目。根据目录的大小，这可能需要很长时间，并且可能会分配大量内存来构建目录条目。 让我们看看第二个例子。 这个示例更像是 Go 语言风格，ListDirectory 返回一个通道，通过该通道传递目录条目。当通道关闭时，表明没有更多目录条目。由于在 ListDirectory 返回后发生了通道的填充，ListDirectory 可能会启动一个 goroutine 来填充通道。 注意:第二个版本实际上不必使用 Go 协程; 它可以分配一个足以保存所有目录条目而不阻塞的通道，填充通道，关闭它，然后将通道返回给调用者。但这样做不太现实，因为会消耗大量内存来缓冲通道中的所有结果。 通道版本的 ListDirectory 还有两个问题： 通过使用关闭通道作为没有其他项目要处理的信号，在中途遇到了错误时, ListDirectory 无法告诉调用者通过通道返回的项目集是否完整。调用者无法区分空目录和读取目录的错误。两者都导致从 ListDirectory 返回的通道立即关闭。 调用者必须持续从通道中读取，直到它被关闭，因为这是调用者知道此通道的是否停止的唯一方式。这是对 ListDirectory 使用的严重限制，即使可能已经收到了它想要的答案，调用者也必须花时间从通道中读取。就中型到大型目录的内存使用而言，它可能更有效，但这种方法并不比原始的基于切片的方法快。 以上两种实现所带来的问题的解决方案是使用回调，该回调是在执行时在每个目录条目的上下文中调用函数。 1func ListDirectory(dir string, fn func(string)) 毫不奇怪，这就是 filepath.WalkDir 函数的工作方式。 贴士:如果你的函数启动了 goroutine，你必须为调用者提供一种明确停止 goroutine 的方法。 把异步执行函数的决定留给该函数的调用者通常会更容易些。 8.3. 永远不要启动一个停止不了的 goroutine。前面的例子显示当一个任务时没有必要时使用 goroutine。但使用 Go 语言的原因之一是该语言提供的并发功能。实际上，很多情况下你希望利用硬件中可用的并行性。为此，你必须使用 goroutines。 这个简单的应用程序在两个不同的端口上提供 http 服务，端口 8080 用于应用程序服务，端口 8001 用于访问 /debug/pprof 终端。 12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;net/http&quot; _ &quot;net/http/pprof&quot;)func main() { mux := http.NewServeMux() mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) { fmt.Fprintln(resp, &quot;Hello, QCon!&quot;) }) go http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux) // debug http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux) // app traffic} 虽然这个程序不是很复杂，但它代表了真实应用程序的基础。 该应用程序存在一些问题，因为它随着应用程序的增长而显露出来，所以我们现在来解决其中的一些问题。 12345678910111213141516func serveApp() { mux := http.NewServeMux() mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) { fmt.Fprintln(resp, &quot;Hello, QCon!&quot;) }) http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux)}func serveDebug() { http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux)}func main() { go serveDebug() serveApp()} 通过将 serveApp 和 serveDebug 处理程序分解成为它们自己的函数，我们将它们与 main.main 分离。 也遵循了上面的建议，并确保 serveApp 和 serveDebug 将它们的并发性留给调用者。 但是这个程序存在一些可操作性问题。 如果 serveApp 返回，那么 main.main 将返回，导致程序关闭并由你使用的进程管理器来重新启动。 贴士:正如 Go 语言中的函数将并发性留给调用者一样，应用程序应该将监视其状态和检测是否重启的工作留给另外的程序来做。 不要让你的应用程序负责重新启动自己，最好从应用程序外部处理该过程。 然而，serveDebug 是在一个单独的 goroutine 中运行的，返回后该 goroutine 将退出，而程序的其余部分继续。 由于 /debug 处理程序已停止工作很久，因此操作人员不会很高兴发现他们无法在你的应用程序中获取统计信息。 我们想要确保的是，如果任何负责提供此应用程序的 goroutine 停止，我们将关闭该应用程序。 123456789101112131415161718192021func serveApp() { mux := http.NewServeMux() mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) { fmt.Fprintln(resp, &quot;Hello, QCon!&quot;) }) if err := http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux); err != nil { log.Fatal(err) }}func serveDebug() { if err := http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux); err != nil { log.Fatal(err) }}func main() { go serveDebug() go serveApp() select {}} 现在 serverApp 和 serveDebug 检查从 ListenAndServe 返回的错误，并在需要时调用 log.Fatal。因为两个处理程序都在 goroutine 中运行，所以我们将 main goroutine 停在 select{} 中。 这种方法存在许多问题： 如果 ListenAndServer 返回 nil 错误，则不会调用 log.Fatal，并且该端口上的 HTTP 服务将在不停止应用程序的情况下关闭。 log.Fatal 调用 os.Exit，它将无条件地退出程序; defer 不会被调用，其他 goroutines 也不会被通知关闭，程序就停止了。 这使得编写这些函数的测试变得困难。 贴士:只在 main.main 或 init 函数中的使用 log.Fatal。 我们真正想要的是任何错误发送回 goroutine 的调用者，以便它可以知道 goroutine 停止的原因，可以干净地关闭程序进程。 123456789101112131415161718192021222324252627func serveApp() error { mux := http.NewServeMux() mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) { fmt.Fprintln(resp, &quot;Hello, QCon!&quot;) }) return http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux)}func serveDebug() error { return http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux)}func main() { done := make(chan error, 2) go func() { done &lt;- serveDebug() }() go func() { done &lt;- serveApp() }() for i := 0; i &lt; cap(done); i++ { if err := &lt;-done; err != nil { fmt.Println(&quot;error: %v&quot;, err) } }} 我们可以使用通道来收集 goroutine 的返回状态。通道的大小等于我们想要管理的 goroutine 的数量，这样发送到 done 通道就不会阻塞，因为这会阻止 goroutine 的关闭，导致它泄漏。 由于没有办法安全地关闭 done 通道，我们不能使用 for range 来循环通道直到获取所有 goroutine 发来的报告，而是循环我们开启的多个 goroutine，即通道的容量。 现在我们有办法等待每个 goroutine 干净地退出并记录他们遇到的错误。所需要的只是一种从第一个 goroutine 转发关闭信号到其他 goroutine 的方法。 事实证明，要求 http.Server 关闭是有点牵扯的，所以我将这个逻辑转给辅助函数。serve 助手使用一个地址和 http.Handler，类似于 http.ListenAndServe，还有一个 stop 通道，我们用它来触发 Shutdown 方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647func serve(addr string, handler http.Handler, stop &lt;-chan struct{}) error { s := http.Server{ Addr: addr, Handler: handler, } go func() { &lt;-stop // wait for stop signal s.Shutdown(context.Background()) }() return s.ListenAndServe()}func serveApp(stop &lt;-chan struct{}) error { mux := http.NewServeMux() mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) { fmt.Fprintln(resp, &quot;Hello, QCon!&quot;) }) return serve(&quot;0.0.0.0:8080&quot;, mux, stop)}func serveDebug(stop &lt;-chan struct{}) error { return serve(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux, stop)}func main() { done := make(chan error, 2) stop := make(chan struct{}) go func() { done &lt;- serveDebug(stop) }() go func() { done &lt;- serveApp(stop) }() var stopped bool for i := 0; i &lt; cap(done); i++ { if err := &lt;-done; err != nil { fmt.Println(&quot;error: %v&quot;, err) } if !stopped { stopped = true close(stop) } }} 现在，每次我们在 done 通道上收到一个值时，我们关闭 stop 通道，这会导致在该通道上等待的所有 goroutine 关闭其 http.Server。 这反过来将导致其余所有的 ListenAndServe goroutines 返回。 一旦我们开启的所有 goroutine 都停止了，main.main 就会返回并且进程会干净地停止。 贴士:自己编写这种逻辑是重复而微妙的。 参考下这个包: https://github.com/heptio/workgroup，它会为你完成大部分工作。 **引用: ** 1. https://gaston.life/books/effective-programming/ 2. https://talks.golang.org/2014/names.slide#4 3. https://www.infoq.com/articles/API-Design-Joshua-Bloch 1. https://www.lysator.liu.se/c/pikestyle.html 2. https://speakerdeck.com/campoy/understanding-nil 3. https://www.youtube.com/watch?v=Ic2y6w8lMPA 4. https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88 5. https://golang.org/doc/go1.4#internalpackages 6. https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis 7. https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html 8. https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully 9. https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201 10. https://blog.golang.org/errors-are-values 11. http://www.gopl.io/ 原文链接：Practical Go: Real world advice for writing maintainable Go programs 如有翻译有误或者不理解的地方，请评论指正 待更新的译注之后会做进一步修改翻译 翻译：田浩 邮箱：llitfkitfk@gmail.com","link":"/2019/07/22/Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4-Go-%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E5%BB%BA%E8%AE%AE/"},{"title":"提问的智慧","text":"提问的智慧 How To Ask Questions The Smart Way Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen 本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。 原文网址：http://www.catb.org/~esr/faqs/smart-questions.html Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu 本中文指南是基于原文 3.10 版以及 2010 年由 Gasolin 所翻译版本的最新翻译； 协助指出翻译问题，请发 Issue，或直接发 Pull Request 给我。 本文另有繁體中文版。 原文版本历史声明许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明： 本指南不提供此项目的实际支持服务！ 我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。 如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。 简介在黑客的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。 不只是黑客，现在开源（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件好事；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。 首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。 尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。 我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 失败者（撸瑟） （由于历史原因，我们有时把它拼作 lusers）。 我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。 我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答赢家（winner）的问题。 如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。 所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 – 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。 如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 – 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。 （欢迎对本指南提出改进意见。你可以 email 你的建议至 esr@thyrsus.com 或 respond-auto@linuxmafia.com。然而请注意，本文并非网络礼节的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。 在提问之前在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情： 尝试在你准备提问的论坛的旧文章中搜索答案。 尝试上网搜索以找到答案。 尝试阅读手册以找到答案。 尝试阅读常见问题文件（FAQ）以找到答案。 尝试自己检查或试验以找到答案。 向你身边的强者朋友打听以找到答案。 如果你是程序开发者，请尝试阅读源代码以找到答案。 当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所学到的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。 运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（既搜索 Google 论坛，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 我在 Google 中搜过下列句子但没有找到什么有用的东西 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。 别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。 准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。 小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着蠢问题…， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。 绝不要自以为够格得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去挣到一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。 另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。谁能给点提示？、我的这个例子里缺了什么？以及我应该检查什么地方比请把我需要的确切的过程贴出来更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。 当你提问时慎选提问的论坛小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者： 在与主题不合的论坛上贴出你的问题。 在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。 在太多的不同新闻群组上重复转贴同样的问题（cross-post）。 向既非熟人也没有义务解决你问题的人发送私人电邮。 黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。 因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括阅读 FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。 向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别处发送，或者压根别发。 在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。 别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。 搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。 一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。 可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。 Stack Overflow搜索，然后 在 Stack Exchange 问。 近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。 因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。 Stack Exchange 已经成长到超过一百个网站，以下是最常用的几个站： Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。 Stack Overflow 是问写程序有关的问题。 Server Fault 是问服务器和网管相关的问题。 网站和 IRC 论坛本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。 事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用我们的版本”。 在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。 通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。 在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。 第二步，使用项目邮件列表当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法： 任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。 向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。 大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。 如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。 如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。 然而，如果你确信你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意） 如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。 使用有意义且描述明确的标题在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的帮帮忙、跪求、急（更别说救命啊！！！！这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。 一个好标题范例是目标 —— 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。 蠢问题：救命啊！我的笔记本电脑不能正常显示了！ 聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。 更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。 编写目标 —— 差异 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境和你遇到的问题。 总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。 如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 Re: 测试 或者 Re: 新 bug 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。 对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。 仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。 在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你只想在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。 使问题容易回复以请将你的回复发送到……来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，换个好点的；如果是操作系统不支持这种邮件程序，也换个好点的。 在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如追踪此讨论串、有回复时发送邮件提醒等功能。 用清晰、正确、精准并语法正确的语句我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。 正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它必须很准确，而且有迹象表明你是在思考和关注问题。 正确地拼写、使用标点和大小写，不要将its混淆为it's，loose搞成lose或者将discrete弄成discreet。不要全部用大写，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。Alan Cox 也许可以这样做，但你不行）。 更白话的说，如果你写得像是个半文盲[译注：小白]，那多半得不到理睬。也不要使用即时通信中的简写或火星文，如将的简化为d会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。 如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。 如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：[译注：以下附上原文以供使用] English is not my native language; please excuse typing errors. 英文不是我的母语，请原谅我的错字或语法。 If you speak $LANGUAGE, please email/PM me;I may need assistance translating my question. 如果你说某语言，请寄信/私讯给我；我需要有人协助我翻译我的问题。 I am familiar with the technical terms,but some slang expressions and idioms are difficult for me. 我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。 I’ve posted my question in $LANGUAGE and English.I’ll be glad to translate responses, if you only use one or the other. 我把我的问题用某语言和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。 使用易于读取且标准的文件格式发送问题如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以： 使用纯文字而不是 HTML (关闭 HTML 并不难）。 使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。 不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。 但是，对一些特殊的文件不要设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。 在英语论坛中，不要使用Quoted-Printable MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的=20符号既难看也分散注意力，甚至有可能破坏内容的语意。 绝对，永远不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。 如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的智能引号功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉智能引号单选框），以免在你的邮件中到处散布垃圾字符。 在论坛，勿滥用表情符号和HTML功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。 如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的查看源代码命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。 精确地描述问题并言之有物 仔细、清楚地描述你的问题或 Bug 的症状。 描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。 描述在提问前你是怎样去研究和理解这个问题的。 描述在提问前为确定问题而采取的诊断步骤。 描述最近做过什么可能相关的硬件或软件变更。 尽可能的提供一个可以重现这个问题的可控环境的方法。 尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。 以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。 Simon Tatham 写过一篇名为《如何有效的报告 Bug》的出色文章。强力推荐你也读一读。 话不在多而在精你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。 这样做的用处至少有三点。第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；第二，简化问题使你更有可能得到有用的答案；第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。 别动辄声称找到 Bug当你在使用软件中遇到问题，除非你非常、非常的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的Bug，你应该能提供相应位置的修正或替代文件。 请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前已经做了这些，是吧？）。这也意味着很有可能是你弄错了而不是软件本身有问题。 编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有Bug时，这尤其严重。 提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是你做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。 低声下气不能代替你的功课有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：我知道我只是个可悲的新手，一个撸瑟，但...。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。 别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。 有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。 描述问题症状而非你的猜测告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。 蠢问题 我在编译内核时接连遇到 SIG11 错误，我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？ 聪明问题 我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。所有内存都换过了，没有效果。相关部分的标准编译记录如下…。 由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：所有的诊断专家都来自密苏里州。 美国国务院的官方座右铭则是：让我看看（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！ 按发生时间先后列出问题症状问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。 如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，多不等于好。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。 如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。 描述目标而不是过程如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。 经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。 蠢问题 我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？ 聪明问题 我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。 第二种提问法比较聪明，你可能得到像是建议采用另一个更合适的工具的回复。 别要求使用私人电邮回复黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。 当你要求私下回复时，这个过程和奖励都被中止。别这样做，让回复者来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。 这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是向我发电邮，我将为论坛归纳这些回复。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。 清楚明确的表达你的问题以及需求漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。 如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。 要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。 所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问我想更好的理解 X，可否指点一下哪有好一点说明？通常比问你能解释一下 X 吗？更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。 询问有关代码的问题时别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：它不能工作会让你完全被忽略。只贴几十行代码，然后说一句：在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;比较有可能让你得到回应。 最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能刚好展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看话不在多而在精一节）。 一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。 如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。 别把自己家庭作业的问题贴上来黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由你来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。 如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的使用者邮件列表或论坛中提问。尽管黑客们会看出来，但一些有经验的使用者也许仍会给你一些提示。 去掉无意义的提问句避免用无意义的话结束提问，例如有人能帮我吗？或者这有答案吗？。 首先：如果你对问题的描述不是很好，这样问更是画蛇添足。 其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：没错，有人能帮你或者不，没答案。 一般来说，避免用 是或否、对或错、有或没有类型的问句，除非你想得到是或否类型的回答。 即使你很急也不要在标题写紧急这是你的问题，不是我们的。宣称紧急极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，紧急这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。 有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。 当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如紧急：帮我救救这个毛绒绒的小海豹！肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。 如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。 礼多人不怪，而且有时还很有帮助彬彬有礼，多用请和谢谢您的关注，或谢谢你的关照。让大家都知道你对他们花时间免费提供帮助心存感激。 坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的） 然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。 （我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得先谢了意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说先谢了，然后事后再对回复者表示感谢，或者换种方式表达感激，譬如用谢谢你的关注或谢谢你的关照。） 问题解决后，加个简短的补充说明问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。 最理想的方式是向最初提问的话题回复此消息，并在标题中包含已修正，已解决或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串问题 X和问题 X - 已解决的潜在回复者就明白不用再浪费时间了（除非他个人觉得问题 X的有趣），因此可以利用此时间去解决其它问题。 补充说明不必很长或是很深入；简单的一句你好，原来是网线出了问题！谢谢大家 – Bill比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。 对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此之后才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。 除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。 至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。 思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。 在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。 如何解读答案 RTFM 和 STFW：如何知道你已完全搞砸了有一个古老而神圣的传统：如果你收到RTFM （Read The Fucking Manual）的回应，回答者认为你应该去读他妈的手册。当然，基本上他是对的，你应该去读一读。 RTFM 有一个年轻的亲戚。如果你收到STFW（Search The Fucking Web）的回应，回答者认为你应该到他妈的网上搜索。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 **Google 是你的朋友**！） 在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。 通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为 你需要的信息非常容易获得； 你自己去搜索这些信息比灌给你，能让你学到更多。 你不应该因此不爽；依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见。你应该对他祖母般的慈祥表示感谢。 如果还是搞不懂如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。 比方说，如果我回答你：看来似乎是 zentry 卡住了；你应该先清除它。，然后，这是一个很糟的后续问题回应：zentry 是什么？ 好的问法应该是这样：哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？ 处理无礼的回应很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。 如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这没有发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而你将被视为有错的一方，这将伤害到你获取信息或帮助的机会。 另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。 （有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会正常交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们喜欢我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑）。 Jeff Bigler 的观察总结和这个相关也值得一读 (tact filters)。 在下一节，我们会谈到另一个问题，当你行为不当时所会受到的冒犯。 如何避免扮演失败者在黑客社区的论坛中有那么几次你可能会搞砸 —— 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。 这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做： 熬过去，这很正常。事实上，它是有益健康且合理的。 社区的标准不会自行维持，它们是通过参与者积极而公开地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。 也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称如果你不想帮助用户就闭嘴。 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。 夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。 记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。 有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是真的会把问题搞砸。 这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。 也别让自己卷入口水战，最好不要理睬大多数的口水战 – 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。 不该问的问题以下是几个经典蠢问题，以及黑客没回答时心中所想的： 问题：我能在哪找到 X 程序或 X 资源？ 问题：我怎样用 X 做 Y？ 问题：如何设定我的 shell 提示？ 问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？ 问题：我的程序/设定/SQL 语句没有用 问题：我的 Windows 电脑有问题，你能帮我吗？ 问题：我的程序不会动了，我认为系统工具 X 有问题 问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？ 问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？ 问题：我能在哪找到 X 程序或 X 资源？ 回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 Google 吗？ 问题：我怎样用 X 做 Y？ 回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。 问题：如何设定我的 shell 提示？？ 回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 RTFM，然后自己去找出来。 问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？ 回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。 问题：我的{程序/设定/SQL 语句}不工作 回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种 你还有什么要补充的吗？ 真糟糕，希望你能搞定。 这关我有什么屁事？ 问题：我的 Windows 电脑有问题，你能帮我吗？ 回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。 注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你可以问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。 问题：我的程序不会动了，我认为系统工具 X 有问题 回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。 问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？ 回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在这儿找到使用者群组的清单）。 注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 Linux 和所有被怀疑的硬件作关键词仔细搜索。 问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？ 回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！ 好问题与蠢问题最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。 蠢问题： 我可以在哪儿找到关于 Foonly Flurbamatic 的资料？ 这种问法无非想得到 STFW 这样的回答。 聪明问题： 我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？ 这个问题已经 STFW 过了，看起来他真的遇到了麻烦。 蠢问题： 我从 foo 项目找来的源码没法编译。它怎么这么烂？ 他觉得都是别人的错，这个傲慢自大的提问者。 聪明问题： foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？ 提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。 蠢问题： 我的主机板有问题了，谁来帮我？ 某黑客对这类问题的回答通常是：好的，还要帮你拍拍背和换尿布吗？，然后按下删除键。 聪明问题： 我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？ 这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。 在最后一个问题中，注意告诉我答案和给我启示，指出我还应该做什么诊断工作之间微妙而又重要的区别。 事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。 通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。 事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的名人，而是因为我用了正确的方式来提问。 黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我像个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。 如果得不到回答如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。 总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。 你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。 有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。 另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。 对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。 如何更好地回答问题态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。 对初犯者私下回复。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。 如果你不确定，一定要说出来！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。 如果帮不了忙，也别妨碍他。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —— 有些可怜的呆瓜会把它当成真的指令。 试探性的反问以引出更多的细节。如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。 尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。 如果你决定回答，就请给出好的答案。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。 正面的回答问题！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 试试看 A 或是 B 或者 试试 X 、 Y 、 Z 、 A 、 B 、 C 并附上一个链接一点用都没有。 帮助你的社区从问题中学习。当回复一个好问题时，问问自己如何修改相关文件或常见问题文件以免再次解答同样的问题？，接着再向文件维护者发一份补丁。 如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟授人以鱼不如授人以渔。 相关资源如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 Unix 系统和网络基本原理。 当你发布软件或补丁时，试着按软件发布实践操作。 鸣谢Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写如何更好地回答问题这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。","link":"/2019/02/25/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","link":"/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"mariadb","slug":"mariadb","link":"/tags/mariadb/"},{"name":"程序员","slug":"程序员","link":"/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Hadoop","slug":"Hadoop","link":"/tags/Hadoop/"},{"name":"HexoClient","slug":"HexoClient","link":"/tags/HexoClient/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"tesseract","slug":"tesseract","link":"/tags/tesseract/"},{"name":"ocr","slug":"ocr","link":"/tags/ocr/"},{"name":"JavaCV","slug":"JavaCV","link":"/tags/JavaCV/"},{"name":"ElasticSearch","slug":"ElasticSearch","link":"/tags/ElasticSearch/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"ffmpeg","slug":"ffmpeg","link":"/tags/ffmpeg/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"shadowsocks","slug":"shadowsocks","link":"/tags/shadowsocks/"},{"name":"Electron","slug":"Electron","link":"/tags/Electron/"},{"name":"推荐系统","slug":"推荐系统","link":"/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"js","slug":"js","link":"/tags/js/"}],"categories":[{"name":"碎碎念","slug":"碎碎念","link":"/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"程序员","slug":"程序员","link":"/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]}
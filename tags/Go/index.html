<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: Go - 雾非雾的情思</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="雾非雾的情思"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="雾非雾的情思"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="雾非雾的情思"><meta property="og:url" content="http://www.mspring.org/"><meta property="og:site_name" content="雾非雾的情思"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.mspring.org/img/og_image.png"><meta property="article:author" content="雾非雾的情思"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.mspring.org"},"headline":"雾非雾的情思","image":["http://www.mspring.org/img/og_image.png"],"author":{"@type":"Person","name":"雾非雾的情思"},"description":null}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="雾非雾的情思" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="http://file.mspring.org/images/blog/avatar.jpg" alt="雾非雾的情思" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/links">友链</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Github" href="https://github.com/gaoyoubo"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">Go</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-11-13T17:52:29.000Z" title="11/13/2019, 5:52:29 PM">2019-11-13</time>发表</span><span class="level-item"><time dateTime="2021-06-10T02:08:47.731Z" title="6/10/2021, 2:08:47 AM">2021-06-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></span><span class="level-item">5 分钟读完 (大约737个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/13/Use-Go-Channels-as-Promises-and-Async-Await/">Use Go Channels as Promises and Async/Await</a></h1><div class="content"><p>原文地址：<a target="_blank" rel="noopener" href="https://levelup.gitconnected.com/use-go-channels-as-promises-and-async-await-ee62d93078ec">https://levelup.gitconnected.com/use-go-channels-as-promises-and-async-await-ee62d93078ec</a></p>
<p>If you’ve ever programmed with <em>Javascript</em>, you definitely know about <code>Promise</code> and <code>async</code>/<code>await</code>. <em>C#</em>, *Java, Python, *and some other programming languages apply the same pattern but with other names such as <code>Task</code> or <code>Future</code>.</p>
<p>On the contrary, Go doesn’t follow the pattern at all. Instead, it introduces <code>goroutines</code> and <code>channels</code>. However, it isn’t difficult to replicate the pattern with <code>goroutines</code> and <code>channels</code>.</p>
<hr>
<h1 id="Single-async-await"><a href="#Single-async-await" class="headerlink" title="Single async/await"></a>Single async/await</h1><p>First, let’s experiment with a simple use case: <code>await</code> a result from an <code>async</code> function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Javascript.</span><br><span class="line"></span><br><span class="line">const longRunningTask &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; Simulate a workload.</span><br><span class="line">    sleep(3000)</span><br><span class="line">    return Math.floor(Math.random() * Math.floor(100))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const r &#x3D; await longRunningTask()</span><br><span class="line">console.log(r)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longRunningTask</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int32</span></span> &#123;</span><br><span class="line">	r := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int32</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(r)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Simulate a workload.</span></span><br><span class="line">		time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">		r &lt;- rand.Int31n(<span class="number">100</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := &lt;-longRunningTask()</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Single async/await in Javascript vs. Golang</p>
<p>To declare an “async” function in Go:</p>
<ul>
<li>The return type is <code>&lt;-chan ReturnType</code>.</li>
<li>Within the function, create a channel by <code>make(chan ReturnType)</code> and return the created channel at the end of the function.</li>
<li>Start an anonymous goroutine by <code>go func() &#123;...&#125;</code> and implement the function’s logic inside that anonymous function.</li>
<li>Return the result by sending the value to channel.</li>
<li>At the beginning of the anonymous function, add <code>defer close(r)</code> to close the channel once done.</li>
</ul>
<p>To “await” the result, simply read the value from channel by <code>v := &lt;- fn()</code>.</p>
<hr>
<h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h1><p>It’s very common that we start multiple async tasks then wait for all of them to finish and gather their results. Doing that is quite simple in both Javascript and Golang.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Javascript.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> longRunningTask = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Simulate a workload.</span></span><br><span class="line">    sleep(<span class="number">3000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="built_in">Math</span>.floor(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b, c] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(longRunningTask(), longRunningTask(), longRunningTask())</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longRunningTask</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int32</span></span> &#123;</span><br><span class="line">	r := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int32</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(r)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Simulate a workload.</span></span><br><span class="line">		time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">		r &lt;- rand.Int31n(<span class="number">100</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	aCh, bCh, cCh := longRunningTask(), longRunningTask(), longRunningTask()</span><br><span class="line">	a, b, c := &lt;-aCh, &lt;-bCh, &lt;-cCh</span><br><span class="line">	</span><br><span class="line">	fmt.Println(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We have to do it in 2 lines of code and introduce 3 more variables, but it’s clean and simple enough.</p>
<p>We can not do <code>&lt;-longRun(), &lt;-longRun(), &lt;-longRun()</code>, which will <code>longRun()</code> one by one instead all in once.</p>
<hr>
<h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h1><p>Sometimes, a piece of data can be received from several sources to avoid high latencies, or there’re cases that multiple results are generated but they’re equivalent and the only first response is consumed. This first-response-win pattern, therefore, is quite popular. Achieving that in both Javascript and Go is very simple.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Javascript.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Simulate a workload.</span></span><br><span class="line">    sleep(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="built_in">Math</span>.floor(<span class="number">2000</span>)))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> two = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Simulate a workload.</span></span><br><span class="line">    sleep(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="built_in">Math</span>.floor(<span class="number">1000</span>)))</span><br><span class="line">    sleep(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="built_in">Math</span>.floor(<span class="number">1000</span>)))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> r = <span class="keyword">await</span> <span class="built_in">Promise</span>.race(one(), two())</span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">one</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int32</span></span> &#123;</span><br><span class="line">	r := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int32</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(r)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Simulate a workload.</span></span><br><span class="line">		time.Sleep(time.Millisecond * time.Duration(rand.Int63n(<span class="number">2000</span>)))</span><br><span class="line">		r &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">two</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int32</span></span> &#123;</span><br><span class="line">	r := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int32</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(r)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Simulate a workload.</span></span><br><span class="line">		time.Sleep(time.Millisecond * time.Duration(rand.Int63n(<span class="number">1000</span>)))</span><br><span class="line">		time.Sleep(time.Millisecond * time.Duration(rand.Int63n(<span class="number">1000</span>)))</span><br><span class="line">		r &lt;- <span class="number">2</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> r <span class="keyword">int32</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> r = &lt;-one():</span><br><span class="line">	<span class="keyword">case</span> r = &lt;-two():</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>select-case</code> is the pattern that Go designed specifically for racing channel operations. We can even do more stuff within each case, but we’re focusing only on the result so we just leave them all empty.</p>
<hr>
<h1 id="Promise-then-and-Promise-catch"><a href="#Promise-then-and-Promise-catch" class="headerlink" title="Promise.then() and Promise.catch()"></a>Promise.then() and Promise.catch()</h1><p>Because Go’s error propagation model is very different from Javascript, there’s any clean way to replicate <code>Promise.then()</code> and <code>Promise.catch()</code>. In Go, error is returned along with return values instead of being thrown as exception. Therefore, if your function can fail, you can consider changing your return <code>&lt;-chan ReturnType</code> into <code>&lt;-chan ReturnAndErrorType</code>, which is a struct holding both the result and error.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-07-22T12:33:47.000Z" title="7/22/2019, 12:33:47 PM">2019-07-22</time>发表</span><span class="level-item"><time dateTime="2021-06-10T02:08:47.727Z" title="6/10/2021, 2:08:47 AM">2021-06-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></span><span class="level-item">2 小时读完 (大约22463个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/22/Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4-Go-%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E5%BB%BA%E8%AE%AE/">Go 语言实战:  编写可维护 Go 语言代码建议</a></h1><div class="content"><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>大家好,我在接下来的两个会议中的目标是向大家提供有关编写 Go 代码最佳实践的建议。</p>
<p>这是一个研讨会形式的演讲，不会有幻灯片,而是直接从文档开始。</p>
<blockquote>
<p>贴士: 在这里有最新的文章链接<br><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a></p>
</blockquote>
<h2 id="编者的话"><a href="#编者的话" class="headerlink" title="编者的话"></a>编者的话</h2><ul>
<li>终于翻译完了 Dave 大神的这一篇《<strong>Go 语言最佳实践</strong>》</li>
<li>耗时两周的空闲时间</li>
<li>翻译的同时也对 Go 语言的开发与实践有了更深层次的了解</li>
<li>有兴趣的同学可以翻阅 Dave 的另一篇博文<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0aebd9618300">《<strong>SOLID Go 语言设计</strong>》</a>(第六章节也会提到)</li>
<li>同时在这里也推荐一个 Telegram Docker 群组(分享/交流): <a target="_blank" rel="noopener" href="https://t.me/dockertutorial">https://t.me/dockertutorial</a></li>
</ul>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-指导原则"><a href="#1-指导原则" class="headerlink" title="1. 指导原则"></a>1. 指导原则</h3><p>如果我要谈论任何编程语言的最佳实践，我需要一些方法来定义“什么是最佳”。如果你昨天来到我的主题演讲，你会看到 Go 团队负责人 Russ Cox 的这句话：</p>
<blockquote>
<p>Software engineering is what happens to programming when you add time and other programmers. (软件工程就是你和其他程序员花费时间在编程上所发生的事情。)<br>   — Russ Cox</p>
</blockquote>
<p>Russ 作出了软件编程与软件工程的区分。 前者是你自己写的一个程序。 后者是很多人会随着时间的推移而开发的产品。 工程师们来来去去，团队会随着时间增长与缩小，需求会发生变化，功能会被添加，错误也会得到修复。 这是软件工程的本质。</p>
<p>我可能是这个房间里 Go 最早的用户之一，<del>但要争辩说我的资历给我的看法更多是假的</del>。相反，今天我要提的建议是基于我认为的 Go 语言本身的指导原则：</p>
<ol>
<li>简单性</li>
<li>可读性</li>
<li>生产力</li>
</ol>
<blockquote>
<p>注意:<br>你会注意到我没有说性能或并发。 有些语言比 Go 语言快一点，但它们肯定不像 Go 语言那么简单。 有些语言使并发成为他们的最高目标，但它们并不具有可读性及生产力。<br>性能和并发是重要的属性，但不如简单性，可读性和生产力那么重要。</p>
</blockquote>
<h4 id="1-1-简单性"><a href="#1-1-简单性" class="headerlink" title="1.1. 简单性"></a>1.1. 简单性</h4><p>我们为什么要追求简单？ 为什么 Go 语言程序的简单性很重要？</p>
<p>我们都曾遇到过这样的情况: “我不懂这段代码”，不是吗？ 我们都做过这样的项目:你害怕做出改变，因为你担心它会破坏程序的另一部分; 你不理解的部分，不知道如何修复。</p>
<p>这就是复杂性。 复杂性把可靠的软件中变成不可靠。 复杂性是杀死软件项目的罪魁祸首。</p>
<p>简单性是 Go 语言的最高目标。 无论我们编写什么程序，我们都应该同意这一点:它们很简单。</p>
<h4 id="1-2-可读性"><a href="#1-2-可读性" class="headerlink" title="1.2. 可读性"></a>1.2. 可读性</h4><blockquote>
<p>Readability is essential for maintainability.<br> (可读性对于可维护性是至关重要的。)<br>    — Mark Reinhold (2018 JVM 语言高层会议)</p>
</blockquote>
<p>为什么 Go 语言的代码可读性是很重要的？我们为什么要争取可读性？</p>
<blockquote>
<p>Programs must be written for people to read, and only incidentally for machines to execute. (程序应该被写来让人们阅读，只是顺便为了机器执行。)<br> — Hal Abelson 与 Gerald Sussman (计算机程序的结构与解释)</p>
</blockquote>
<p>可读性很重要，因为所有软件不仅仅是 Go 语言程序，都是由人类编写的，供他人阅读。执行软件的计算机则是次要的。</p>
<p>代码的读取次数比写入次数多。一段代码在其生命周期内会被读取数百次，甚至数千次。</p>
<blockquote>
<p>The most important skill for a programmer is the ability to effectively communicate ideas. (程序员最重要的技能是有效沟通想法的能力。)<br>  — Gastón Jorquera <a href="(https://gaston.life/books/effective-programming/)">[1]</a></p>
</blockquote>
<p>可读性是能够理解程序正在做什么的关键。如果你无法理解程序正在做什么，那你希望如何维护它？如果软件无法维护，那么它将被重写;最后这可能是你的公司最后一次投资 Go 语言。</p>
<p><del>如果你正在为自己编写一个程序，也许它只需要运行一次，或者你是唯一一个曾经看过它的人，然后做任何对你有用的事。</del>但是，如果是一个不止一个人会贡献编写的软件，或者在很长一段时间内需求、功能或者环境会改变，那么你的目标必须是你的程序可被维护。</p>
<p>编写可维护代码的第一步是确保代码可读。</p>
<h4 id="1-3-生产力"><a href="#1-3-生产力" class="headerlink" title="1.3. 生产力"></a>1.3. 生产力</h4><blockquote>
<p>Design is the art of arranging code to work today, and be changeable forever. (设计是安排代码到工作的艺术，并且永远可变。)<br>— Sandi Metz</p>
</blockquote>
<p>我要强调的最后一个基本原则是生产力。开发人员的工作效率是一个庞大的主题，但归结为此; 你花多少时间做有用的工作，而不是等待你的工具或迷失在一个外国的代码库里。 Go 程序员应该觉得他们可以通过 Go 语言完成很多工作。</p>
<p>有人开玩笑说， Go 语言是在等待 C++ 语言程序编译时设计的。快速编译是 Go 语言的一个关键特性，也是吸引新开发人员的关键工具。虽然编译速度仍然是一个持久的战场，但可以说，在其他语言中需要几分钟的编译，在 Go 语言中只需几秒钟。这有助于 Go 语言开发人员感受到与使用动态语言的同行一样的高效，而且没有那些语言固有的可靠性问题。</p>
<p>对于开发人员生产力问题更为基础的是，Go 程序员意识到编写代码是为了阅读，因此将读代码的行为置于编写代码的行为之上。Go 语言甚至通过工具和自定义强制执行所有代码以特定样式格式化。这就消除了项目中学习特定格式的摩擦，并帮助发现错误，因为它们看起来不正确。</p>
<p>Go 程序员不会花费整天的时间来调试不可思议的编译错误。他们也不会将浪费时间在复杂的构建脚本或在生产中部署代码。最重要的是，他们不用花费时间来试图了解他们的同事所写的内容。</p>
<p>当他们说语言必须扩展时，Go 团队会谈论生产力。</p>
<h3 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2. 标识符"></a>2. 标识符</h3><p>我们要讨论的第一个主题是标识符。 标识符是一个用来表示名称的花哨单词; 变量的名称，函数的名称，方法的名称，类型的名称，包的名称等。</p>
<blockquote>
<p>Poor naming is symptomatic of poor design. (命名不佳是设计不佳的症状。)<br>  — Dave Cheney</p>
</blockquote>
<p>鉴于 Go 语言的语法有限，我们为程序选择的名称对我们程序的可读性产生了非常大的影响。 可读性是良好代码的定义质量，因此选择好名称对于 Go 代码的可读性至关重要。</p>
<h4 id="2-1-选择标识符是为了清晰，而不是简洁"><a href="#2-1-选择标识符是为了清晰，而不是简洁" class="headerlink" title="2.1. 选择标识符是为了清晰，而不是简洁"></a>2.1. 选择标识符是为了清晰，而不是简洁</h4><blockquote>
<p>Obvious code is important. What you can do in one line you should do in three.<br> (清晰的代码很重要。在一行可以做的你应当分三行做。(<code>if/else</code> 吗?))<br>— Ukiah Smith</p>
</blockquote>
<p> Go 语言不是为了单行而优化的语言。  Go 语言不是为了最少行程序而优化的语言。我们没有优化源代码的大小，也没有优化输入所需的时间。</p>
<blockquote>
<p>Good naming is like a good joke. If you have to explain it, it’s not funny.<br> (好的命名就像一个好笑话。如果你必须解释它，那就不好笑了。)<br>— Dave Cheney</p>
</blockquote>
<p>清晰的关键是在 Go 语言程序中我们选择的标识名称。让我们谈一谈所谓好的名字：</p>
<ul>
<li><p><strong>好的名字很简洁。</strong> 好的名字不一定是最短的名字，但好的名字不会浪费在无关的东西上。好名字具有高的信噪比。</p>
</li>
<li><p><strong>好的名字是描述性的。</strong> 好的名字会描述变量或常量的应用，而不是它们的内容。好的名字应该描述函数的结果或方法的行为，而不是它们的操作。好的名字应该描述包的目的而非它的内容。描述东西越准确的名字就越好。</p>
</li>
<li><p><strong>好的名字应该是可预测的。</strong> 你能够从名字中推断出使用方式。<del>这是选择描述性名称的功能，但它也遵循传统。</del>这是 Go 程序员在谈到习惯用语时所谈论的内容。</p>
</li>
</ul>
<p>让我们深入讨论以下这些属性。</p>
<h4 id="2-2-标识符长度"><a href="#2-2-标识符长度" class="headerlink" title="2.2. 标识符长度"></a>2.2. 标识符长度</h4><p>有时候人们批评 Go 语言推荐短变量名的风格。正如 Rob Pike 所说，“ Go 程序员想要正确的长度的标识符”。 <a target="_blank" rel="noopener" href="https://www.lysator.liu.se/c/pikestyle.html">[1]</a></p>
<p>Andrew Gerrand 建议通过对某些事物使用更长的标识，向读者表明它们具有更高的重要性。</p>
<blockquote>
<p>The greater the distance between a name’s declaration and its uses, the longer the name should be. (名字的声明与其使用之间的距离越大，名字应该越长。)<br> — Andrew Gerrand <a target="_blank" rel="noopener" href="https://talks.golang.org/2014/names.slide#4">[2]</a></p>
</blockquote>
<p>由此我们可以得出一些指导方针：</p>
<ul>
<li>短变量名称在声明和上次使用之间的距离很短时效果很好。</li>
<li>长变量名称需要证明自己的合理性; 名称越长，需要提供的价值越高。冗长的名称与页面上的重量相比，信号量较小。</li>
<li>请勿在变量名称中包含类型名称。</li>
<li>常量应该描述它们持有的值，而不是该如何使用。</li>
<li>对于循环和分支使用单字母变量，参数和返回值使用单个字，函数和包级别声明使用多个单词</li>
<li>方法、接口和包使用单个词。</li>
<li>请记住，包的名称是调用者用来引用名称的一部分，因此要好好利用这一点。</li>
</ul>
<p>我们来举个栗子:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AverageAge returns the average age of people.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AverageAge</span><span class="params">(people []Person)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(people) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> count, sum <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> people &#123;</span><br><span class="line">		sum += p.Age</span><br><span class="line">		count += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sum / count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此示例中，变量 <code>p</code> 的在第 <code>10</code> 行被声明并且也只在接下来的一行中被引用。 <code>p</code> 在执行函数期间存在时间很短。如果要了解 <code>p</code> 的作用只需阅读两行代码。</p>
<p>相比之下，<code>people</code> 在函数第 <code>7</code> 行参数中被声明。<code>sum</code> 和 <code>count</code> 也是如此，他们用了更长的名字。读者必须查看更多的行数来定位它们，因此他们名字更为独特。</p>
<p>我可以选择 <code>s</code> 替代 <code>sum</code> 以及 <code>c</code>（或可能是 <code>n</code>）替代 <code>count</code>，但是这样做会将程序中的所有变量份量降低到同样的级别。我可以选择 <code>p</code> 来代替 <code>people</code>，但是用什么来调用 <code>for ... range</code> 迭代变量。如果用 <code>person</code> 的话看起来很奇怪，因为循环迭代变量的生命时间很短，其名字的长度超出了它的值。</p>
<blockquote>
<p>贴士:<br>与使用段落分解文档的方式一样用空行来分解函数。 在 <code>AverageAge</code> 中，按顺序共有三个操作。 第一个是前提条件，检查 <code>people</code> 是否为空，第二个是 <code>sum</code> 和 <code>count</code> 的累积，最后是平均值的计算。</p>
</blockquote>
<h4 id="2-2-1-上下文是关键"><a href="#2-2-1-上下文是关键" class="headerlink" title="2.2.1. 上下文是关键"></a>2.2.1. 上下文是关键</h4><p>重要的是要意识到关于命名的大多数建议都是需要考虑上下文的。 我想说这是一个原则，而不是一个规则。</p>
<p>两个标识符 <code>i</code> 和 <code>index</code> 之间有什么区别。 我们不能断定一个就比另一个好，例如</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="built_in">len</span>(s); index++ &#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从根本上说，上面的代码更具有可读性</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我认为它不是，因为就此事而论, <code>i</code> 和 <code>index</code> 的范围很大可能上仅限于 for 循环的主体，后者的额外冗长性(指 <code>index</code>)几乎没有增加对于程序的理解。</p>
<p>但是，哪些功能更具可读性？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SNMP)</span> <span class="title">Fetch</span><span class="params">(oid []<span class="keyword">int</span>, index <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SNMP)</span> <span class="title">Fetch</span><span class="params">(o []<span class="keyword">int</span>, i <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>oid</code> 是 <code>SNMP</code> 对象 <code>ID</code> 的缩写，因此将其缩短为 <code>o</code> 意味着程序员必须要将文档中常用符号转换为代码中较短的符号。 类似地将 <code>index</code> 替换成 <code>i</code>，模糊了 <code>i</code> 所代表的含义，因为在 <code>SNMP</code> 消息中，每个 <code>OID</code> 的子值称为索引。</p>
<blockquote>
<p>贴士: 在同一声明中长和短形式的参数不能混搭。</p>
</blockquote>
<h4 id="2-3-不要用变量类型命名你的变量"><a href="#2-3-不要用变量类型命名你的变量" class="headerlink" title="2.3. 不要用变量类型命名你的变量"></a>2.3. 不要用变量类型命名你的变量</h4><p>你不应该用变量的类型来命名你的变量, 就像您不会将宠物命名为“狗”和“猫”。 出于同样的原因，您也不应在变量名字中包含类型的名字。</p>
<p>变量的名称应描述其内容，而不是内容的类型。 例如：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> usersMap <span class="keyword">map</span>[<span class="keyword">string</span>]*User</span><br></pre></td></tr></table></figure>
<p>这个声明有什么好处？ 我们可以看到它是一个 <code>map</code>，它与 <code>*User</code> 类型有关。 但是 <code>usersMap</code> 是一个 <code>map</code>，而 Go 语言是一种静态类型的语言，如果没有定义变量,不会让我们意外地使用到它，因此 <code>Map</code> 后缀是多余的。</p>
<p>接下来, 如果我们像这样来声明其他变量：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	companiesMap <span class="keyword">map</span>[<span class="keyword">string</span>]*Company</span><br><span class="line">	productsMap <span class="keyword">map</span>[<span class="keyword">string</span>]*Products</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>usersMap</code>，<code>companiesMap</code> 和 <code>productsMap</code> 三个 <code>map</code> 类型变量，所有映射字符串都是不同的类型。 我们知道它们是 <code>map</code>，我们也知道我们不能使用其中一个来代替另一个 - 如果我们在需要 <code>map[string]*User</code> 的地方尝试使用 <code>companiesMap</code>, 编译器将抛出错误异常。 在这种情况下，很明显变量中 <code>Map</code> 后缀并没有提高代码的清晰度，它只是增加了要输入的额外样板代码。</p>
<p>我的建议是避免使用任何类似变量类型的后缀。</p>
<blockquote>
<p>贴士:<br>如果 <code>users</code> 的描述性都不够用，那么 <code>usersMap</code> 也不会。</p>
</blockquote>
<p>此建议也适用于函数参数。 例如：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, config *Config)</span></span></span><br></pre></td></tr></table></figure>
<p>命名 <code>*Config</code> 参数 <code>config</code> 是多余的。 我们知道它是 <code>*Config</code> 类型，就是这样。</p>
<p>在这种情况下，如果变量的生命周期足够短，请考虑使用 <code>conf</code> 或 <code>c</code>。</p>
<p>如果有更多的 <code>*Config</code>，那么将它们称为 <code>original</code> 和 <code>updated</code> 比 <code>conf1</code> 和 <code>conf2</code> 会更具描述性，因为前者不太可能被互相误解。</p>
<blockquote>
<p>贴士:<br>不要让包名窃取好的变量名。<br>导入标识符的名称包括其包名称。 例如，<code>context</code> 包中的 <code>Context</code> 类型将被称为 <code>context.Context</code>。 这使得无法将 <code>context</code> 用作包中的变量或类型。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteLog</span><span class="params">(context context.Context, message <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的栗子将会编译出错。 这就是为什么 <code>context.Context</code> 类型的通常的本地声明是 <code>ctx</code>，例如：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteLog</span><span class="params">(ctx context.Context, message <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-使用一致的命名方式"><a href="#2-4-使用一致的命名方式" class="headerlink" title="2.4. 使用一致的命名方式"></a>2.4. 使用一致的命名方式</h4><p>一个好名字的另一个属性是它应该是可预测的。 在第一次遇到该名字时读者就能够理解名字的使用。 当他们遇到常见的名字时，他们应该能够认为自从他们上次看到它以来它没有改变意义。</p>
<p>例如，如果您的代码在处理数据库请确保每次出现参数时，它都具有相同的名称。 与其使用 <code>d * sql.DB</code>，<code>dbase * sql.DB</code>，<code>DB * sql.DB</code> 和 <code>database * sql.DB</code> 的组合，倒不如统一使用:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db *sql.DB</span><br></pre></td></tr></table></figure>
<p>这样做使读者更为熟悉; 如果你看到<code>db</code>，你知道它就是 <code>*sql.DB</code> 并且它已经在本地声明或者由调用者为你提供。</p>
<p>类似地，对于方法接收器: 在该类型的每个方法上使用相同的接收者名称。 在这种类型的方法内部可以使读者更容易使用。</p>
<blockquote>
<p>注意:<br>Go 语言中的短接收者名称惯例与目前提供的建议不一致。 这只是早期做出的选择之一，已经成为首选的风格，就像使用 <code>CamelCase</code> 而不是 <code>snake_case</code> 一样。</p>
</blockquote>
<blockquote>
<p>贴士:<br>Go 语言样式规定接收器具有单个字母名称或从其类型派生的首字母缩略词。 你可能会发现接收器的名称有时会与方法中参数的名称冲突。 在这种情况下，请考虑将参数名称命名稍长，并且不要忘记一致地使用此新参数名称。</p>
</blockquote>
<p>最后，某些单字母变量传统上与循环和计数相关联。 例如，<code>i</code>，<code>j</code> 和 <code>k</code> 通常是简单 <code>for</code> 循环的循环归纳变量。<code>n</code> 通常与计数器或累加器相关联。<code>v</code> 是通用编码函数中值的常用简写，<code>k</code> 通常用于 <code>map</code> 的键，<code>s</code> 通常用作字符串类型参数的简写。</p>
<p>与上面的 <code>db</code> 示例一样，程序员认为 <code>i</code> 是一个循环归纳变量。 如果确保 <code>i</code> 始终是循环变量，而且不在 <code>for</code> 循环之外的其他地方中使用。 当读者遇到一个名为 <code>i</code> 或 <code>j</code> 的变量时，他们知道循环就在附近。</p>
<blockquote>
<p>贴士:<br>如果你发现自己有如此多的嵌套循环，<code>i</code>，<code>j</code> 和 <code>k</code> 变量都无法满足时，这个时候可能就是需要将函数分解成更小的函数。</p>
</blockquote>
<h4 id="2-5-使用一致的声明样式"><a href="#2-5-使用一致的声明样式" class="headerlink" title="2.5. 使用一致的声明样式"></a>2.5. 使用一致的声明样式</h4><p>Go 至少有六种不同的方式来声明变量</p>
<ul>
<li><code>var x int = 1</code></li>
<li><code>var x = 1</code></li>
<li><code>var x int; x = 1</code></li>
<li><code>var x = int(1)</code></li>
<li><code>x := 1</code></li>
</ul>
<p>我确信还有更多我没有想到的。 这可能是 Go 语言的设计师意识到的一个错误，但现在改变它为时已晚。 通过所有这些不同的方式来声明变量，我们如何避免每个 Go 程序员选择自己的风格？</p>
<p>我想就如何在程序中声明变量提出建议。 这是我尽可能使用的风格。</p>
<ul>
<li><p><strong>声明变量但没有初始化时，请使用 <code>var</code>。</strong> 当声明变量稍后将在函数中初始化时，请使用 <code>var</code> 关键字。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> players <span class="keyword">int</span>    <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> things []Thing <span class="comment">// an empty slice of Things</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing Thing    <span class="comment">// empty Thing struct</span></span><br><span class="line">json.Unmarshall(reader, &amp;thing)</span><br></pre></td></tr></table></figure>
<p><code>var</code> 表示此变量已被声明为指定类型的零值。 这也与使用 <code>var</code> 而不是短声明语法在包级别声明变量的要求一致 - 尽管我稍后会说你根本不应该使用包级变量。</p>
</li>
<li><p><strong>在声明和初始化时，使用 <code>:=</code>。</strong> 在同时声明和初始化变量时，也就是说我们不会将变量初始化为零值，我建议使用短变量声明。 这使得读者清楚地知道 <code>:=</code> 左侧的变量是初始化过的。</p>
</li>
</ul>
<p>为了解释原因，让我们看看前面的例子，但这次是初始化每个变量：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> players <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> things []Thing = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing *Thing = <span class="built_in">new</span>(Thing)</span><br><span class="line">json.Unmarshall(reader, thing)</span><br></pre></td></tr></table></figure>
<p>在第一个和第三个例子中，因为在 Go 语言中没有从一种类型到另一种类型的自动转换; 赋值运算符左侧的类型必须与右侧的类型相同。 编译器可以从右侧的类型推断出声明的变量的类型，上面的例子可以更简洁地写为：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> players = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> things []Thing = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="built_in">new</span>(Thing)</span><br><span class="line">json.Unmarshall(reader, thing)</span><br></pre></td></tr></table></figure>
<p>我们将 <code>players</code> 初始化为 <code>0</code>，但这是多余的，因为 <code>0</code> 是 <code>players</code> 的零值。 因此，要明确地表示使用零值, 我们将上面例子改写为:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> players <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>第二个声明如何？ 我们不能省略类型而写作:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> things = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>nil</code> 没有类型。 <a target="_blank" rel="noopener" href="https://speakerdeck.com/campoy/understanding-nil">[2]</a>相反，我们有一个选择，如果我们要使用切片的零值则写作:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> things []Thing</span><br></pre></td></tr></table></figure>
<p>或者我们要创建一个有零元素的切片则写作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var things &#x3D; make([]Thing, 0)</span><br></pre></td></tr></table></figure>
<p>如果我们想要后者那么这不是切片的零值，所以我们应该向读者说明我们通过使用简短的声明形式做出这个选择：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">things := <span class="built_in">make</span>([]Thing, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这告诉读者我们已选择明确初始化事物。</p>
<p>下面是第三个声明，</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thing = <span class="built_in">new</span>(Thing)</span><br></pre></td></tr></table></figure>
<p>既是初始化了变量又引入了一些 Go 程序员不喜欢的 <code>new</code> 关键字的罕见用法。 如果我们用推荐地简短声明语法，那么就变成了:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thing := <span class="built_in">new</span>(Thing)</span><br></pre></td></tr></table></figure>
<p>这清楚地表明 <code>thing</code> 被初始化为 <code>new(Thing)</code> 的结果 - 一个指向 <code>Thing</code> 的指针 - 但依旧我们使用了 <code>new</code> 地罕见用法。 我们可以通过使用紧凑的文字结构初始化形式来解决这个问题，</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thing := &amp;Thing&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>与 <code>new(Thing)</code> 相同，这就是为什么一些 Go 程序员对重复感到不满。 然而，这意味着我们使用指向 <code>Thing&#123;&#125;</code> 的指针初始化了 <code>thing</code>，也就是 <code>Thing</code> 的零值。</p>
<p>相反，我们应该认识到 <code>thing</code> 被声明为零值，并使用地址运算符将 <code>thing</code> 的地址传递给 <code>json.Unmarshall</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thing Thing</span><br><span class="line">json.Unmarshall(reader, &amp;thing)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>贴士:<br>当然，任何经验法则，都有例外。 例如，有时两个变量密切相关，这样写会很奇怪:</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> min <span class="keyword">int</span></span><br><span class="line">max := <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果这样声明可能更具可读性</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min, max := <span class="number">0</span>, <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>综上所述：</p>
<p>在没有初始化的情况下声明变量时，请使用 <code>var</code> 语法。</p>
<p>声明并初始化变量时，请使用 <code>:=</code>。</p>
<blockquote>
<p>贴士:<br>使复杂的声明显而易见。<br>当事情变得复杂时，它看起来就会很复杂。例如</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> length <span class="keyword">uint32</span> = <span class="number">0x80</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里 <code>length</code> 可能要与特定数字类型的库一起使用，并且 <code>length</code> 明确选择为 <code>uint32</code> 类型而不是短声明形式：</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length := <span class="keyword">uint32</span>(<span class="number">0x80</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在第一个例子中，我故意违反了规则, 使用 <code>var</code> 声明带有初始化变量的。 这个决定与我的常用的形式不同，这给读者一个线索,告诉他们一些不寻常的事情将会发生。</p>
</blockquote>
<h4 id="2-6-成为团队合作者"><a href="#2-6-成为团队合作者" class="headerlink" title="2.6. 成为团队合作者"></a>2.6. 成为团队合作者</h4><p>我谈到了软件工程的目标，即编写可读及可维护的代码。 因此，您可能会将大部分职业生涯用于你不是唯一作者的项目。 我在这种情况下的建议是遵循项目自身风格。</p>
<p>在文件中间更改样式是不和谐的。 即使不是你喜欢的方式，对于维护而言一致性比你的个人偏好更有价值。 我的经验法则是: 如果它通过了 <code>gofmt</code>，那么通常不值得再做代码审查。</p>
<blockquote>
<p>贴士:<br>如果要在代码库中进行重命名，请不要将其混合到另一个更改中。 如果有人使用 <code>git bisect</code>，他们不想通过数千行重命名来查找您更改的代码。</p>
</blockquote>
<h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h3><p>在我们继续讨论更大的项目之前，我想花几分钟时间谈论一下注释。</p>
<blockquote>
<p>Good code has lots of comments, bad code requires lots of comments.<br>(好的代码有很多注释，坏代码需要很多注释。)<br> — Dave Thomas and Andrew Hunt (The Pragmatic Programmer)</p>
</blockquote>
<p>注释对 Go 语言程序的可读性非常重要。 注释应该做的三件事中的一件：</p>
<ol>
<li>注释应该解释其作用。</li>
<li>注释应该解释其如何做的。</li>
<li>注释应该解释其原因。</li>
</ol>
<p>第一种形式是公共符号注释的理想选择：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open opens the named file for reading.</span></span><br><span class="line"><span class="comment">// If successful, methods on the returned file can be used for reading.</span></span><br></pre></td></tr></table></figure>
<p>第二种形式非常适合在方法中注释：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// queue all dependant actions</span></span><br><span class="line"><span class="keyword">var</span> results []<span class="keyword">chan</span> error</span><br><span class="line"><span class="keyword">for</span> _, dep := <span class="keyword">range</span> a.Deps &#123;</span><br><span class="line">        results = <span class="built_in">append</span>(results, execute(seen, dep))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种形式是独一无二的，因为它不会取代前两种形式，但与此同时它并不能代替前两种形式。 此形式的注解用以解释代码的外部因素。 这些因素脱离上下文后通常很难理解，此注释的为了提供这种上下文。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;v2.Cluster_CommonLbConfig&#123;</span><br><span class="line">	<span class="comment">// Disable HealthyPanicThreshold</span></span><br><span class="line">        HealthyPanicThreshold: &amp;envoy_type.Percent&#123;</span><br><span class="line">        	Value: <span class="number">0</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此示例中，无法清楚地明白 <code>HealthyPanicThreshold</code> 设置为零百分比的效果。 需要注释 <code>0</code> 值将禁用 <code>panic</code> 阀值。</p>
<h4 id="3-1-关于变量和常量的注释应描述其内容而非其目的"><a href="#3-1-关于变量和常量的注释应描述其内容而非其目的" class="headerlink" title="3.1. 关于变量和常量的注释应描述其内容而非其目的"></a>3.1. 关于变量和常量的注释应描述其内容而非其目的</h4><p>我之前谈过，变量或常量的名称应描述其目的。 向变量或常量添加注释时，该注释应描述变量内容，而不是变量目的。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomNumber = <span class="number">6</span> <span class="comment">// determined from an unbiased die</span></span><br></pre></td></tr></table></figure>
<p>在此示例中，注释描述了为什么 <code>randomNumber</code> 被赋值为6，以及6来自哪里。 注释没有描述 <code>randomNumber</code> 的使用位置。 还有更多的栗子：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    StatusContinue           = <span class="number">100</span> <span class="comment">// RFC 7231, 6.2.1</span></span><br><span class="line">    StatusSwitchingProtocols = <span class="number">101</span> <span class="comment">// RFC 7231, 6.2.2</span></span><br><span class="line">    StatusProcessing         = <span class="number">102</span> <span class="comment">// RFC 2518, 10.1</span></span><br><span class="line"></span><br><span class="line">    StatusOK                 = <span class="number">200</span> <span class="comment">// RFC 7231, 6.3.1</span></span><br></pre></td></tr></table></figure>
<p>在HTTP的上下文中，数字 <code>100</code> 被称为 <code>StatusContinue</code>，如 RFC 7231 第 6.2.1 节中所定义。</p>
<blockquote>
<p>贴士:<br>对于没有初始值的变量，注释应描述谁负责初始化此变量。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeCalculationDisabled indicates whether it is safe</span></span><br><span class="line"><span class="comment">// to calculate Types&#x27; widths and alignments. See dowidth.</span></span><br><span class="line"><span class="keyword">var</span> sizeCalculationDisabled <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的注释让读者知道 <code>dowidth</code> 函数负责维护 <code>sizeCalculationDisabled</code> 的状态。</p>
<p><strong>隐藏在众目睽睽下</strong><br>这个提示来自Kate Gregory<a target="_blank" rel="noopener" href="https://www.infoq.com/articles/API-Design-Joshua-Bloch">[3]</a>。有时你会发现一个更好的变量名称隐藏在注释中。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// registry of SQL drivers</span></span><br><span class="line"><span class="keyword">var</span> registry = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*sql.Driver)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注释是由作者添加的，因为 <code>registry</code> 没有充分解释其目的 - 它是一个注册表，但注册的是什么？</p>
<p>通过将变量重命名为 <code>sqlDrivers</code>，现在可以清楚地知道此变量的目的是保存SQL驱动程序。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sqlDrivers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*sql.Driver)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之前的注释就是多余的，可以删除。</p>
</blockquote>
<h4 id="3-2-公共符号始终要注释"><a href="#3-2-公共符号始终要注释" class="headerlink" title="3.2. 公共符号始终要注释"></a>3.2. 公共符号始终要注释</h4><p><code>godoc</code> 是包的文档，所以应该始终为包中声明的每个公共符号 —​ 变量、常量、函数以及方法添加注释。</p>
<p>以下是 <code>Google Style</code> 指南中的两条规则:</p>
<ul>
<li>任何既不明显也不简短的公共功能必须予以注释。</li>
<li>无论长度或复杂程度如何，对库中的任何函数都必须进行注释<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ioutil</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadAll reads from r until an error or EOF and returns the data it read.</span></span><br><span class="line"><span class="comment">// A successful call returns err == nil, not err == EOF. Because ReadAll is</span></span><br><span class="line"><span class="comment">// defined to read from src until EOF, it does not treat an EOF from Read</span></span><br><span class="line"><span class="comment">// as an error to be reported.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>
这条规则有一个例外; 您不需要注释实现接口的方法。 具体不要像下面这样做：<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read implements the io.Reader interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *FileReader)</span> <span class="title">Read</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>
这个注释什么也没说。 它没有告诉你这个方法做了什么，更糟糕是它告诉你去看其他地方的文档。 在这种情况下，我建议完全删除该注释。</li>
</ul>
<p>这是 <code>io</code> 包中的一个例子</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LimitReader returns a Reader that reads from r</span></span><br><span class="line"><span class="comment">// but stops with EOF after n bytes.</span></span><br><span class="line"><span class="comment">// The underlying implementation is a *LimitedReader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LimitReader</span><span class="params">(r Reader, n <span class="keyword">int64</span>)</span> <span class="title">Reader</span></span> &#123; <span class="keyword">return</span> &amp;LimitedReader&#123;r, n&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A LimitedReader reads from R but limits the amount of</span></span><br><span class="line"><span class="comment">// data returned to just N bytes. Each call to Read</span></span><br><span class="line"><span class="comment">// updates N to reflect the new amount remaining.</span></span><br><span class="line"><span class="comment">// Read returns EOF when N &lt;= 0 or when the underlying R returns EOF.</span></span><br><span class="line"><span class="keyword">type</span> LimitedReader <span class="keyword">struct</span> &#123;</span><br><span class="line">	R Reader <span class="comment">// underlying reader</span></span><br><span class="line">	N <span class="keyword">int64</span>  <span class="comment">// max bytes remaining</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LimitedReader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> l.N &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, EOF</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">int64</span>(<span class="built_in">len</span>(p)) &gt; l.N &#123;</span><br><span class="line">		p = p[<span class="number">0</span>:l.N]</span><br><span class="line">	&#125;</span><br><span class="line">	n, err = l.R.Read(p)</span><br><span class="line">	l.N -= <span class="keyword">int64</span>(n)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<code>LimitedReader</code> 的声明就在使用它的函数之前，而 <code>LimitedReader.Read</code> 的声明遵循 <code>LimitedReader</code> 本身的声明。 尽管 <code>LimitedReader.Read</code> 本身没有文档，但它清楚地表明它是 <code>io.Reader</code> 的一个实现。</p>
<blockquote>
<p>贴士:<br>在编写函数之前，请编写描述函数的注释。 如果你发现很难写出注释，那么这就表明你将要编写的代码很难理解。</p>
</blockquote>
<h4 id="3-2-1-不要注释不好的代码，将它重写"><a href="#3-2-1-不要注释不好的代码，将它重写" class="headerlink" title="3.2.1. 不要注释不好的代码，将它重写"></a>3.2.1. 不要注释不好的代码，将它重写</h4><blockquote>
<p>Don’t comment bad code — rewrite it<br>   — Brian Kernighan</p>
</blockquote>
<p>粗劣的代码的注释高亮显示是不够的。 如果你遇到其中一条注释，则应提出问题，以提醒您稍后重构。 只要技术债务数额已知，它是可以忍受的。</p>
<p>标准库中的惯例是注意到它的人用 <code>TODO(username)</code> 的样式来注释。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO(dfc) this is O(N^2), find a faster way to do this.</span></span><br></pre></td></tr></table></figure>
<p>注释 <code>username</code> 不是该人承诺要解决该问题，但在解决问题时他们可能是最好的人选。 其他项目使用 <code>TODO</code> 与日期或问题编号来注释。</p>
<h4 id="3-2-2-与其注释一段代码，不如重构它"><a href="#3-2-2-与其注释一段代码，不如重构它" class="headerlink" title="3.2.2. 与其注释一段代码，不如重构它"></a>3.2.2. 与其注释一段代码，不如重构它</h4><blockquote>
<p>Good code is its own best documentation. As you’re about to add a comment, ask yourself, ‘How can I improve the code so that this comment isn’t needed?’ Improve the code and then document it to make it even clearer.<br>好的代码是最好的文档。 在即将添加注释时，请问下自己，“如何改进代码以便不需要此注释？’ 改进代码使其更清晰。<br> — Steve McConnell</p>
</blockquote>
<p>函数应该只做一件事。 如果你发现自己在注释一段与函数的其余部分无关的代码，请考虑将其提取到它自己的函数中。</p>
<p>除了更容易理解之外，较小的函数更易于隔离测试，将代码隔离到函数中，其名称可能是所需的所有文档。</p>
<h3 id="4-包的设计"><a href="#4-包的设计" class="headerlink" title="4. 包的设计"></a>4. 包的设计</h3><blockquote>
<p>Write shy code - modules that don’t reveal anything unnecessary to other modules and that don’t rely on other modules’ implementations.<br>编写谨慎的代码 - 不向其他模块透露任何不必要的模块，并且不依赖于其他模块的实现。<br> — Dave Thomas</p>
</blockquote>
<p>每个 Go 语言的包实际上都是它一个小小的 Go 语言程序。 正如函数或方法的实现对调用者而言并不重要一样，包的公共API-其函数、方法以及类型的实现对于调用者来说也并不重要。</p>
<p>一个好的 Go 语言包应该具有低程度的源码级耦合，这样，随着项目的增长，对一个包的更改不会跨代码库级联。 这些世界末日的重构严格限制了代码库的变化率以及在该代码库中工作的成员的生产率。</p>
<p>在本节中，我们将讨论如何设计包，包括包的名称，命名类型以及编写方法和函数的技巧。</p>
<h4 id="4-1-一个好的包从它的名字开始"><a href="#4-1-一个好的包从它的名字开始" class="headerlink" title="4.1. 一个好的包从它的名字开始"></a>4.1. 一个好的包从它的名字开始</h4><p>编写一个好的 Go 语言包从包的名称开始。将你的包名用一个词来描述它。</p>
<p>正如我在上一节中谈到变量的名称一样，包的名称也非常重要。我遵循的经验法则不是“我应该在这个包中放入什么类型的？”。相反，我要问是“该包提供的服务是什么？”通常这个问题的答案不是“这个包提供 <code>X</code> 类型”，而是“这个包提供 <code>HTTP</code>”。</p>
<blockquote>
<p>贴士:<br>以包所提供的内容来命名，而不是它包含的内容。</p>
</blockquote>
<h4 id="4-1-1-好的包名应该是唯一的。"><a href="#4-1-1-好的包名应该是唯一的。" class="headerlink" title="4.1.1. 好的包名应该是唯一的。"></a>4.1.1. 好的包名应该是唯一的。</h4><p>在项目中，每个包名称应该是唯一的。包的名称应该描述其目的的建议很容易理解 - 如果你发现有两个包需要用相同名称，它可能是:</p>
<ol>
<li>包的名称太通用了。</li>
<li>该包与另一个类似名称的包重叠了。在这种情况下，您应该检查你的设计，或考虑合并包。</li>
</ol>
<h4 id="4-2-避免使用类似-base，common-或-util-的包名称"><a href="#4-2-避免使用类似-base，common-或-util-的包名称" class="headerlink" title="4.2. 避免使用类似 base，common 或 util 的包名称"></a>4.2. 避免使用类似 <code>base</code>，<code>common</code> 或 <code>util</code> 的包名称</h4><p>不好的包名的常见情况是 <code>utility</code> 包。这些包通常是随着时间的推移一些帮助程序和工具类的包。由于这些包包含各种不相关的功能，因此很难根据包提供的内容来描述它们。这通常会导致包的名称来自包含的内容 - <code>utilities</code>。</p>
<p>像 <code>utils</code> 或 <code>helper</code> 这样的包名称通常出现在较大的项目中，这些项目已经开发了深层次包的结构，并且希望在不遇到导入循环的情况下共享 <code>helper</code> 函数。通过将 <code>utility </code> 程序函数提取到新的包中，导入循环会被破坏，但由于该包源于项目中的设计问题，因此其包名称不反映其目的，仅反映其为了打破导入循环。</p>
<p>我建议改进 <code>utils</code> 或 <code>helpers</code> 包的名称是分析它们的调用位置，如果可能的话，将相关的函数移动到调用者的包中。即使这涉及复制一些 <code>helper</code> 程序代码，这也比在两个程序包之间引入导入依赖项更好。</p>
<blockquote>
<p>[A little] duplication is far cheaper than the wrong abstraction.<br>([一点点]重复比错误的抽象的性价比高很多。)<br> — Sandy Metz</p>
</blockquote>
<p>在使用 <code>utility</code> 程序的情况下，最好选多个包，每个包专注于单个方面，而不是选单一的整体包。</p>
<blockquote>
<p>贴士:<br>使用复数形式命名 <code>utility</code> 包。例如 <code>strings</code> 来处理字符串。</p>
</blockquote>
<p>当两个或多个实现共有的功能或客户端和服务器的常见类型被重构为单独的包时，通常会找到名称类似于 <code>base</code> 或 <code>common</code> 的包。我相信解决方案是减少包的数量，将客户端，服务器和公共代码组合到一个以包的功能命名的包中。</p>
<p>例如，<code>net/http</code> 包没有 <code>client</code> 和 <code>server</code> 的分包，而是有一个 <code>client.go</code> 和 <code>server.go</code> 文件，每个文件都有各自的类型，还有一个 <code>transport.go</code> 文件，用于公共消息传输代码。</p>
<blockquote>
<p>贴士:<br><strong>标识符的名称包括其包名称。</strong><br>重要的是标识符的名称包括其包的名称。</p>
<ul>
<li>当由另一个包引用时，<code>net/http</code> 包中的 Get 函数变为 <code>http.Get</code>。</li>
<li>当导入到其他包中时，<code>strings</code> 包中的 <code>Reader</code> 类型变为 <code>strings.Reader</code>。</li>
<li><code>net</code> 包中的 <code>Error</code> 接口显然与网络错误有关。</li>
</ul>
</blockquote>
<h4 id="4-3-尽早-return-而不是深度嵌套"><a href="#4-3-尽早-return-而不是深度嵌套" class="headerlink" title="4.3. 尽早 return 而不是深度嵌套"></a>4.3. 尽早 <code>return</code> 而不是深度嵌套</h4><p>由于 Go 语言的控制流不使用 <code>exception</code>，因此不需要为 <code>try</code> 和 <code>catch</code> 块提供顶级结构而深度缩进代码。Go 语言代码不是成功的路径越来越深地嵌套到右边，而是以一种风格编写，其中随着函数的进行，成功路径继续沿着屏幕向下移动。 我的朋友 Mat Ryer 将这种做法称为“视线”编码。<a target="_blank" rel="noopener" href="https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88">[4]</a></p>
<p>这是通过使用 <code>guard clauses</code> 来实现的; 在进入函数时是具有断言前提条件的条件块。 这是一个来自 <code>bytes</code> 包的例子:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">UnreadRune</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b.lastRead &lt;= opInvalid &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b.off &gt;= <span class="keyword">int</span>(b.lastRead) &#123;</span><br><span class="line">		b.off -= <span class="keyword">int</span>(b.lastRead)</span><br><span class="line">	&#125;</span><br><span class="line">	b.lastRead = opInvalid</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 <code>UnreadRune</code> 后，将检查 <code>b.lastRead</code> 的状态，如果之前的操作不是 <code>ReadRune</code>，则会立即返回错误。 之后，函数的其余部分继续进行 <code>b.lastRead</code> 大于 <code>opInvalid</code> 的断言。</p>
<p>与没有 <code>guard clause</code> 的相同函数进行比较，</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">UnreadRune</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b.lastRead &gt; opInvalid &#123;</span><br><span class="line">		<span class="keyword">if</span> b.off &gt;= <span class="keyword">int</span>(b.lastRead) &#123;</span><br><span class="line">			b.off -= <span class="keyword">int</span>(b.lastRead)</span><br><span class="line">		&#125;</span><br><span class="line">		b.lastRead = opInvalid</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> errors.New(<span class="string">&quot;bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最常见的执行成功的情况是嵌套在第一个if条件内，成功的退出条件是 <code>return nil</code>，而且必须通过仔细匹配大括号来发现。 函数的最后一行是返回一个错误，并且被调用者必须追溯到匹配的左括号，以了解何时执行到此点。</p>
<p>对于读者和维护程序员来说，这更容易出错，因此 Go 语言更喜欢使用 <code>guard clauses</code> 并尽早返回错误。</p>
<h4 id="4-4-让零值更有用"><a href="#4-4-让零值更有用" class="headerlink" title="4.4. 让零值更有用"></a>4.4. 让零值更有用</h4><p>假设变量没有初始化，每个变量声明都会自动初始化为与零内存的内容相匹配的值。 这就是零值。 值的类型决定了其零值; 对于数字类型，它为 <code>0</code>，对于指针类型为 <code>nil</code>，<code>slices</code>、<code>map</code> 和 <code>channel</code> 同样是 <code>nil</code>。</p>
<p>始终设置变量为已知默认值的属性对于程序的安全性和正确性非常重要，并且可以使 Go 语言程序更简单、更紧凑。 这就是 Go 程序员所说的“给你的结构一个有用的零值”。</p>
<p>对于 <code>sync.Mutex</code> 类型。<code>sync.Mutex</code> 包含两个未公开的整数字段，它们用来表示互斥锁的内部状态。 每当声明 <code>sync.Mutex</code> 时，其字段会被设置为 <code>0</code> 初始值。<code>sync.Mutex</code> 利用此属性来编写，使该类型可直接使用而无需初始化。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu  sync.Mutex</span><br><span class="line">	val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i MyInt</span><br><span class="line"></span><br><span class="line">	<span class="comment">// i.mu is usable without explicit initialisation.</span></span><br><span class="line">	i.mu.Lock()</span><br><span class="line">	i.val++</span><br><span class="line">	i.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个利用零值的类型是 <code>bytes.Buffer</code>。您可以声明 <code>bytes.Buffer</code> 然后就直接写入而无需初始化。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">	b.WriteString(<span class="string">&quot;Hello, world!\n&quot;</span>)</span><br><span class="line">	io.Copy(os.Stdout, &amp;b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切片的一个有用属性是它们的零值 <code>nil</code>。如果我们看一下切片运行时 <code>header</code> 的定义就不难理解:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">        array *[...]T <span class="comment">// pointer to the underlying array</span></span><br><span class="line">        <span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">        <span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此结构的零值意味着 <code>len</code> 和 <code>cap</code> 的值为 <code>0</code>，而 <code>array</code>（指向保存切片的内容数组的指针）将为 <code>nil</code>。这意味着你不需要 <code>make</code> 切片，你只需声明它即可。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// s := make([]string, 0)</span></span><br><span class="line">	<span class="comment">// s := []string&#123;&#125;</span></span><br><span class="line">	<span class="keyword">var</span> s []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">	fmt.Println(strings.Join(s, <span class="string">&quot; &quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:<br><code>var s []string</code> 类似于它上面的两条注释行，但并不完全相同。值为 <code>nil</code> 的切片与具有零长度的切片就可以来相互比较。以下代码将输出 <code>false</code>。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s1 = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> s2 []<span class="keyword">string</span></span><br><span class="line">	fmt.Println(reflect.DeepEqual(s1, s2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nil pointers</code> – 未初始化的指针变量的一个有用属性是你可以在具有 <code>nil</code> 值的类型上调用方法。它可以简单地用于提供默认值。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	path <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Config)</span> <span class="title">Path</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;/usr/home&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.path</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c1 *Config</span><br><span class="line">	<span class="keyword">var</span> c2 = &amp;Config&#123;</span><br><span class="line">		path: <span class="string">&quot;/export&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(c1.Path(), c2.Path())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-避免包级别状态"><a href="#4-5-避免包级别状态" class="headerlink" title="4.5. 避免包级别状态"></a>4.5. 避免包级别状态</h4><p>编写可维护程序的关键是它们应该是松散耦合的 - 对一个程序包的更改应该很少影响另一个不直接依赖于第一个程序包的程序包。</p>
<p>在 Go 语言中有两种很好的方法可以实现松散耦合</p>
<ol>
<li>使用接口来描述函数或方法所需的行为。</li>
<li>避免使用全局状态。</li>
</ol>
<p>在 Go 语言中，我们可以在函数或方法范围以及包范围内声明变量。当变量是公共的时，给定一个以大写字母开头的标识符，那么它的范围对于整个程序来说实际上是全局的 - 任何包都可以随时观察该变量的类型和内容。</p>
<p>可变全局状态引入程序的独立部分之间的紧密耦合，因为全局变量成为程序中每个函数的不可见参数！如果该变量的类型发生更改，则可以破坏依赖于全局变量的任何函数。如果程序的另一部分更改了该变量，则可以破坏依赖于全局变量状态的任何函数。</p>
<p>如果要减少全局变量所带来的耦合，</p>
<ol>
<li>将相关变量作为字段移动到需要它们的结构上。</li>
<li>使用接口来减少行为与实现之间的耦合。</li>
</ol>
<h3 id="5-项目结构"><a href="#5-项目结构" class="headerlink" title="5. 项目结构"></a>5. 项目结构</h3><p>我们来谈谈如何将包组合到项目中。 通常一个项目是一个 <code>git</code> 仓库，但在未来 Go 语言开发人员会交替地使用 <code>module</code> 和 <code>project</code>。</p>
<p>就像一个包，每个项目都应该有一个明确的目的。 如果你的项目是一个库，它应该提供一件事，比如 <code>XML</code> 解析或记录。 您应该避免在一个包实现多个目的，这将有助于避免成为 <code>common</code> 库。</p>
<blockquote>
<p>贴士:<br>据我的经验，<code>common</code> 库最终会与其最大的调用者紧密相连，在没有升级该库与最大调用者的情况下是很难修复的，还会带来了许多无关的更改以及API破坏。</p>
</blockquote>
<p>如果你的项目是应用程序，如 <code>Web</code> 应用程序，<code>Kubernetes</code> 控制器等，那么项目中可能有一个或多个 <code>main</code> 程序包。 例如，我编写的 <code>Kubernetes</code> 控制器有一个 <code>cmd/contour</code> 包，既可以作为部署到 <code>Kubernetes</code> 集群的服务器，也可以作为调试目的的客户端。</p>
<h4 id="5-1-考虑更少，更大的包"><a href="#5-1-考虑更少，更大的包" class="headerlink" title="5.1. 考虑更少，更大的包"></a>5.1. 考虑更少，更大的包</h4><p>对于从其他语言过渡到 Go 语言的程序员来说，我倾向于在代码审查中提到的一件事是他们会过度使用包。</p>
<p>Go 语言没有提供有关可见性的详细方法; Java有 <code>public</code>、<code>protected</code>、<code>private</code> 以及隐式 <code>default</code> 的访问修饰符。 没有 <code>C++</code> 的 <code>friend</code> 类概念。</p>
<p>在 Go 语言中，我们只有两个访问修饰符，<code>public</code> 和 <code>private</code>，由标识符的第一个字母的大小写表示。 如果标识符是公共的，则其名称以大写字母开头，该标识符可用于任何其他 Go 语言包的引用。</p>
<blockquote>
<p>注意:<br>你可能会听到人们说 <code>exported</code> 与 <code>not exported</code>, 跟 <code>public</code> 和 <code>private</code> 是同义词。</p>
</blockquote>
<p>鉴于包的符号的访问有限控件，Go 程序员应遵循哪些实践来避免创建过于复杂的包层次结构？</p>
<blockquote>
<p>贴士:<br>除 <code>cmd/</code> 和 <code>internal/</code> 之外的每个包都应包含一些源代码。</p>
</blockquote>
<p>我的建议是选择更少，更大的包。 你应该做的是不创建新的程序包。 这将导致太多类型被公开，为你的包创建一个宽而浅的API。</p>
<p>以下部分将更为详细地探讨这一建议。</p>
<blockquote>
<p>贴士:<br>来自 <code>Java</code>？<br>如果您来自 <code>Java</code> 或 <code>C#</code>，请考虑这一经验法则 – <code>Java</code> 包相当于单个 <code>.go</code> 源文件。 - Go 语言包相当于整个 <code>Maven</code> 模块或 <code>.NET</code> 程序集。</p>
</blockquote>
<h4 id="5-1-1-通过-import-语句将代码排列到文件中"><a href="#5-1-1-通过-import-语句将代码排列到文件中" class="headerlink" title="5.1.1. 通过 import 语句将代码排列到文件中"></a>5.1.1. 通过 <code>import</code> 语句将代码排列到文件中</h4><p>如果你按照包提供的内容来安排你的程序包，是否需要对 Go 包中的文件也执行相同的操作？什么时候应该将 <code>.go</code> 文件拆分成多个文件？什么时候应该考虑整合 <code>.go</code> 文件？</p>
<p>以下是我的经验法则：</p>
<ul>
<li>开始时使用一个 <code>.go</code> 文件。为该文件指定与文件夹名称相同的名称。例如: <code>package http</code> 应放在名为 <code>http</code> 的目录中名为 <code>http.go</code> 的文件中。</li>
<li>随着包的增长，您可能决定将各种职责任务拆分为不同的文件。例如：<code>messages.go</code> 包含 <code>Request</code> 和 <code>Response</code> 类型，<code>client.go</code> 包含 <code>Client</code> 类型，<code>server.go</code>包含 <code>Server</code> 类型。</li>
<li>如果你的文件中 <code>import</code> 的声明类似，请考虑将它们组合起来。或者确定 <code>import</code> 集之间的差异并移动它们。</li>
<li>不同的文件应该负责包的不同区域。<code>messages.go</code> 可能负责网络的 <code>HTTP</code> 请求和响应，<code>http.go</code> 可能包含底层网络处理逻辑，<code>client.go</code> 和 <code>server.go</code> 实现 <code>HTTP</code> 业务逻辑请求的实现或路由等等。</li>
</ul>
<blockquote>
<p>贴士: 首选名词为源文件命名。</p>
</blockquote>
<blockquote>
<p>注意:<br>Go编译器并行编译每个包。 在一个包中，编译器并行编译每个函数（方法只是 Go 语言中函数的另一种写法）。 更改包中代码的布局不会影响编译时间。</p>
</blockquote>
<h4 id="5-1-2-优先内部测试再到外部测试"><a href="#5-1-2-优先内部测试再到外部测试" class="headerlink" title="5.1.2. 优先内部测试再到外部测试"></a>5.1.2. 优先内部测试再到外部测试</h4><p><code>go tool</code> 支持在两个地方编写 <code>testing</code> 包测试。假设你的包名为 <code>http2</code>，您可以编写 <code>http2_test.go</code> 文件并使用包 <code>http2</code> 声明。这样做会编译 <code>http2_test.go</code> 中的代码，就像它是 <code>http2</code> 包的一部分一样。这就是内部测试。</p>
<p><code>go tool</code> 还支持一个特殊的包声明，以 <code>test</code> 为结尾，即 <code>package http_test</code>。这允许你的测试文件与代码一起存放在同一个包中，但是当编译时这些测试不是包的代码的一部分，它们存在于自己的包中。就像调用另一个包的代码一样来编写测试。这被称为外部测试。</p>
<p>我建议在编写单元测试时使用内部测试。这样你就可以直接测试每个函数或方法，避免外部测试干扰。</p>
<p>但是，你应该将 <code>Example</code> 测试函数放在外部测试文件中。这确保了在 <code>godoc</code> 中查看时，示例具有适当的包名前缀并且可以轻松地进行复制粘贴。</p>
<blockquote>
<p>贴士:<br><code>避免复杂的包层次结构，抵制应用分类法</code><br>Go 语言包的层次结构对于 <code>go tool</code> 没有任何意义除了下一节要说的。 例如，<code>net/http</code> 包不是一个子包或者 <code>net</code> 包的子包。</p>
<p>如果在项目中创建了不包含 <code>.go</code> 文件的中间目录，则可能无法遵循此建议。</p>
</blockquote>
<h4 id="5-1-3-使用-internal-包来减少公共API"><a href="#5-1-3-使用-internal-包来减少公共API" class="headerlink" title="5.1.3. 使用 internal 包来减少公共API"></a>5.1.3. 使用 <code>internal</code> 包来减少公共API</h4><p>如果项目包含多个包，可能有一些公共的函数，这些函数旨在供项目中的其他包使用，但不打算成为项目的公共API的一部分。 如果你发现是这种情况，那么 <code>go tool</code> 会识别一个特殊的文件夹名称 - 而非包名称 - <code>internal/</code> 可用于放置对项目公开的代码，但对其他项目是私有的。</p>
<p>要创建此类包，请将其放在名为 <code>internal/</code> 的目录中，或者放在名为 <code>internal/</code> 的目录的子目录中。 当 <code>go</code> 命令在其路径中看到导入包含 <code>internal</code> 的包时，它会验证执行导入的包是否位于 <code>internal</code> 目录。</p>
<p>例如，<code>.../a/b/c/internal/d/e/f</code> 的包只能通过以 <code>.../a/b/c/</code> 为根目录的代码被导入。 它无法通过 <code>.../a/b/g</code> 或任何其他仓库中的代码导入。<a target="_blank" rel="noopener" href="https://golang.org/doc/go1.4#internalpackages">[5]</a></p>
<h4 id="5-2-确保-main-包内容尽可能的少"><a href="#5-2-确保-main-包内容尽可能的少" class="headerlink" title="5.2. 确保 main 包内容尽可能的少"></a>5.2. 确保 <code>main</code> 包内容尽可能的少</h4><p><code>main</code> 函数和 <code>main</code> 包的内容应尽可能少。 这是因为 <code>main.main</code> 充当单例; 程序中只能有一个 <code>main</code> 函数，包括 <code>tests</code>。</p>
<p>因为 <code>main.main</code> 是一个单例，假设 <code>main</code> 函数中需要执行很多事情,<code>main.main</code> 只会在 <code>main.main</code> 或 <code>main.init</code> 中调用它们并且只调用一次。 这使得为 <code>main.main</code> 编写代码测试变得很困难，因此你应该将所有业务逻辑从 <code>main</code> 函数中移出，最好是从 <code>main</code> 包中移出。</p>
<blockquote>
<p>贴士:<br><code>main</code> 应该做解析 <code>flags</code>，开启数据库连接、开启日志等，然后将执行交给更高一级的对象。</p>
</blockquote>
<h3 id="6-API-设计"><a href="#6-API-设计" class="headerlink" title="6. API 设计"></a>6. API 设计</h3><p>我今天要给出的最后一条建议是设计, 我认为也是最重要的。</p>
<p>到目前为止我提出的所有建议都是建议。 这些是我尝试编写 Go 语言的方式，但我不打算在代码审查中拼命推广。</p>
<p>但是，在审查 API 时, 我就不会那么宽容了。 这是因为到目前为止我所谈论的所有内容都是可以修复而且不会破坏向后兼容性; 它们在很大程度上是实现的细节。</p>
<p>当涉及到软件包的公共 API 时，在初始设计中投入大量精力是值得的，因为稍后更改该设计对于已经使用 API 的人来说会是破坏性的。</p>
<h4 id="6-1-设计难以被误用的-API"><a href="#6-1-设计难以被误用的-API" class="headerlink" title="6.1. 设计难以被误用的 API"></a>6.1. 设计难以被误用的 API</h4><blockquote>
<p>APIs should be easy to use and hard to misuse.<br>(API 应该易于使用且难以被误用)<br> — Josh Bloch <a target="_blank" rel="noopener" href="https://www.infoq.com/articles/API-Design-Joshua-Bloch">[3]</a></p>
</blockquote>
<p>如果你从这个演讲中带走任何东西，那应该是 Josh Bloch 的建议。 如果一个 API 很难用于简单的事情，那么 API 的每次调用都会很复杂。 当 API 的实际调用很复杂时，它就会便得不那么明显，而且会更容易被忽视。</p>
<h4 id="6-1-1-警惕采用几个相同类型参数的函数"><a href="#6-1-1-警惕采用几个相同类型参数的函数" class="headerlink" title="6.1.1. 警惕采用几个相同类型参数的函数"></a>6.1.1. 警惕采用几个相同类型参数的函数</h4><p>简单, 但难以正确使用的 API 是采用两个或更多相同类型参数的 API。 让我们比较两个函数签名：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(to, from <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>这两个函数有什么区别？ 显然，一个返回两个数字最大的那个，另一个是复制文件，但这不重要。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Max(<span class="number">8</span>, <span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line">Max(<span class="number">10</span>, <span class="number">8</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p><code>Max</code> 是可交换的; 参数的顺序无关紧要。 无论是 8 比 10 还是 10 比 8，最大的都是 10。</p>
<p>但是，却不适用于 <code>CopyFile</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyFile(<span class="string">&quot;/tmp/backup&quot;</span>, <span class="string">&quot;presentation.md&quot;</span>)</span><br><span class="line">CopyFile(<span class="string">&quot;presentation.md&quot;</span>, <span class="string">&quot;/tmp/backup&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这些声明中哪一个备份了 <code>presentation.md</code>，哪一个用上周的版本覆盖了 <code>presentation.md</code>？ 没有文档，你无法分辨。 如果没有查阅文档，代码审查员也无法知道你写对了顺序。</p>
<p>一种可能的解决方案是引入一个 <code>helper</code> 类型，它会负责如何正确地调用 <code>CopyFile</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Source <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(src Source)</span> <span class="title">CopyTo</span><span class="params">(dest <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> CopyFile(dest, <span class="keyword">string</span>(src))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> from Source = <span class="string">&quot;presentation.md&quot;</span></span><br><span class="line">	from.CopyTo(<span class="string">&quot;/tmp/backup&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，<code>CopyFile</code> 总是能被正确调用 - 还可以通过单元测试 - 并且可以被设置为私有，进一步降低了误用的可能性。</p>
<blockquote>
<p>贴士: 具有多个相同类型参数的API难以正确使用。</p>
</blockquote>
<h4 id="6-2-为其默认用例设计-API"><a href="#6-2-为其默认用例设计-API" class="headerlink" title="6.2. 为其默认用例设计 API"></a>6.2. 为其默认用例设计 API</h4><p>几年前，我就对 <code>functional options</code><a target="_blank" rel="noopener" href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">[7]</a> 进行过讨论<a target="_blank" rel="noopener" href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">[6]</a>，使 API 更易用于默认用例。</p>
<p>本演讲的主旨是你应该为常见用例设计 API。 另一方面， API 不应要求调用者提供他们不在乎参数。</p>
<h4 id="6-2-1-不鼓励使用-nil-作为参数"><a href="#6-2-1-不鼓励使用-nil-作为参数" class="headerlink" title="6.2.1. 不鼓励使用 nil 作为参数"></a>6.2.1. 不鼓励使用 <code>nil</code> 作为参数</h4><p>本章开始时我建议是不要强迫提供给 API 的调用者他们不在乎的参数。 这就是我要说的为默认用例设计 API。</p>
<p>这是 <code>net/http</code> 包中的一个例子</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListenAndServe listens on the TCP network address addr and then calls</span></span><br><span class="line"><span class="comment">// Serve with handler to handle requests on incoming connections.</span></span><br><span class="line"><span class="comment">// Accepted connections are configured to enable TCP keep-alives.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The handler is typically nil, in which case the DefaultServeMux is used.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br></pre></td></tr></table></figure>
<p><code>ListenAndServe</code> 有两个参数，一个用于监听传入连接的 <code>TCP</code> 地址，另一个用于处理 <code>HTTP</code> 请求的 <code>http.Handler</code>。<code>Serve</code> 允许第二个参数为 <code>nil</code>，需要注意的是调用者通常会传递 <code>nil</code>，表示他们想要使用 <code>http.DefaultServeMux</code> 作为隐含参数。</p>
<p>现在，<code>Serve</code> 的调用者有两种方式可以做同样的事情。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, http.DefaultServeMux)</span><br></pre></td></tr></table></figure>
<p>两者完全相同。</p>
<p>这种 <code>nil</code> 行为是病毒式的。 <code>http</code> 包也有一个 <code>http.Serve</code> 帮助类，你可以合理地想象一下 <code>ListenAndServe</code> 是这样构建的</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	l, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> l.Close()</span><br><span class="line">	<span class="keyword">return</span> Serve(l, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>ListenAndServe</code> 允许调用者为第二个参数传递 <code>nil</code>，所以 <code>http.Serve</code> 也支持这种行为。 事实上，<code>http.Serve</code> 实现了如果 <code>handler</code> 是<code>nil</code>，使用 <code>DefaultServeMux</code> 的逻辑。 参数可为 <code>nil</code> 可能会导致调用者认为他们可以为两个参数都使用 <code>nil</code>。 像下面这样:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.Serve(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>会导致 <code>panic</code>。</p>
<blockquote>
<p>贴士:<br>不要在同一个函数签名中混合使用可为 <code>nil</code> 和不能为 <code>nil</code> 的参数。</p>
</blockquote>
<p><code>http.ListenAndServe</code> 的作者试图在常见情况下让使用 API 的用户更轻松些，但很可能会让该程序包更难以被安全地使用。</p>
<p>使用 <code>DefaultServeMux</code> 或使用 <code>nil</code> 没有什么区别。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = http.Dir(<span class="string">&quot;/htdocs&quot;</span>)</span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>对比</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = http.Dir(<span class="string">&quot;/htdocs&quot;</span>)</span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, http.DefaultServeMux)</span><br></pre></td></tr></table></figure>
<p>这种混乱值得拯救吗？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = http.Dir(<span class="string">&quot;/htdocs&quot;</span>)</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, mux)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>贴士: 认真考虑 <code>helper</code> 函数会节省不少时间。 清晰要比简洁好。</p>
</blockquote>
<blockquote>
<p>贴士:<br><code>避免公共 API 使用测试参数</code><br>避免在公开的 API 上使用仅在测试范围上不同的值。 相反，使用 <code>Public wrappers</code> 隐藏这些参数，使用辅助方式来设置测试范围中的属性。</p>
</blockquote>
<h4 id="6-2-2-首选可变参数函数而非-T-参数"><a href="#6-2-2-首选可变参数函数而非-T-参数" class="headerlink" title="6.2.2. 首选可变参数函数而非 []T 参数"></a>6.2.2. 首选可变参数函数而非 <code>[]T</code> 参数</h4><p>编写一个带有切片参数的函数或方法是很常见的。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShutdownVMs</span><span class="params">(ids []<span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>这只是我编的一个例子，但它与我所写的很多代码相同。 这里的问题是他们假设他们会被调用于多个条目。 但是很多时候这些类型的函数只用一个参数调用，为了满足函数参数的要求，它必须打包到一个切片内。</p>
<p>另外，因为 <code>ids</code> 参数是切片，所以你可以将一个空切片或 <code>nil</code> 传递给该函数，编译也没什么错误。 但是这会增加额外的测试负载，因为你应该涵盖这些情况在测试中。</p>
<p>举一个这类 API 的例子，最近我重构了一条逻辑，要求我设置一些额外的字段，如果一组参数中至少有一个非零。 逻辑看起来像这样：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> svc.MaxConnections &gt; <span class="number">0</span> || svc.MaxPendingRequests &gt; <span class="number">0</span> || svc.MaxRequests &gt; <span class="number">0</span> || svc.MaxRetries &gt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// apply the non zero parameters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <code>if</code> 语句变得很长，我想将签出的逻辑拉入其自己的函数中。 这就是我提出的：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// anyPostive indicates if any value is greater than zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyPositive</span><span class="params">(values ...<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就能够向读者明确内部块的执行条件：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) &#123;</span><br><span class="line">        <span class="comment">// apply the non zero parameters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是 <code>anyPositive</code> 还存在一个问题，有人可能会这样调用它:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> anyPositive() &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，<code>anyPositive</code> 将返回 <code>false</code>，因为它不会执行迭代而是立即返回 <code>false</code>。对比起如果 <code>anyPositive</code> 在没有传递参数时返回 <code>true</code>, 这还不算世界上最糟糕的事情。</p>
<p>然而，如果我们可以更改 <code>anyPositive</code> 的签名以强制调用者应该传递至少一个参数，那会更好。我们可以通过组合正常和可变参数来做到这一点，如下所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// anyPostive indicates if any value is greater than zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyPositive</span><span class="params">(first <span class="keyword">int</span>, rest ...<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> first &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> rest &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在不能使用少于一个参数来调用 <code>anyPositive</code>。</p>
<h4 id="6-3-让函数定义它们所需的行为"><a href="#6-3-让函数定义它们所需的行为" class="headerlink" title="6.3. 让函数定义它们所需的行为"></a>6.3. 让函数定义它们所需的行为</h4><p>假设我需要编写一个将 <code>Document</code> 结构保存到磁盘的函数的任务。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the file f.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(f *os.File, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>我可以指定这个函数 <code>Save</code>，它将 <code>*os.File</code> 作为写入 <code>Document</code> 的目标。但这样做会有一些问题</p>
<p><code>Save</code> 的签名排除了将数据写入网络位置的选项。假设网络存储可能在以后成为需求，则此功能的签名必须改变，从而影响其所有调用者。</p>
<p><code>Save</code> 测试起来也很麻烦，因为它直接操作磁盘上的文件。因此，为了验证其操作，测试时必须在写入文件后再读取该文件的内容。</p>
<p>而且我必须确保 <code>f</code> 被写入临时位置并且随后要将其删除。</p>
<p><code>*os.File</code> 还定义了许多与 <code>Save</code> 无关的方法，比如读取目录并检查路径是否是符号链接。 如果 <code>Save</code> 函数的签名只用 <code>*os.File</code> 的相关内容，那将会很有用。</p>
<p>我们能做什么 ？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the supplied</span></span><br><span class="line"><span class="comment">// ReadWriterCloser.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(rwc io.ReadWriteCloser, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>使用 <code>io.ReadWriteCloser</code>，我们可以应用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99">接口隔离原则</a>来重新定义 <code>Save</code> 以获取更通用文件形式。</p>
<p>通过此更改，任何实现 <code>io.ReadWriteCloser</code> 接口的类型都可以替换以前的 <code>*os.File</code>。</p>
<p>这使 <code>Save</code> 在其应用程序中更广泛，并向 <code>Save</code> 的调用者阐明 <code>*os.File</code> 类型的哪些方法与其操作有关。</p>
<p>而且，<code>Save</code> 的作者也不可以在 <code>*os.File</code> 上调用那些不相关的方法，因为它隐藏在 <code>io.ReadWriteCloser</code> 接口后面。</p>
<p>但我们可以进一步采用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99">接口隔离原则</a>。</p>
<p>首先，如果 <code>Save</code> 遵循<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99">单一功能原则</a>，它不可能读取它刚刚写入的文件来验证其内容 - 这应该是另一段代码的功能。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the supplied</span></span><br><span class="line"><span class="comment">// WriteCloser.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(wc io.WriteCloser, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>因此，我们可以将我们传递给 <code>Save</code> 的接口的规范缩小到只写和关闭。</p>
<p>其次，通过向 <code>Save</code> 提供一个关闭其流的机制，使其看起来仍然像一个文件，这就提出了在什么情况下关闭 <code>wc</code> 的问题。</p>
<p>可能 <code>Save</code> 会无条件地调用 <code>Close</code>，或者在成功的情况下调用 <code>Close</code>。</p>
<p>这给 <code>Save</code> 的调用者带来了问题，因为它可能希望在写入文档后将其他数据写入流。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the supplied</span></span><br><span class="line"><span class="comment">// Writer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(w io.Writer, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>一个更好的解决方案是重新定义 <code>Save</code> 仅使用 <code>io.Writer</code>，它只负责将数据写入流。</p>
<p>将<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99">接口隔离原则</a>应用于我们的 <code>Save</code> 功能，同时, 就需求而言, 得出了最具体的一个函数 - 它只需要一个可写的东西 - 并且它的功能最通用，现在我们可以使用 <code>Save</code> 将我们的数据保存到实现 <code>io.Writer</code> 的任何事物中。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0aebd9618300">[译注: 不理解设计原则部分的同学可以阅读 Dave 大神的另一篇《Go 语言 SOLID 设计》]</a></p>
<h3 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a>7. 错误处理</h3><p>我已经给出了几个关于错误处理的演示文稿<a target="_blank" rel="noopener" href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">[8]</a>，并在我的博客上写了很多关于错误处理的文章。我在昨天的会议上也讲了很多关于错误处理的内容，所以在这里不再赘述。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dave.cheney.net/2014/12/24/inspecting-errors">https://dave.cheney.net/2014/12/24/inspecting-errors</a></li>
<li><a target="_blank" rel="noopener" href="https://dave.cheney.net/2016/04/07/constant-errors">https://dave.cheney.net/2016/04/07/constant-errors</a></li>
</ul>
<p>相反，我想介绍与错误处理相关的两个其他方面。</p>
<h4 id="7-1-通过消除错误来消除错误处理"><a href="#7-1-通过消除错误来消除错误处理" class="headerlink" title="7.1. 通过消除错误来消除错误处理"></a>7.1. 通过消除错误来消除错误处理</h4><p>如果你昨天在我的演讲中，我谈到了改进错误处理的提案。但是你知道有什么比改进错误处理的语法更好吗？那就是根本不需要处理错误。</p>
<blockquote>
<p>注意:<br>我不是说“删除你的错误处理”。我的建议是，修改你的代码，这样就不用处理错误了。</p>
</blockquote>
<p>本节从 John Ousterhout 最近的著作“软件设计哲学”<a target="_blank" rel="noopener" href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201">[9]</a>中汲取灵感。该书的其中一章是“定义不存在的错误”。我们将尝试将此建议应用于 Go 语言。</p>
<h4 id="7-1-1-计算行数"><a href="#7-1-1-计算行数" class="headerlink" title="7.1.1. 计算行数"></a>7.1.1. 计算行数</h4><p>让我们编写一个函数来计算文件中的行数。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines</span><span class="params">(r io.Reader)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		br    = bufio.NewReader(r)</span><br><span class="line">		lines <span class="keyword">int</span></span><br><span class="line">		err   error</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_, err = br.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		lines++</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lines, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们遵循前面部分的建议，<code>CountLines</code> 需要一个 <code>io.Reader</code>，而不是一个 <code>*File</code>；它的任务是调用者为我们想要计算的内容提供 <code>io.Reader</code>。</p>
<p>我们构造一个 <code>bufio.Reader</code>，然后在一个循环中调用 <code>ReadString</code> 方法，递增计数器直到我们到达文件的末尾，然后我们返回读取的行数。</p>
<p>至少这是我们想要编写的代码，但是这个函数由于需要错误处理而变得更加复杂。 例如，有这样一个奇怪的结构:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, err = br.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">lines++</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在检查错误之前增加了行数，这样做看起来很奇怪。</p>
<p>我们必须以这种方式编写它的原因是，如果在遇到换行符之前就读到文件结束，则 <code>ReadString</code> 将返回错误。如果文件中没有换行符，同样会出现这种情况。</p>
<p>为了解决这个问题，我们重新排列逻辑增来加行数，然后查看是否需要退出循环。</p>
<blockquote>
<p>注意:<br>这个逻辑仍然不完美，你能发现错误吗？</p>
</blockquote>
<p>但是我们还没有完成检查错误。当 <code>ReadString</code> 到达文件末尾时，预期它会返回 <code>io.EOF</code>。<code>ReadString</code> 需要某种方式在没有什么可读时来停止。因此，在我们将错误返回给 <code>CountLine</code> 的调用者之前，我们需要检查错误是否是 <code>io.EOF</code>，如果不是将其错误返回，否则我们返回 <code>nil</code> 说一切正常。</p>
<p>我认为这是 Russ Cox 观察到错误处理可能会模​​糊函数操作的一个很好的例子。我们来看一个改进的版本。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines</span><span class="params">(r io.Reader)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	sc := bufio.NewScanner(r)</span><br><span class="line">	lines := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> sc.Scan() &#123;</span><br><span class="line">		lines++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lines, sc.Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个改进的版本从 <code>bufio.Reader</code> 切换到 <code>bufio.Scanner</code>。</p>
<p>在 <code>bufio.Scanner</code> 内部使用 <code>bufio.Reader</code>，但它添加了一个很好的抽象层，它有助于通过隐藏 <code>CountLines</code> 的操作来消除错误处理。</p>
<blockquote>
<p>注意:<br><code>bufio.Scanner</code> 可以扫描任何模式，但默认情况下它会查找换行符。</p>
</blockquote>
<p>如果扫描程序匹配了一行文本并且没有遇到错误，则 <code>sc.Scan()</code> 方法返回 <code>true</code> 。因此，只有当扫描仪的缓冲区中有一行文本时，才会调用 <code>for</code> 循环的主体。这意味着我们修改后的 <code>CountLines</code> 正确处理没有换行符的情况，并且还处理文件为空的情况。</p>
<p>其次，当 <code>sc.Scan</code> 在遇到错误时返回 <code>false</code>，我们的 <code>for</code> 循环将在到达文件结尾或遇到错误时退出。<code>bufio.Scanner</code> 类型会记住遇到的第一个错误，一旦我们使用 <code>sc.Err()</code> 方法退出循环，我们就可以获取该错误。</p>
<p>最后， <code>sc.Err()</code> 负责处理 <code>io.EOF</code> 并在达到文件末尾时将其转换为 <code>nil</code>，而不会遇到其他错误。</p>
<blockquote>
<p>贴士:<br>当遇到难以忍受的错误处理时，请尝试将某些操作提取到辅助程序类型中。</p>
</blockquote>
<h4 id="7-1-2-WriteResponse"><a href="#7-1-2-WriteResponse" class="headerlink" title="7.1.2. WriteResponse"></a>7.1.2. WriteResponse</h4><p>我的第二个例子受到了 <code>Errors are values</code> 博客文章<a target="_blank" rel="noopener" href="https://blog.golang.org/errors-are-values">[10]</a>的启发。</p>
<p>在本章前面我们已经看过处理打开、写入和关闭文件的示例。错误处理是存在的，但是接收范围内的，因为操作可以封装在诸如 <code>ioutil.ReadFile</code> 和 <code>ioutil.WriteFile</code> 之类的辅助程序中。但是，在处理底层网络协议时，有必要使用 <code>I/O</code> 原始的错误处理来直接构建响应，这样就可能会变得重复。看一下构建 <code>HTTP</code> 响应的 <code>HTTP</code> 服务器的这个片段。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key, Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code   <span class="keyword">int</span></span><br><span class="line">	Reason <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, st Status, headers []Header, body io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	_, err := fmt.Fprintf(w, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, st.Code, st.Reason)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">		_, err := fmt.Fprintf(w, <span class="string">&quot;%s: %s\r\n&quot;</span>, h.Key, h.Value)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, err := fmt.Fprint(w, <span class="string">&quot;\r\n&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = io.Copy(w, body)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们使用 <code>fmt.Fprintf</code> 构造状态码并检查错误。 然后对于每个标题，我们写入键值对，每次都检查错误。 最后，我们使用额外的 <code>\r\n</code> 终止标题部分，检查错误之后将响应主体复制到客户端。 最后，虽然我们不需要检查 <code>io.Copy</code> 中的错误，但我们需要将 <code>io.Copy</code> 返回的两个返回值形式转换为 <code>WriteResponse</code> 的单个返回值。</p>
<p>这里很多重复性的工作。 我们可以通过引入一个包装器类型 <code>errWriter</code> 来使其更容易。</p>
<p><code>errWriter</code> 实现 <code>io.Writer</code> 接口，因此可用于包装现有的 <code>io.Writer</code>。 <code>errWriter</code> 写入传递给其底层 <code>writer</code>，直到检测到错误。 从此时起，它会丢弃任何写入并返回先前的错误。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	io.Writer</span><br><span class="line">	err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errWriter)</span> <span class="title">Write</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, e.err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">	n, e.err = e.Writer.Write(buf)</span><br><span class="line">	<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, st Status, headers []Header, body io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	ew := &amp;errWriter&#123;Writer: w&#125;</span><br><span class="line">	fmt.Fprintf(ew, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, st.Code, st.Reason)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">		fmt.Fprintf(ew, <span class="string">&quot;%s: %s\r\n&quot;</span>, h.Key, h.Value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Fprint(ew, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">	io.Copy(ew, body)</span><br><span class="line">	<span class="keyword">return</span> ew.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>errWriter</code> 应用于 <code>WriteResponse</code> 可以显着提高代码的清晰度。 每个操作不再需要自己做错误检查。 通过检查 <code>ew.err</code> 字段，将错误报告移动到函数末尾，从而避免转换从 <code>io.Copy</code> 的两个返回值。</p>
<h4 id="7-2-错误只处理一次"><a href="#7-2-错误只处理一次" class="headerlink" title="7.2. 错误只处理一次"></a>7.2. 错误只处理一次</h4><p>最后，我想提一下你应该只处理错误一次。 处理错误意味着检查错误值并做出单一决定。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteAll writes the contents of buf to the supplied writer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">        w.Write(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你做出的决定少于一个，则忽略该错误。 正如我们在这里看到的那样， <code>w.WriteAll</code> 的错误被丢弃。</p>
<p>但是，针对单个错误做出多个决策也是有问题的。 以下是我经常遇到的代码。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	_, err := w.Write(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;unable to write:&quot;</span>, err) <span class="comment">// annotated error goes to log file</span></span><br><span class="line">		<span class="keyword">return</span> err                           <span class="comment">// unannotated error returned to caller</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此示例中，如果在 <code>w.Write</code> 期间发生错误，则会写入日志文件，注明错误发生的文件与行数，并且错误也会返回给调用者，调用者可能会记录该错误并将其返回到上一级，一直回到程序的顶部。</p>
<p>调用者可能正在做同样的事情</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	buf, err := json.Marshal(conf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;could not marshal config: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;could not write config: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此你在日志文件中得到一堆重复的内容，</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unable to write: io.EOF</span><br><span class="line">could not write config: io.EOF</span><br></pre></td></tr></table></figure>
<p>但在程序的顶部，虽然得到了原始错误，但没有相关内容。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err := WriteConfig(f, &amp;conf)</span><br><span class="line">fmt.Println(err) <span class="comment">// io.EOF</span></span><br></pre></td></tr></table></figure>
<p>我想深入研究这一点，因为作为个人偏好, 我并没有看到 <code>logging</code> 和返回的问题。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	buf, err := json.Marshal(conf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;could not marshal config: %v&quot;</span>, err)</span><br><span class="line">		<span class="comment">// oops, forgot to return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;could not write config: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很多问题是程序员忘记从错误中返回。正如我们之前谈到的那样，Go 语言风格是使用  <code>guard clauses</code>  以及检查前提条件作为函数进展并提前返回。</p>
<p>在这个例子中，作者检查了错误，记录了它，但忘了返回。这就引起了一个微妙的错误。</p>
<p>Go 语言中的错误处理规定，如果出现错误，你不能对其他返回值的内容做出任何假设。由于 <code>JSON</code> 解析失败，<code>buf</code> 的内容未知，可能它什么都没有，但更糟的是它可能包含解析的 <code>JSON</code> 片段部分。</p>
<p>由于程序员在检查并记录错误后忘记返回，因此损坏的缓冲区将传递给 <code>WriteAll</code>，这可能会成功，因此配置文件将被错误地写入。但是，该函数会正常返回，并且发生问题的唯一日志行是有关 <code>JSON</code> 解析错误，而与写入配置失败有关。</p>
<h4 id="7-2-1-为错误添加相关内容"><a href="#7-2-1-为错误添加相关内容" class="headerlink" title="7.2.1. 为错误添加相关内容"></a>7.2.1. 为错误添加相关内容</h4><p>发生错误的原因是作者试图在错误消息中添加 <code>context</code> 。 他们试图给自己留下一些线索，指出错误的根源。</p>
<p>让我们看看使用 <code>fmt.Errorf</code> 的另一种方式。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	buf, err := json.Marshal(conf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;could not marshal config: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;could not write config: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	_, err := w.Write(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;write failed: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将注释与返回的错误组合起来，就更难以忘记错误的返回来避免意外继续。</p>
<p>如果写入文件时发生 <code>I/O</code> 错误，则 <code>error</code> 的 <code>Error()</code> 方法会报告以下类似的内容;</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">could not write config: write failed: input/output error</span><br></pre></td></tr></table></figure>

<h4 id="7-2-2-使用-github-com-pkg-errors-包装-errors"><a href="#7-2-2-使用-github-com-pkg-errors-包装-errors" class="headerlink" title="7.2.2. 使用 github.com/pkg/errors 包装 errors"></a>7.2.2. 使用 <code>github.com/pkg/errors</code> 包装 <code>errors</code></h4><p><code>fmt.Errorf</code> 模式适用于注释错误 <code>message</code>，但这样做的代价是模糊了原始错误的类型。 我认为将错误视为不透明值对于松散耦合的软件非常重要，因此如果你使用错误值做的唯一事情是原始错误的类型应该无关紧要的面孔</p>
<ol>
<li>检查它是否为 <code>nil</code>。</li>
<li>输出或记录它。</li>
</ol>
<p>但是在某些情况下，我认为它们并不常见，您需要恢复原始错误。 在这种情况下，使用类似我的 <code>errors</code> 包来注释这样的错误, 如下</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	f, err := os.Open(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;open failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	buf, err := ioutil.ReadAll(f)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;read failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadConfig</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	home := os.Getenv(<span class="string">&quot;HOME&quot;</span>)</span><br><span class="line">	config, err := ReadFile(filepath.Join(home, <span class="string">&quot;.settings.xml&quot;</span>))</span><br><span class="line">	<span class="keyword">return</span> config, errors.WithMessage(err, <span class="string">&quot;could not read config&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_, err := ReadConfig()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在报告的错误就是 <code>K＆D</code> <a target="_blank" rel="noopener" href="http://www.gopl.io/">[11]</a>样式错误，</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</span><br></pre></td></tr></table></figure>
<p>并且错误值保留对原始原因的引用。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_, err := ReadConfig()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;original error: %T %v\n&quot;</span>, errors.Cause(err), errors.Cause(err))</span><br><span class="line">		fmt.Printf(<span class="string">&quot;stack trace:\n%+v\n&quot;</span>, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，你可以恢复原始错误并打印堆栈跟踪;</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">stack trace:</span><br><span class="line">open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">open failed</span><br><span class="line">main.ReadFile</span><br><span class="line">        /Users/dfc/devel/practical-<span class="keyword">go</span>/src/errors/readfile2.<span class="keyword">go</span>:<span class="number">16</span></span><br><span class="line">main.ReadConfig</span><br><span class="line">        /Users/dfc/devel/practical-<span class="keyword">go</span>/src/errors/readfile2.<span class="keyword">go</span>:<span class="number">29</span></span><br><span class="line">main.main</span><br><span class="line">        /Users/dfc/devel/practical-<span class="keyword">go</span>/src/errors/readfile2.<span class="keyword">go</span>:<span class="number">35</span></span><br><span class="line">runtime.main</span><br><span class="line">        /Users/dfc/<span class="keyword">go</span>/src/runtime/proc.<span class="keyword">go</span>:<span class="number">201</span></span><br><span class="line">runtime.goexit</span><br><span class="line">        /Users/dfc/<span class="keyword">go</span>/src/runtime/asm_amd64.s:<span class="number">1333</span></span><br><span class="line">could not read config</span><br></pre></td></tr></table></figure>
<p>使用 <code>errors</code> 包，你可以以人和机器都可检查的方式向错误值添加上下文。 如果昨天你来听我的演讲，你会知道这个库在被移植到即将发布的 Go 语言版本的标准库中。</p>
<h3 id="8-并发"><a href="#8-并发" class="headerlink" title="8. 并发"></a>8. 并发</h3><p>由于 Go 语言的并发功能，经常被选作项目编程语言。 Go 语言团队已经竭尽全力以廉价（在硬件资源方面）和高性能来实现并发，但是 Go 语言的并发功能也可以被用来编写性能不高同时也不太可靠的代码。在结尾，我想留下一些建议，以避免 Go 语言的并发功能带来的一些陷阱。</p>
<p>Go 语言以 <code>channels</code> 以及 <code>select</code> 和 <code>go</code> 语句来支持并发。如果你已经从书籍或培训课程中正式学习了 Go 语言，你可能已经注意到并发部分始终是这些课程的最后一部分。这个研讨会也没有什么不同，我选择最后覆盖并发，好像它是 Go 程序员应该掌握的常规技能的额外补充。</p>
<p>这里有一个二分法; Go 语言的最大特点是简单、轻量级的并发模型。作为一种产品，我们的语言几乎只推广这个功能。另一方面，有一种说法认为并发使用起来实际上并不容易，否则作者不会把它作为他们书中的最后一章，我们也不会遗憾地来回顾其形成过程。</p>
<p>本节讨论了 Go 语言的并发功能的“坑”。</p>
<h4 id="8-1-保持自己忙碌或做自己的工作"><a href="#8-1-保持自己忙碌或做自己的工作" class="headerlink" title="8.1. 保持自己忙碌或做自己的工作"></a>8.1. 保持自己忙碌或做自己的工作</h4><p>这个程序有什么问题？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(w, <span class="string">&quot;Hello, GopherCon SG&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序实现了我们的预期，它提供简单的 Web 服务。 然而，它同时也做了其他事情，它在无限循环中浪费 CPU 资源。 这是因为 <code>main</code> 的最后一行上的 <code>for &#123;&#125;</code> 将阻塞 <code>main goroutine</code>，因为它不执行任何 IO、等待锁定、发送或接收通道数据或以其他方式与调度器通信。</p>
<p>由于 Go 语言运行时主要是协同调度，该程序将在单个 CPU 上做无效地旋转，并可能最终实时锁定。</p>
<p>我们如何解决这个问题？ 这是一个建议。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(w, <span class="string">&quot;Hello, GopherCon SG&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		runtime.Gosched()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这看起来很愚蠢，但这是我看过的一种常见解决方案。 这是不了解潜在问题的症状。</p>
<p>现在，如果你有更多的经验，你可能会写这样的东西。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(w, <span class="string">&quot;Hello, GopherCon SG&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空的 <code>select</code> 语句将永远阻塞。 这是一个有用的属性，因为现在我们不再调用 <code>runtime.GoSched()</code> 而耗费整个 CPU。 但是这也只是治疗了症状，而不是病根。</p>
<p>我想向你提出另一种你可能在用的解决方案。 与其在 <code>goroutine</code> 中运行 <code>http.ListenAndServe</code>，会给我们留下处理 <code>main goroutine</code> 的问题，不如在 <code>main goroutine</code> 本身上运行 <code>http.ListenAndServe</code>。</p>
<blockquote>
<p>贴士:<br>如果 Go 语言程序的 <code>main.main</code> 函数返回，无论程序在一段时间内启动的其他 <code>goroutine</code> 在做什么, Go 语言程序会无条件地退出。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(w, <span class="string">&quot;Hello, GopherCon SG&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这是我的第一条建议：如果你的 <code>goroutine</code> 在得到另一个结果之前无法取得进展，那么让自己完成此工作而不是委托给其他 <code>goroutine</code> 会更简单。</p>
<p>这通常会消除将结果从 <code>goroutine</code> 返回到其启动程序所需的大量状态跟踪和通道操作。</p>
<blockquote>
<p>贴士:<br>许多 Go 程序员过度使用 <code>goroutine</code>，特别是刚开始时。与生活中的所有事情一样，适度是成功的关键。</p>
</blockquote>
<h4 id="8-2-将并发性留给调用者"><a href="#8-2-将并发性留给调用者" class="headerlink" title="8.2. 将并发性留给调用者"></a>8.2. 将并发性留给调用者</h4><p>以下两个 API 有什么区别？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListDirectory returns the contents of dir.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListDirectory</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListDirectory returns a channel over which</span></span><br><span class="line"><span class="comment">// directory entries will be published. When the list</span></span><br><span class="line"><span class="comment">// of entries is exhausted, the channel will be closed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListDirectory</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="title">chan</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p>首先，最明显的不同: 第一个示例将目录读入切片然后返回整个切片，如果出错则返回错误。这是同步发生的，<code>ListDirectory</code> 的调用者会阻塞，直到读取了所有目录条目。根据目录的大小，这可能需要很长时间，并且可能会分配大量内存来构建目录条目。</p>
<p>让我们看看第二个例子。 这个示例更像是 Go 语言风格，<code>ListDirectory</code> 返回一个通道，通过该通道传递目录条目。当通道关闭时，表明没有更多目录条目。由于在 <code>ListDirectory</code> 返回后发生了通道的填充，<code>ListDirectory</code> 可能会启动一个 <code>goroutine</code> 来填充通道。</p>
<blockquote>
<p>注意:<br>第二个版本实际上不必使用 Go 协程; 它可以分配一个足以保存所有目录条目而不阻塞的通道，填充通道，关闭它，然后将通道返回给调用者。但这样做不太现实，因为会消耗大量内存来缓冲通道中的所有结果。</p>
</blockquote>
<p>通道版本的 <code>ListDirectory</code> 还有两个问题：</p>
<ul>
<li>通过使用关闭通道作为没有其他项目要处理的信号，在中途遇到了错误时, <code>ListDirectory</code> 无法告诉调用者通过通道返回的项目集是否完整。调用者无法区分空目录和读取目录的错误。两者都导致从 <code>ListDirectory</code> 返回的通道立即关闭。</li>
<li>调用者必须持续从通道中读取，直到它被关闭，因为这是调用者知道此通道的是否停止的唯一方式。这是对 <code>ListDirectory</code> 使用的严重限制，即使可能已经收到了它想要的答案，调用者也必须花时间从通道中读取。就中型到大型目录的内存使用而言，它可能更有效，但这种方法并不比原始的基于切片的方法快。</li>
</ul>
<p>以上两种实现所带来的问题的解决方案是使用回调，该回调是在执行时在每个目录条目的上下文中调用函数。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListDirectory</span><span class="params">(dir <span class="keyword">string</span>, fn <span class="keyword">func</span>(<span class="keyword">string</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>毫不奇怪，这就是 <code>filepath.WalkDir</code> 函数的工作方式。</p>
<blockquote>
<p>贴士:<br>如果你的函数启动了 <code>goroutine</code>，你必须为调用者提供一种明确停止 <code>goroutine</code> 的方法。 把异步执行函数的决定留给该函数的调用者通常会更容易些。</p>
</blockquote>
<h4 id="8-3-永远不要启动一个停止不了的-goroutine。"><a href="#8-3-永远不要启动一个停止不了的-goroutine。" class="headerlink" title="8.3. 永远不要启动一个停止不了的 goroutine。"></a>8.3. 永远不要启动一个停止不了的 goroutine。</h4><p>前面的例子显示当一个任务时没有必要时使用 <code>goroutine</code>。但使用 Go 语言的原因之一是该语言提供的并发功能。实际上，很多情况下你希望利用硬件中可用的并行性。为此，你必须使用 <code>goroutines</code>。</p>
<p>这个简单的应用程序在两个不同的端口上提供 <code>http</code> 服务，端口 <code>8080</code> 用于应用程序服务，端口 <code>8001</code> 用于访问 <code>/debug/pprof</code> 终端。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">&quot;Hello, QCon!&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">go</span> http.ListenAndServe(<span class="string">&quot;127.0.0.1:8001&quot;</span>, http.DefaultServeMux) <span class="comment">// debug</span></span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, mux)                       <span class="comment">// app traffic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个程序不是很复杂，但它代表了真实应用程序的基础。</p>
<p>该应用程序存在一些问题，因为它随着应用程序的增长而显露出来，所以我们现在来解决其中的一些问题。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">&quot;Hello, QCon!&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;127.0.0.1:8001&quot;</span>, http.DefaultServeMux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> serveDebug()</span><br><span class="line">	serveApp()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将 <code>serveApp</code> 和 <code>serveDebug</code> 处理程序分解成为它们自己的函数，我们将它们与 <code>main.main</code> 分离。 也遵循了上面的建议，并确保 <code>serveApp</code> 和 <code>serveDebug</code> 将它们的并发性留给调用者。</p>
<p>但是这个程序存在一些可操作性问题。 如果 <code>serveApp</code> 返回，那么 <code>main.main</code> 将返回，导致程序关闭并由你使用的进程管理器来重新启动。</p>
<blockquote>
<p>贴士:<br>正如 Go 语言中的函数将并发性留给调用者一样，应用程序应该将监视其状态和检测是否重启的工作留给另外的程序来做。 不要让你的应用程序负责重新启动自己，最好从应用程序外部处理该过程。</p>
</blockquote>
<p>然而，<code>serveDebug</code> 是在一个单独的 <code>goroutine</code> 中运行的，返回后该 <code>goroutine</code> 将退出，而程序的其余部分继续。 由于 <code>/debug</code> 处理程序已停止工作很久，因此操作人员不会很高兴发现他们无法在你的应用程序中获取统计信息。</p>
<p>我们想要确保的是，如果任何负责提供此应用程序的 <code>goroutine</code> 停止，我们将关闭该应用程序。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">&quot;Hello, QCon!&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;127.0.0.1:8001&quot;</span>, http.DefaultServeMux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> serveDebug()</span><br><span class="line">	<span class="keyword">go</span> serveApp()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 <code>serverApp</code> 和 <code>serveDebug</code> 检查从 <code>ListenAndServe</code> 返回的错误，并在需要时调用 <code>log.Fatal</code>。因为两个处理程序都在 <code>goroutine</code> 中运行，所以我们将 <code>main goroutine</code> 停在 <code>select&#123;&#125;</code> 中。</p>
<p>这种方法存在许多问题：</p>
<ol>
<li>如果 <code>ListenAndServer</code> 返回 <code>nil</code> 错误，则不会调用 <code>log.Fatal</code>，并且该端口上的 HTTP 服务将在不停止应用程序的情况下关闭。</li>
<li><code>log.Fatal</code> 调用 <code>os.Exit</code>，它将无条件地退出程序; <code>defer</code> 不会被调用，其他 <code>goroutines</code> 也不会被通知关闭，程序就停止了。 这使得编写这些函数的测试变得困难。</li>
</ol>
<blockquote>
<p>贴士:<br>只在 <code>main.main</code> 或 <code>init</code> 函数中的使用 <code>log.Fatal</code>。</p>
</blockquote>
<p>我们真正想要的是任何错误发送回 <code>goroutine</code> 的调用者，以便它可以知道 <code>goroutine</code> 停止的原因，可以干净地关闭程序进程。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">&quot;Hello, QCon!&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> http.ListenAndServe(<span class="string">&quot;127.0.0.1:8001&quot;</span>, http.DefaultServeMux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done &lt;- serveDebug()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done &lt;- serveApp()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(done); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> err := &lt;-done; err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;error: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用通道来收集 <code>goroutine</code> 的返回状态。通道的大小等于我们想要管理的 <code>goroutine</code> 的数量，这样发送到 <code>done</code> 通道就不会阻塞，因为这会阻止 <code>goroutine</code> 的关闭，导致它泄漏。</p>
<p>由于没有办法安全地关闭 <code>done</code> 通道，我们不能使用 <code>for range</code> 来循环通道直到获取所有 <code>goroutine</code> 发来的报告，而是循环我们开启的多个 <code>goroutine</code>，即通道的容量。</p>
<p>现在我们有办法等待每个 <code>goroutine</code> 干净地退出并记录他们遇到的错误。所需要的只是一种从第一个 <code>goroutine</code> 转发关闭信号到其他 <code>goroutine</code> 的方法。</p>
<p>事实证明，要求 <code>http.Server</code> 关闭是有点牵扯的，所以我将这个逻辑转给辅助函数。<code>serve</code> 助手使用一个地址和 <code>http.Handler</code>，类似于 <code>http.ListenAndServe</code>，还有一个 <code>stop</code> 通道，我们用它来触发 <code>Shutdown</code> 方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(addr <span class="keyword">string</span>, handler http.Handler, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	s := http.Server&#123;</span><br><span class="line">		Addr:    addr,</span><br><span class="line">		Handler: handler,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-stop <span class="comment">// wait for stop signal</span></span><br><span class="line">		s.Shutdown(context.Background())</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">&quot;Hello, QCon!&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> serve(<span class="string">&quot;0.0.0.0:8080&quot;</span>, mux, stop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> serve(<span class="string">&quot;127.0.0.1:8001&quot;</span>, http.DefaultServeMux, stop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">2</span>)</span><br><span class="line">	stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done &lt;- serveDebug(stop)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done &lt;- serveApp(stop)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> stopped <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(done); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> err := &lt;-done; err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;error: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !stopped &#123;</span><br><span class="line">			stopped = <span class="literal">true</span></span><br><span class="line">			<span class="built_in">close</span>(stop)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，每次我们在 <code>done</code> 通道上收到一个值时，我们关闭 <code>stop</code> 通道，这会导致在该通道上等待的所有 <code>goroutine</code> 关闭其 <code>http.Server</code>。 这反过来将导致其余所有的 <code>ListenAndServe</code> <code>goroutines</code> 返回。 一旦我们开启的所有 <code>goroutine</code> 都停止了，<code>main.main</code> 就会返回并且进程会干净地停止。</p>
<blockquote>
<p>贴士:<br>自己编写这种逻辑是重复而微妙的。 参考下这个包: <a target="_blank" rel="noopener" href="https://github.com/heptio/workgroup">https://github.com/heptio/workgroup</a>，它会为你完成大部分工作。</p>
</blockquote>
<hr>
<blockquote>
<p>**引用: **</p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_1">1</a>. <a target="_blank" rel="noopener" href="https://gaston.life/books/effective-programming/">https://gaston.life/books/effective-programming/</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_2">2</a>. <a target="_blank" rel="noopener" href="https://talks.golang.org/2014/names.slide#4">https://talks.golang.org/2014/names.slide#4</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_3">3</a>. <a target="_blank" rel="noopener" href="https://www.infoq.com/articles/API-Design-Joshua-Bloch">https://www.infoq.com/articles/API-Design-Joshua-Bloch</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_1">1</a>. <a target="_blank" rel="noopener" href="https://www.lysator.liu.se/c/pikestyle.html">https://www.lysator.liu.se/c/pikestyle.html</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_2">2</a>. <a target="_blank" rel="noopener" href="https://speakerdeck.com/campoy/understanding-nil">https://speakerdeck.com/campoy/understanding-nil</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_3">3</a>. <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Ic2y6w8lMPA">https://www.youtube.com/watch?v=Ic2y6w8lMPA</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_4">4</a>. <a target="_blank" rel="noopener" href="https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88">https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_5">5</a>. <a target="_blank" rel="noopener" href="https://golang.org/doc/go1.4#internalpackages">https://golang.org/doc/go1.4#internalpackages</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_6">6</a>. <a target="_blank" rel="noopener" href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_7">7</a>. <a target="_blank" rel="noopener" href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_8">8</a>. <a target="_blank" rel="noopener" href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_9">9</a>. <a target="_blank" rel="noopener" href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201">https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_10">10</a>. <a target="_blank" rel="noopener" href="https://blog.golang.org/errors-are-values">https://blog.golang.org/errors-are-values</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_11">11</a>. <a target="_blank" rel="noopener" href="http://www.gopl.io/">http://www.gopl.io/</a></p>
</blockquote>
<hr>
<p><strong>原文链接：</strong><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html">Practical Go: Real world advice for writing maintainable Go programs</a></p>
<ul>
<li><em>如有翻译有误或者不理解的地方，请评论指正</em></li>
<li><em>待更新的译注之后会做进一步修改翻译</em></li>
<li><em>翻译：<a target="_blank" rel="noopener" href="https://github.com/llitfkitfk">田浩</a></em></li>
<li><em>邮箱：<a href="mailto:&#108;&#x6c;&#x69;&#x74;&#x66;&#107;&#x69;&#116;&#x66;&#107;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;">&#108;&#x6c;&#x69;&#x74;&#x66;&#107;&#x69;&#116;&#x66;&#107;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;</a></em></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-07-15T16:23:19.000Z" title="7/15/2019, 4:23:19 PM">2019-07-15</time>发表</span><span class="level-item"><time dateTime="2021-06-10T02:08:47.727Z" title="6/10/2021, 2:08:47 AM">2021-06-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></span><span class="level-item">3 分钟读完 (大约504个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/15/Golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Golang并发编程</a></h1><div class="content"><p>Go语言的并发是基于 goroutine 的，goroutine 类似于线程，但并非线程。可以将 goroutine 理解为一种虚拟线程。Go语言运行时会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用CPU性能。</p>
<p>Go 程序从 main 包的 main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine。</p>
<p><img src="https://i.loli.net/2019/07/15/5d2c2e4fe2f4d88322.jpg"></p>
<p>下面我们来看一个例子，在线演示：<a target="_blank" rel="noopener" href="https://play.golang.org/p/U9U-qjuY0t1">https://play.golang.org/p/U9U-qjuY0t1</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个goroutine</span></span><br><span class="line">	<span class="keyword">go</span> runing()</span><br><span class="line">	<span class="comment">// 创建一个匿名的goroutine</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;喜特:&quot;</span> + time.Now().String())</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里sleep一下是因为main方法如果执行完了，main该程序创建的所有goroutine都会退出</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runing</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;法克:&quot;</span> + time.Now().String())</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">法克:<span class="number">2009</span><span class="number">-11</span><span class="number">-10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> +<span class="number">0000</span> UTC m=+<span class="number">0.000000001</span></span><br><span class="line">喜特:<span class="number">2009</span><span class="number">-11</span><span class="number">-10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> +<span class="number">0000</span> UTC m=+<span class="number">0.000000001</span></span><br></pre></td></tr></table></figure>

<p>执行结果说明fuck函数中的sleep三秒并没有影响<code>喜特</code>的输出。</p>
<p>如果说 goroutine 是Go语言程序的并发体的话，那么 channel 就是它们之间的通信机制。一个 channel 是一个通信机制，它可以让一个 goroutine 通过它给另一个 goroutine 发送值信息。每个 channel 都有一个特殊的类型，也就是 channel 可发送数据的类型。一个可以发送 int 类型数据的 channel 一般写为 chan int。</p>
<p>下面我们利用goroutine+channel来实现一个生产消费者模型，示例代码如下，在线执行：<a target="_blank" rel="noopener" href="https://play.golang.org/p/lqUBugLdU-I">https://play.golang.org/p/lqUBugLdU-I</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个通道</span></span><br><span class="line">	channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int64</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 异步去生产</span></span><br><span class="line">	<span class="keyword">go</span> producer(channel)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 数据消费</span></span><br><span class="line">	consumer(channel)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(channel <span class="keyword">chan</span>&lt;- <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 将数据写入通道</span></span><br><span class="line">		channel &lt;- time.Now().Unix()</span><br><span class="line">		<span class="comment">// 睡1秒钟</span></span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(channel &lt;-<span class="keyword">chan</span> <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		timestamp := &lt;-channel</span><br><span class="line">		fmt.Println(timestamp)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出为如下：(每秒钟打印一次)</span><br><span class="line"><span class="number">1257894000</span></span><br><span class="line"><span class="number">1257894001</span></span><br><span class="line"><span class="number">1257894002</span></span><br><span class="line"><span class="number">1257894003</span></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-07-15T16:22:22.000Z" title="7/15/2019, 4:22:22 PM">2019-07-15</time>发表</span><span class="level-item"><time dateTime="2021-06-10T02:08:47.727Z" title="6/10/2021, 2:08:47 AM">2021-06-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></span><span class="level-item">2 分钟读完 (大约234个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/15/Golang%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B/">Golang指针类型和值类型</a></h1><div class="content"><p>Java中值类型和引用类型都是定死的，int、double、float、long、byte、short、char、boolean为值类型，其他的都是引用类型，而Go语言中却不是这样。</p>
<p>在Go语言中：</p>
<ul>
<li><code>&amp;</code>表示取地址，例如你有一个变量<code>a</code>那么<code>&amp;a</code>就是变量<code>a</code>在内存中的地址，对于Golang指针也是有类型的，比如a是一个string那么&amp;a是一个string的指针类型，在Go里面叫&amp;string。</li>
<li><code>*</code>表示取值，接上面的例子，假设你定义<code>b := &amp;a</code> 如果你打印<code>b</code>，那么输出的是<code>&amp;a</code>的内存地址，如果要取值，那么需要使用：<code>*b</code></li>
</ul>
<p>下面我们来看下例子，在线运行：<a target="_blank" rel="noopener" href="https://play.golang.org/p/jxAKyVMjnoy">https://play.golang.org/p/jxAKyVMjnoy</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="string">&quot;123&quot;</span></span><br><span class="line">	b := &amp;a</span><br><span class="line"></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	fmt.Println(*b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">0x40c128</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-07-15T16:20:11.000Z" title="7/15/2019, 4:20:11 PM">2019-07-15</time>发表</span><span class="level-item"><time dateTime="2021-06-10T02:08:47.731Z" title="6/10/2021, 2:08:47 AM">2021-06-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></span><span class="level-item">13 分钟读完 (大约1908个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/15/Java%E7%A8%8B%E5%BA%8F%E5%91%98Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/">Java程序员Go语言入门简介</a></h1><div class="content"><h2 id="为什么是Go语言"><a href="#为什么是Go语言" class="headerlink" title="为什么是Go语言"></a>为什么是Go语言</h2><ul>
<li>类C的语法，这意味着Java、C#、JavaScript程序员能很快的上手</li>
<li>有自己的垃圾回收机制</li>
<li>跨平台、编译即可执行无需安装依赖环境</li>
<li>支持反射</li>
</ul>
<h2 id="Go语言简介"><a href="#Go语言简介" class="headerlink" title="Go语言简介"></a>Go语言简介</h2><p>Go 语言（或 Golang）起源于 2007 年，并在 2009 年正式对外发布。Go 是非常年轻的一门语言，它的主要目标是“兼具Python等动态语言的开发速度和 C/C++ 等编译型语言的性能与安全性”。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>布尔</td>
</tr>
<tr>
<td>string</td>
<td>字符串</td>
</tr>
<tr>
<td>int</td>
<td>uint8,uint16,uint32,uint64,int8,int16,int32,int64</td>
</tr>
<tr>
<td>float</td>
<td>float32,float64</td>
</tr>
<tr>
<td>byte</td>
<td>byte</td>
</tr>
</tbody></table>
<p>参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/go/go-data-types.html">https://www.runoob.com/go/go-data-types.html</a></p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><p>在线运行示例：<a target="_blank" rel="noopener" href="https://play.golang.org/p/-4RylAqUV36">https://play.golang.org/p/-4RylAqUV36</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  name = <span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;hello &quot;</span> + name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来执行一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run main.go <span class="comment"># main.go 为刚刚创建的那个文件的名称</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hello world</span></span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>在线运行示例：<a target="_blank" rel="noopener" href="https://play.golang.org/p/zPqCkRZgrgp">https://play.golang.org/p/zPqCkRZgrgp</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> name <span class="keyword">string</span>   <span class="comment">// 声明</span></span><br><span class="line">	name = <span class="string">&quot;gaoyoubo&quot;</span> <span class="comment">// 赋值</span></span><br><span class="line">	fmt.Println(name)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">18</span> <span class="comment">// 声明并赋值</span></span><br><span class="line">	fmt.Println(age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>在线运行示例：<a target="_blank" rel="noopener" href="https://play.golang.org/p/0My8veBvtJ8">https://play.golang.org/p/0My8veBvtJ8</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	name := <span class="string">&quot;gaoyoubo&quot;</span></span><br><span class="line">	fmt.Println(name)</span><br><span class="line"></span><br><span class="line">	age := <span class="number">18</span></span><br><span class="line">	fmt.Println(age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>函数可以有多个返回值</li>
<li>隐式的指定函数是private还是public，函数首字母大写的为public、小写的为private</li>
<li>没有类似Java中的<code>try cache</code>、<code>throw</code>，Go语言是通过将<code>error</code>作为返回值来处理异常。</li>
<li>不支持重载</li>
</ul>
<p>下面我们通过一个示例来了解一下，在线运行示例：<a target="_blank" rel="noopener" href="https://play.golang.org/p/PYy3ueuPFS6">https://play.golang.org/p/PYy3ueuPFS6</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log1()</span><br><span class="line"></span><br><span class="line">	log2(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">	ret1 := add1(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;add1 result:&quot;</span> + strconv.Itoa(ret1))</span><br><span class="line"></span><br><span class="line">	ret2, err := Add2(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Add2 result:&quot;</span> + strconv.Itoa(ret2))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Add2 error&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有、无入参、无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;execute func log1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有、入参、无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log2</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;execute func log2:&quot;</span> + msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有、两个入参、一个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(count1, count2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	total := count1 + count2</span><br><span class="line">	fmt.Println(<span class="string">&quot;execute func add3, result=&quot;</span> + strconv.Itoa(total))</span><br><span class="line">	<span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Public、两个入参、多个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add2</span><span class="params">(count1, count2 <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> count1 &lt; <span class="number">1</span> || count2 &lt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;数量不能小于1&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	total := count1 + count2</span><br><span class="line">	<span class="keyword">return</span> total, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execute func log1</span><br><span class="line">execute func log2:hello world</span><br><span class="line">execute func add3, result&#x3D;2</span><br><span class="line">add1 result:2</span><br><span class="line">Add2 error 数量不能小于1</span><br></pre></td></tr></table></figure>

<p>但函数有多个返回值的时候，有时你只关注其中一个返回值，这种情况下你可以将其他的返回值赋值给空白符：<code>_</code>，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_, err := Add2(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(err)</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>空白符特殊在于实际上返回值并没有赋值，所以你可以随意将不同类型的值赋值给他，而不会由于类型不同而报错。</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>Go语言不是像Java那样的面向对象的语言，他没有对象和继承的概念。也没有<code>class</code>的概念。在Go语言中有个概念叫做结构体（<code>struct</code>），结构体和Java中的<code>class</code>比较类似。下面我们定义一个结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Gender <span class="keyword">string</span></span><br><span class="line">	Age    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面我们定义了一个结构体<code>User</code>，并为该结构体分别设置了三个公有属性：Name/Gender/Age，下面我们来创建一个User对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;</span><br><span class="line">	Name:   <span class="string">&quot;hahaha&quot;</span>,</span><br><span class="line">	Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">	Age:    <span class="number">18</span>, <span class="comment">// 值得一提的是，最后的逗号是必须的，否则编译器会报错，这就是go的设计哲学之一，要求强一致性。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体的属性可以在结构体内直接声明，那么如何为结构体声明函数（即Java中的方法）呢，我们来看下下面的示例：在线运行示例：<a target="_blank" rel="noopener" href="https://play.golang.org/p/01_cTu0RzdH">https://play.golang.org/p/01_cTu0RzdH</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Gender <span class="keyword">string</span></span><br><span class="line">	Age    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义User的成员方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">addAge</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u.Age = u.Age + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	user := User&#123;</span><br><span class="line">		Name:   <span class="string">&quot;哈&quot;</span>, <span class="comment">// 名称</span></span><br><span class="line">		Gender: <span class="string">&quot;男&quot;</span>, <span class="comment">// 性别</span></span><br><span class="line">		Age:    <span class="number">18</span>,  <span class="comment">// 值得一提的是，最后的逗号是必须的，否则编译器会报错，这就是go的设计哲学之一，要求强一致性。</span></span><br><span class="line">	&#125;</span><br><span class="line">	user.addAge()</span><br><span class="line">	fmt.Println(user.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针类型和值类型"><a href="#指针类型和值类型" class="headerlink" title="指针类型和值类型"></a>指针类型和值类型</h3><p>Java中值类型和引用类型都是定死的，int、double、float、long、byte、short、char、boolean为值类型，其他的都是引用类型，而Go语言中却不是这样。</p>
<p>在Go语言中：</p>
<ul>
<li><code>&amp;</code>表示取地址，例如你有一个变量<code>a</code>那么<code>&amp;a</code>就是变量<code>a</code>在内存中的地址，对于Golang指针也是有类型的，比如a是一个string那么&amp;a是一个string的指针类型，在Go里面叫&amp;string。</li>
<li><code>*</code>表示取值，接上面的例子，假设你定义<code>b := &amp;a</code> 如果你打印<code>b</code>，那么输出的是<code>&amp;a</code>的内存地址，如果要取值，那么需要使用：<code>*b</code></li>
</ul>
<p>下面我们来看下例子，在线运行：<a target="_blank" rel="noopener" href="https://play.golang.org/p/jxAKyVMjnoy">https://play.golang.org/p/jxAKyVMjnoy</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="string">&quot;123&quot;</span></span><br><span class="line">	b := &amp;a</span><br><span class="line"></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	fmt.Println(*b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">0x40c128</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p>Go语言的并发是基于 goroutine 的，goroutine 类似于线程，但并非线程。可以将 goroutine 理解为一种虚拟线程。Go语言运行时会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用CPU性能。</p>
<p>Go 程序从 main 包的 main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine。</p>
<p><img src="/images/2019/07/15/55b6ace0-a6d9-11e9-8437-8fc3aa44f6bd.jpg"></p>
<p>下面我们来看一个例子（在线演示：<a target="_blank" rel="noopener" href="https://play.golang.org/p/U9U-qjuY0t1%EF%BC%89">https://play.golang.org/p/U9U-qjuY0t1）</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个goroutine</span></span><br><span class="line">	<span class="keyword">go</span> runing()</span><br><span class="line">	<span class="comment">// 创建一个匿名的goroutine</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;喜特:&quot;</span> + time.Now().String())</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里sleep一下是因为main方法如果执行完了，main该程序创建的所有goroutine都会退出</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runing</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;法克:&quot;</span> + time.Now().String())</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">法克:<span class="number">2009</span><span class="number">-11</span><span class="number">-10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> +<span class="number">0000</span> UTC m=+<span class="number">0.000000001</span></span><br><span class="line">喜特:<span class="number">2009</span><span class="number">-11</span><span class="number">-10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> +<span class="number">0000</span> UTC m=+<span class="number">0.000000001</span></span><br></pre></td></tr></table></figure>

<p>执行结果说明fuck函数中的sleep三秒并没有影响<code>喜特</code>的输出。</p>
<p>如果说 goroutine 是Go语言程序的并发体的话，那么 channel 就是它们之间的通信机制。一个 channel 是一个通信机制，它可以让一个 goroutine 通过它给另一个 goroutine 发送值信息。每个 channel 都有一个特殊的类型，也就是 channel 可发送数据的类型。一个可以发送 int 类型数据的 channel 一般写为 chan int。</p>
<p>下面我们利用goroutine+channel来实现一个生产消费者模型，示例代码如下：（在线执行：<a target="_blank" rel="noopener" href="https://play.golang.org/p/lqUBugLdU-I%EF%BC%89">https://play.golang.org/p/lqUBugLdU-I）</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个通道</span></span><br><span class="line">	channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int64</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 异步去生产</span></span><br><span class="line">	<span class="keyword">go</span> producer(channel)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 数据消费</span></span><br><span class="line">	consumer(channel)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(channel <span class="keyword">chan</span>&lt;- <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 将数据写入通道</span></span><br><span class="line">		channel &lt;- time.Now().Unix()</span><br><span class="line">		<span class="comment">// 睡1秒钟</span></span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(channel &lt;-<span class="keyword">chan</span> <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		timestamp := &lt;-channel</span><br><span class="line">		fmt.Println(timestamp)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出为如下：(每秒钟打印一次)</span><br><span class="line"><span class="number">1257894000</span></span><br><span class="line"><span class="number">1257894001</span></span><br><span class="line"><span class="number">1257894002</span></span><br><span class="line"><span class="number">1257894003</span></span><br></pre></td></tr></table></figure>


<h2 id="Java程序员觉得不好用的地方"><a href="#Java程序员觉得不好用的地方" class="headerlink" title="Java程序员觉得不好用的地方"></a>Java程序员觉得不好用的地方</h2><ul>
<li>异常处理</li>
<li>没有泛型</li>
<li>不支持多态、重载</li>
<li>不支持注解（但是他的struct中的属性支持<code>tag</code>）</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/go/go-tutorial.html">https://www.runoob.com/go/go-tutorial.html</a></li>
<li><a target="_blank" rel="noopener" href="https://books.studygolang.com/the-little-go-book_ZH_CN/">https://books.studygolang.com/the-little-go-book_ZH_CN/</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-04-28T12:15:05.000Z" title="4/28/2019, 12:15:05 PM">2019-04-28</time>发表</span><span class="level-item"><time dateTime="2021-06-10T02:08:47.731Z" title="6/10/2021, 2:08:47 AM">2021-06-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></span><span class="level-item">2 小时读完 (大约22289个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/28/the-little-go-book/">Go 简易教程</a></h1><div class="content"><h1 id="关于本书"><a href="#关于本书" class="headerlink" title="关于本书"></a>关于本书</h1><h2 id="授权许可"><a href="#授权许可" class="headerlink" title="授权许可"></a>授权许可</h2><p>本书中的内容使用 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>（署名 - 非商业性使用 - 相同方式共享4.0许可协议）授权。你不必为此书付费。<br>你可以免费的复制、发布、修改或者展示此书。但是，这本书的版权归原作者Karl Seguin所有，不要将此书用于商业目的。</p>
<p>关于许可证的全部内容你可以浏览以下网站：</p>
<p><a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">http://creativecommons.org/licenses/by-nc-sa/4.0/</a></p>
<h2 id="最新版本"><a href="#最新版本" class="headerlink" title="最新版本"></a>最新版本</h2><p>这本书的最新版本可以在以下网站获得:<br><a target="_blank" rel="noopener" href="http://github.com/karlseguin/the-little-go-book">http://github.com/karlseguin/the-little-go-book</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每次提起学习一门新语言，我真的是又爱又恨。一方面，语言是我们的行事之本，即使一些小的变化都会对事情有重大的影响。可能有时一闪而过的 <em>灵感</em> 就会对你如何编程产生长久的影响力，并重新定义你对其他语言的期望。而头疼的是，语言的设计是呈增量式的，要学习新的关键字、类型系统、代码风格以及新的库、社区和范例真的是难言其苦。相比于所有其他必须学习的事情，花时间在一门新的语言上貌似真的是很糟糕的投资。</p>
<p>即便如此，我们还是得走下去。我们 <em>必须</em> 得乐于每天一点点地进步，因为“语言是我们的行事之本”。虽然语言的变化往往会是循序渐进的，但它影响范围仍然很广，包括了有生产率、可读性、性能、可测试性、依赖性管理、错误处理、文档、简要、社区、标准库等等。所以，有好点的说法来形容 <em>千刀万剐</em> 么？</p>
<p> 留给我们一个重要问题就是：为什么选择 <strong>Go?</strong> 。对于我来说，有两条原因。第一条，它是一种相对简单的语言，且具有相对简单的标准库。在很多方面，Go 的特性语法是为了简化我们在过去几十年中添加到编程语言中的一些复杂特性。另外一条原因就是对于许多开发者来说，它将补充您的知识面。</p>
<p>Go 是作为系统语言（例如：操作系统，设备驱动程序）创建的，因此它针对的是 C 和 C++ 开发人员。按照 Go 团队的说法，应用程序开发人员已经成为 Go 的主要用户而不是系统开发人员了，这个说法我也是相信的。为什么？我不能权威的代表系统开发人员说话，但对于我们这些构建网站，服务，桌面应用程序等的人来说，它可以部分的归结为对一类系统的新兴需求，这类系统介于低级系统应用程序和更高级的应用程序之间。</p>
<p>可能 Go 语言有消息传递机制，缓存，重计算数据分析，命令行接口，体制和监控，我不知道给 Go 语言什么样的标签，但是在我的职业生涯中，随着系统的复杂性不断增加，以及动辄成千上万的并发，显然对定制基础类型系统的需求不断增加。你可以使用 Ruby 或者 Python 构建这样的系统（大多人都这样做），但这些类型的系统可以从更严格的类型系统和更高的性能中受益。类似地，你可以使用 Go 来构建网站（很多人都愿意这样做），但我仍然喜欢 Node 或者 Ruby 对这类系统展现出的表现力。</p>
<p>Go 语言还擅长其他领域。比如，当运行一个编译过的 Go 程序时，他没有依赖性。你不必担心用户是安装了 Ruby 或者 JVM，如果这样，你还要考虑版本。出于这个原因，Go  作为命令行程序以及其他并发类型的工具（日志收集器）的开发语言变得越来越流行。</p>
<p>坦白来说，学习 Go 可以有效利用你的时间。你不必担心会花费很长时间学习 Go 甚至掌握它，你最终会从你的努力中得到一些实用的东西。</p>
<h2 id="作者注解"><a href="#作者注解" class="headerlink" title="作者注解"></a>作者注解</h2><p>对于写这本书我犹豫再三，主要有两个原因。第一个是 Go 有自己的文档，特别是 <a target="_blank" rel="noopener" href="https://golang.org/doc/effective_go.html">Effective Go</a>。</p>
<p>另一个是在写一本关于语言类的书的时候我会有点不安。当我们写 《 The Little MongoDB Book》 这本书的时候，我完全假设大多数读者已经理解了关系型数据库和建模的基本知识。在写 《The Little Redis Book》这本书的时候，你也可以同样假设读者已经熟悉键值存储。</p>
<p>在我考虑未来的某些章节的时候，我知道不能再做出同样的假设。你花多长时间学习并理解接口，这是个新的概念，我希望你从中学到的不仅仅是 <strong>Go 有提供接口</strong>，并且还有如何使用它们。最终，我希望你向我反馈本书的哪部分讲得太细或者太粗，我会感到很欣慰，也算是我对读者们的小小要求了。</p>
<h1 id="第一章-·-基础"><a href="#第一章-·-基础" class="headerlink" title="第一章 · 基础"></a>第一章 · 基础</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>如果你想去尝试运行 Go 的代码，你可以去看看  <a target="_blank" rel="noopener" href="https://play.golang.org/">Go Playground</a>  ,它可以在线运行你的代码并且不要安装任何东西。这也是你在 <a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!forum/golang-nuts">Go 的论坛区</a>和 StackOverflow 等地方寻求帮助时分享 Go 代码的最常用方法。</p>
<p>Go 的安装很简单。你可以用源码去安装，但是我还是建议你使用其中一个预编译的二进制文件。当你 <a target="_blank" rel="noopener" href="https://golang.org/dl/">跳转到下载页面</a>，你将会看到 Go 语言的在各个平台上的安装包。我们会避免这些东西并且学会如何在自己的平台上安装好 Go。正如你所看到的的那样，安装 Go 并不是很难。</p>
<p>除了一些简单的例子， Go 被设计成代码在工作区内运行。工作区是一个文件夹，这个文件夹由 <code>bin</code> ，<code>pkg</code>，以及<code>src</code>子文件夹组成的。你可能会试图强迫 Go 遵循自己的风格-不要这么去做。</p>
<p>一般，我把我的项目放在 <code>~/code</code> 文件夹下。比如，<code>~/code/blog</code> 目录就包含了我的 blog 项目。对于 Go 来说，我的工作区域就是 <code>~/code/go</code> ，然后我的 Go 写的项目代码就在 <code>~/code/go/src/blog</code> 文件夹下。</p>
<p>简单来说，无论你希望把你的项目放在哪里，你最好创建一个 <code>go</code> 的文件夹，再在里面创建一个 <code>src</code> 的子文件夹。</p>
<h3 id="OSX-Linux-系统安装-Go"><a href="#OSX-Linux-系统安装-Go" class="headerlink" title="OSX / Linux 系统安装 Go"></a>OSX / Linux 系统安装 Go</h3><p>下载适合你自己电脑系统的 <code>tar.gz</code> 文件。对于 OSX 系统来说，你可能会对 <code>go#.#.#.darwin-amd64-osx10.8.tar.gz</code> 感兴趣，其中 <code>#.#.#</code> 代表 Go 的最新版本号。</p>
<p>通过  <code>tar -C /usr/local -xzf go#.#.#.darwin-amd64-osx10.8.tar.gz</code> 命令将文件加压缩到 <code>/usr/local</code> 目录下</p>
<p>设置两个环境变量：</p>
<p>1.<code>GOPATH</code> 指向的是你的工作目录，对我来说，那个目录就是 <code>$HOME/code/go</code><br>2.我们需要将 Go 的二进制文件添加到的 <code>PATH</code>变量中。 </p>
<p>你可以通过下面的 shell 去设置这两个环境变量：</p>
<pre><code>echo &#39;export GOPATH=$HOME/code/go&#39; &gt;&gt; $HOME/.profile
echo &#39;export PATH=$PATH:/usr/local/go/bin&#39; &gt;&gt; $HOME/.profile
</code></pre>
<p>你需要将这些环境变量激活。你可以关掉 shell 终端，然后在打开 shell 终端，或者你可以在 shell 终端运行 <code>source $HOME/.profile</code>。</p>
<p>在命令终端输入 <code>go version</code>，你将会得到一个 <code>go version go1.3.3 darwin / amd64</code> 的输出，Go 就安装完成了。</p>
<h3 id="Windows-系统"><a href="#Windows-系统" class="headerlink" title="Windows 系统"></a>Windows 系统</h3><p>下载最新的 zip 文件。如果你的电脑是 64 位的系统，你将需要 <code>go#.#.#.windows-amd64.zip</code> ，这里的  <code>#.#.#</code> 是 Go 的最新版本号。</p>
<p>解压缩  <code>go#.#.#.windows-amd64.zip</code> 文件到你选择的位置。 <code>c:\Go</code>这个位置是个不错的选择。</p>
<p>在系统中设置两个环境变量：</p>
<ol>
<li> <code>GOPATH</code> 同样的指向的是你的工作目录。这个变量看起来像<code>c:\users\goku\work\go</code> 这个样子。</li>
<li>添加 <code>c:\Go\bin</code>  到系统的 <code>PATH</code> 环境变量。</li>
</ol>
<p>你可以通过「系统」 控制面板的 「高级」 选项卡上的 「环境变量」按钮设置环境变量。 某些版本的 Windows 通过「系统」控制面板中的「高级系统选项」选项此控制面板。</p>
<p>打开一个 <code>cmd</code> 命令终端，输入 <code>go version</code>。 你会得到一个 <code>go version go1.3.3 windows/amd64</code> 的输出，即表示 Go 安装完成。</p>
<p>Go 是一门编译型，具有静态类型和类 C 语言语法的语言，并且有垃圾回收（GC）机制。这是什么意思？</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译是将源代码翻译为更加低级的语言的过程——翻译成汇编语言（例如 Go），或是翻译成其他中间语言（如 Java 和 C#）。</p>
<p>编译型语言可能会让你很不爽，因为编译过程实在是太慢了。如果每次都需要花好几分钟甚至好几个小时去等待代码编译的话，很难进行快速迭代。而编译速度是 Go 的主要优化目标之一。这对我们这些从事大型项目开发或者是习惯用解释型快速看到程序结果的人来说，确实是一件好事。</p>
<p>编译型语言注重于运行速度和无依赖执行程序（至少对于 C/C++ 和 Go 来说是这样的，直接将依赖编译到程序中）。</p>
<h2 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h2><p>静态类型意味着变量必须是特定的类型（如：int, string, bool, []byte 等等），这可以通过在声明变量的时候，指定变量的类型来实现，或者让编译器自行推断变量的类型（我们将很快可以看到实例）。</p>
<p>关于静态类型的东西，可以说的还有很多，但是我相信通过看代码能更好的理解静态类型是什么。如果你习惯于动态类型语言， 你可能会发现这很麻烦。这种想法没错，但是静态类型语言也有优点，特别是当你将静态类型和编译配对使用时。这两者经常混为一谈。确实当你有其中一个的时候，通常也会有另一个，但是这不是硬性规定的。使用强类型系统，编译器能够检测除语法错误之外的问题从而进一步优化。</p>
<h2 id="类-C-语法"><a href="#类-C-语法" class="headerlink" title="类 C 语法"></a>类 C 语法</h2><p>当说到一门语言是类 C 语法的时候，通常意味着如果你用过其他类 C 语言如：C，C++，Java，JavaScript 和 C#，你会觉得 Go 的语法很熟悉——最少表面上是这样的。举个例子，<code>&amp;&amp;</code> 用于逻辑 AND，<code>==</code> 用于判断是否相等，<code>&#123;</code> 和 <code>&#125;</code> 是块的开始和结束，数组下标的起始值为 0。</p>
<p>类 Ｃ 语法也倾向于用分号表示作为语句结束符，并将条件写在括号中。Go 不支持这些，但是仍然使用括号来控制优先级。例如，一个 <code>if</code> 语句是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> name == <span class="string">&quot;Leto&quot;</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;the spice must flow&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在很多复杂系统中，括号符还是很有用的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (name == <span class="string">&quot;Goku&quot;</span> &amp;&amp; power &gt; <span class="number">9000</span>) || (name == <span class="string">&quot;gohan&quot;</span> &amp;&amp; power &lt; <span class="number">4000</span>)  &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;super Saiyan&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，Go 要比 C# 或 Java 更接近 C - 不仅是语法方面，还有目的方面。这反映在语言的简洁和简单上，希望你在学习它的时候能慢慢体会这一点。</p>
<h2 id="变量和申明"><a href="#变量和申明" class="headerlink" title="变量和申明"></a>变量和申明</h2><p>如果我们用 x = 4 来申明和赋值变量，那么我们就可以同时开始和结束对变量的查看了。遗憾的是，Go 更为复杂些。我们将通过简单的示例来开始我们的学习。然后，在下一章中，我们会在创建和使用结构体时，进一步扩展。尽管如此，你可能还得花一段时间来适应，才能感受到它带给你的舒适感。</p>
<p>你可能会想：“哇！这有什么复杂的？”。 让我们开始一个例子。</p>
<p>下面的例子是 Go 中，申明变量和赋值最为明确的方法，但也是最为冗长的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> power <span class="keyword">int</span></span><br><span class="line">  power = <span class="number">9000</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;It&#x27;s over %d\n&quot;</span>, power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们定义了一个 <code>int</code> 类型的变量 <code>power</code>。默认情况下，Go 会为变量分配默认值。Integers 的默认值是 <code>0</code>，booleans 默认值是 <code>false</code>，strings 默认值是 <code>&quot;&quot;</code> 等等。下面，我们创建一个值为 <code>9000</code> 的名为 <code>power</code> 的变量。我们可以将定义和赋值两行代码合并起来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> power <span class="keyword">int</span> = <span class="number">9000</span></span><br></pre></td></tr></table></figure>

<p>不过，这么写太长了。Go 提供了一个方便的短变量声明运算符 <code>:=</code> ，它可以自动推断变量类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power := <span class="number">9000</span></span><br></pre></td></tr></table></figure>

<p>这非常方便，它可以跟函数结合使用，就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  power := getPower()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPower</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">9001</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是要用 <code>:=</code> 来声明变量以及给变量赋值。相同变量不能被声明两次（在相同作用域下），如果你尝试这样，会收到错误提示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  power := <span class="number">9000</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;It&#x27;s over %d\n&quot;</span>, power)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编译器错误：</span></span><br><span class="line">  <span class="comment">//  := 左侧不是新的变量</span></span><br><span class="line">  power := <span class="number">9001</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;It&#x27;s also over %d\n&quot;</span>, power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编辑器会告诉你 * := 左侧不是新的变量*。这就意味着当我们首次声明一个变量时应该使用 <code>:=</code> ，后面再给变量赋值时应该使用 <code>=</code>。这似乎很有道理，但是凭空来记忆且需要根据情况来切换却是很难的事。</p>
<p>如果你仔细阅读代码的错误信息，你会发现 <em>variables</em> 单词是个复数，即有多个变量，那是因为go支持多个变量同时赋值（使用 <code>=</code> 或者 <code>:=</code>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  name, power := <span class="string">&quot;Goku&quot;</span>, <span class="number">9000</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s&#x27;s power is over %d\n&quot;</span>, name, power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，多个变量赋值的时候，只要其中有一个变量是新的，就可以使用<code>:=</code>。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  power := <span class="number">1000</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;default power is %d\n&quot;</span>, power)</span><br><span class="line"></span><br><span class="line">  name, power := <span class="string">&quot;Goku&quot;</span>, <span class="number">9000</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s&#x27;s power is over %d\n&quot;</span>, name, power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管变量 <code>power</code> 使用了两次<code>:=</code>，但是编译器不会在第 2 次使用 <code>:=</code>时报错，因为这里有一个新的 <code>name</code>变量，它可以使用<code>:=</code>。然后你不能改变 <code>power</code> 变量的类型，它已经被声明成一个整型，所以只能赋值整数。</p>
<p>到目前为止，你最后需要了解的一件事是，Go 会像 import 一样，不允许你在程序中拥有未使用的变量。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  name, power := <span class="string">&quot;Goku&quot;</span>, <span class="number">1000</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;default power is %d\n&quot;</span>, power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将不会通过编译，因为 <code>name</code> 是一个被申明但是未被使用的变量，就像 import 的包未被使用时，也将会导致编译失败，但总的来说，我认为这有助于提高代码的清洁度和可读性。</p>
<p>还有更多关于的申明和赋值的技巧。初始化一个变量时，请使用：<code> var NAME TYPE</code>；给变量申明及赋值时，请使用： <code>NAME := VALUE</code> ； 给之前已经申明过的变量赋值时，请使用： <code>NAME = VALUE</code> </p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>一些变量，在创建的时候，就拥有一个简单定义的生命周期。对于函数中的变量，会在函数执行完后进行销毁。在别的语言中，对于编译器而言，这不会很明显。例如：函数返回的变量，或者由其他变量和对象所调用的变量，它们的生命周期是很难确定的。 如果没有垃圾回收机制，那么开发人员就得知道有哪些不需要用到的变量，并将它们释放。就像 C 语言，你需要使用 <code>free(str);</code> 来释放变量。 </p>
<p>语言的垃圾回收机制（像：Ruby, Python, Java, JavaScript, C# , Go）是会对变量进行跟踪，并在没有使用它们的时候，进行释放。垃圾回收会增加一些额外的开销，但是也减少了一些致命性的 BUG。</p>
<h2 id="运行-go-代码"><a href="#运行-go-代码" class="headerlink" title="运行 go 代码"></a>运行 go 代码</h2><p>创建一个简单的程序然后学习如何编译和运行它。打开你的文本编辑器写入下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;it&#x27;s over 9000!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存文件并命名为 <code>main.go</code> 。 你可以将文件保存在任何地方；不必将这些琐碎的例子放在 go 的工作空间内。</p>
<p>接下来，打开一个 shell 或者终端提示符，进入到文件保存的目录内， 对于我而言， 应该输入 <code>cd ~/code</code> 进入到文件保存目录。</p>
<p>最后，通过敲入以下命令来运行程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure>

<p>如果一切正常(即你的 golang 环境配置的正确)，你将看到 <em>it’s over 9000!</em> 。</p>
<p>但是编译步骤是怎么样的呢？ <code>go run</code> 命令已经包含了<strong>编译</strong>和<strong>运行</strong>。它使用一个临时目录来构建程序，执行完然后清理掉临时目录。你可以执行以下命令来查看临时文件的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run --work main.go</span><br></pre></td></tr></table></figure>

<p>明确要编译代码的话，使用 <code>go build</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build main.go</span><br></pre></td></tr></table></figure>

<p>这将产生一个可执行文件，名为 <code>main</code> ，你可以执行该文件。如果是在 Linux / OSX 系统中，别忘了使用 <code>./</code> 前缀来执行，也就是输入 <code>./main</code>  。</p>
<p>在开发中，你既可以使用 <code>go run</code> 也可以使用 <code>go build</code> 。但当你正式部署代码的时候，你应该部署通过 <code>go build</code> 产生的二进制文件并且执行它。</p>
<h3 id="入口函数-Main"><a href="#入口函数-Main" class="headerlink" title="入口函数 Main"></a>入口函数 Main</h3><p>希望刚才执行的代码是可以理解的。我们刚刚创建了一个函数，并且使用内置函数 <code>println</code> 打印出了字符串。难道仅因为这里只有一个选择，所以 <code>go run</code> 知道执行什么吗？？不。在 go 中程序入口必须是 <code>main</code> 函数，并且在 <code>main</code> 包内。</p>
<p>我们将在后面的章节中详细介绍<code>包</code>。目前，我们将专注于理解 go 基础，一直会在 <code>main</code> 包中写代码。</p>
<p>如果你想尝试，你可以修改代码并且可以更改包名。使用 <code>go run</code> 执行程序将出现一个错误。 接着你可以将包名改回 <code>main</code> ，换一个不同的方法名，你会看到一个不同的错误。尝试使用 <code>go build</code> 代替 <code>go run</code> 来执行刚才的代码，注意代码编译时，没有入口点可以执行。但当你构建一个库时，确实完全正确的。</p>
<h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><p>Go 有很多内建函数，例如 <code>println</code>，可以在没有引用情况下直接使用。但是，如果不使用 Go 的标准库直接使用第三方库，我们就无法走的更远。<code>import</code> 关键字被用于去声明文件中代码要使用的包。</p>
<p>修改下我们的程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;It&#x27;s over&quot;</span>, os.Args[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以这样运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go 9000</span><br></pre></td></tr></table></figure>

<p>我们现在用了 Go 的两个标准包：<code>fmt</code> 和 <code>os</code> 。我们也介绍了另一个内建函数  <code>len</code> 。<code>len</code>  返回字符串的长度，字典值的数量，或者我们这里看到的，它返回了数组元素的数量。如果你想知道我们这里为什么期望得到两个参数，它是因为第一个参数 – 索引0处 – 总是当前可运行程序的路径。（更改程序将它打印出来亲自看看就知道了）</p>
<p>你可能注意到了，我们在函数名称前加上了前缀包名，例如，<code>fmt.PrintLn</code>。这是不同于其他很多语言的。后续的章节中我们将学习到更多关于包的知识。现在，知道如何导入以及使用一个包就是一个好的开始。</p>
<p>在 Go 中，关于导包是很严格的。如果你导入了一个包却没有使用将会导致编译不通过。尝试运行下面的程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你应该会得到两个关于 <code>fmt</code> 和 <code>os</code> 被导入却没有被使用的错误。这很烦人的是不是呀？绝对是这样的，不过随着时间的推移，你将慢慢习惯它（虽然仍然烦人，不过要以 Go 的思维写 Go）。Go 如此严格是因为没用的导入会降低编译速度；诚然，我们大多数人不会关注这个问题。</p>
<p>另一个需要记住的事情是 Go 的标准库已经有了很好的文档。你可以访问 <a target="_blank" rel="noopener" href="https://golang.org/pkg/fmt/#Println">https://golang.org/pkg/fmt/#Println</a> 去看更多关于 <code>PrintLn</code> 函数的信息。你可以点击那个部分的头去看源代码。另外，也可以滚动到顶部查看关于 Go 格式化功能的更多消息。</p>
<p>如果没有互联网，你可以这样在本地获取文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">godoc -http&#x3D;:6060</span><br></pre></td></tr></table></figure>

<p>然后浏览器中访问  <code>http://localhost:6060</code></p>
<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>这是个好时机指出函数是可以返回多个值的。让我们看三个函数：一个没有返回值，一个有一个返回值，一个有两个返回值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">power</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以像这样使用最后一个：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value, exists := power(<span class="string">&quot;goku&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> exists == <span class="literal">false</span> &#123;</span><br><span class="line">  <span class="comment">// 处理错误情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时候，你仅仅关注其中一个返回值。这个情况下，你可以将其他的返回值赋值给空白符<code>_</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_, exists := power(<span class="string">&quot;goku&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> exists == <span class="literal">false</span> &#123;</span><br><span class="line">  <span class="comment">// handle this error case</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这不仅仅是一个惯例。<code>_</code> ，空白标识符，特殊在于实际上返回值并没有赋值。这让你可以一遍又一遍地使用 <code>_</code> 而不用管它的类型。</p>
<p>最后，关于函数声明还有些要说的。如果参数有相同的类型，您可以用这样一个简洁的用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回多个值可能是你经常使用的，你也可能会频繁地使用 <code>_</code> 丢弃一个值。命名返回值和稍微冗长的参数声明不太常用。尽管如此，你将很快遇到他们，所以了解他们很重要。</p>
<h2 id="继续之前"><a href="#继续之前" class="headerlink" title="继续之前"></a>继续之前</h2><p>我们之前看了很多小的独立片段，在这点上，可能会感到有点脱节。我们将慢慢地构建更大的例子，将这些小的片段组合在一起。</p>
<p>如果你之前用的是动态类型语言，那么类型和声明的复杂性看起来像是在倒退。我并没有不同意你，在某些系统中动态语言可能更加有效。</p>
<p>如果你来自静态类型的语言，你可能对 Go 感到满意。类型推断以及多值返回的设计非常棒?（尽管这不是 Go 独有）。希望随着我们了解更多，你将会慢慢爱上这干净简洁的语法。</p>
<h1 id="第二章-·-结构体"><a href="#第二章-·-结构体" class="headerlink" title="第二章 · 结构体"></a>第二章 · 结构体</h1><p>Go 不是像 C ++，Java，Ruby和C＃一样的面向对象的（OO）语言。它没有对象和继承的概念，也没有很多与面向对象相关的概念，例如多态和重载。</p>
<p>Go所具有的是结构体的概念，可以将一些方法和结构体关联。Go 还支持一种简单但有效的组合形式。  总的来说，它会使代码变的更简单，但在某一些场合，你会错过面向对象提供的一些特性。（值得指出的是，通过组合实现继承是一场古老的战斗呐喊，Go 是我用过的第一种坚定立场的语言，在这个问题上。）</p>
<p>虽然 Go 不会像你以前使用的面向对象语言一样，但是你会注意到结构的定义和类的定义之间有很多相似之处。下面的代码定义了一个简单的 <code>Saiyan</code> 结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Saiyan <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Power <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将看明白怎么往这个结构体添加一个方法，就像面向对象类，会有方法作为 它的一部分。在这之前，我们先要知道如何申明结构体。</p>
<h2 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h2><p>当我们第一次看到变量和声明时，我们只看了内置类型，比如整数和字符串。既然现在我们要讨论结构，那么我们需要扩展讨论范围到指针。</p>
<p>创建结构的值的最简单的方式是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">goku := Saiyan&#123;</span><br><span class="line">  Name: <span class="string">&quot;Goku&quot;</span>,</span><br><span class="line">  Power: <span class="number">9000</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注意：</em> 上述结构末尾的逗号 <code>,</code> 是必需的。没有它的话，编译器就会报错。你将会喜欢上这种必需的一致性，尤其当你使用一个与这种风格相反的语言或格式的时候。 </p>
<p>我们不必设置所有或哪怕一个字段。下面这些都是有效的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">goku := Saiyan&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line">goku := Saiyan&#123;Name: <span class="string">&quot;Goku&quot;</span>&#125;</span><br><span class="line">goku.Power = <span class="number">9000</span></span><br></pre></td></tr></table></figure>

<p>就像未赋值的变量其值默认为 0 一样，字段也是如此。</p>
<p>此外，你可以不写字段名，依赖字段顺序去初始化结构体 （但是为了可读性，你应该把字段名写清楚）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goku := Saiyan&#123;<span class="string">&quot;Goku&quot;</span>, <span class="number">9000</span>&#125;</span><br></pre></td></tr></table></figure>

<p>以上所有的示例都是声明变量 <code>goku</code> 并赋值。</p>
<p>许多时候，我们并不想让一个变量直接关联到值，而是让它的值为一个指针，通过指针关联到值。一个指针就是内存中的一个地址；指针的值就是实际值的地址。这是间接地获取值的方式。形象地来说，指针和实际值的关系就相当于房子和指向该房子的方向之间的关系。</p>
<p>为什么我们想要一个指针指向值而不是直接包含该值呢？这归结为 Go 中传递参数到函数的方式：就像复制。知道了这个，尝试理解一下下面的代码呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  goku := Saiyan&#123;<span class="string">&quot;Goku&quot;</span>, <span class="number">9000</span>&#125;</span><br><span class="line">  Super(goku)</span><br><span class="line">  fmt.Println(goku.Power)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Super</span><span class="params">(s Saiyan)</span></span> &#123;</span><br><span class="line">  s.Power += <span class="number">10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序运行的结果是 9000，而不是 19000,。为什么？因为 <code>Super</code> 修改了原始值 <code>goku</code> 的复制版本，而不是它本身，所以，<code>Super</code> 中的修改并不影响上层调用者。现在为了达到你的期望，我们可以传递一个指针到函数中： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  goku := &amp;Saiyan&#123;<span class="string">&quot;Goku&quot;</span>, <span class="number">9000</span>&#125;</span><br><span class="line">  Super(goku)</span><br><span class="line">  fmt.Println(goku.Power)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Super</span><span class="params">(s *Saiyan)</span></span> &#123;</span><br><span class="line">  s.Power += <span class="number">10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次，我们修改了两处代码。第一个是使用了 <code>&amp;</code> 操作符以获取值的地址（它就是 <em>取地址</em> 操作符）。然后，我们修改了 <code>Super</code> 参数期望的类型。它之前期望一个 <code>Saiyan</code> 类型，但是现在期望一个地址类型 <code>*Saiyan</code>，这里 <code>*X</code> 意思是 <em>指向类型 X 值的指针</em> 。很显然类型 <code>Saiyan</code> 和 <code>*Saiyan</code> 是有关系的，但是他们是不同的类型。</p>
<p>这里注意到我们仍然传递了一个 <code>goku</code> 的值的副本给 <code>Super</code>，但这时 <code>goku</code> 的值其实是一个地址。所以这个副本值也是一个与原值相等的地址，这就是我们间接传值的方式。想象一下，就像复制一个指向饭店的方向牌。你所拥有的是一个方向牌的副本，但是它仍然指向原来的饭店。</p>
<p>我们可以证实一下这是一个地址的副本，通过修改其指向的值（尽管这可能不是你真正想做的事情）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  goku := &amp;Saiyan&#123;<span class="string">&quot;Goku&quot;</span>, <span class="number">9000</span>&#125;</span><br><span class="line">  Super(goku)</span><br><span class="line">  fmt.Println(goku.Power)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Super</span><span class="params">(s *Saiyan)</span></span> &#123;</span><br><span class="line">  s = &amp;Saiyan&#123;<span class="string">&quot;Gohan&quot;</span>, <span class="number">1000</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，又一次地输出 9000。就像许多语言表现的那样，包括  Ruby，Python， Java 和 C#，Go 以及部分的 C#，只是让这个事实变得更明显一些。</p>
<p>同样很明显的是，复制一个指针比复制一个复杂的结构的消耗小多了。在 64 位的机器上面，一个指针占据 64 bit 的空间。如果我们有一个包含很多字段的结构，创建它的副本将会是一个很昂贵的操作。指针的真正价值在于能够分享它所指向的值。我们是想让 <code>Super</code> 修改 <code>goku</code> 的副本还是修改共享的 <code>goku</code> 值本身呢？</p>
<p>所有这些并不是说你总应该使用指针。这章末尾，在我们见识了结构的更多功能以后，我们将重新检视 指针与值这个问题。</p>
<h2 id="结构体上的函数"><a href="#结构体上的函数" class="headerlink" title="结构体上的函数"></a>结构体上的函数</h2><p>我们可以把一个方法关联在一个结构体上：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Saiyan <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Power <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Saiyan)</span> <span class="title">Super</span><span class="params">()</span></span> &#123;</span><br><span class="line">  s.Power += <span class="number">10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们可以这么理解，<code>*Saiyan</code> 类型是 <code>Super</code> 方法的<em>接受者</em>。然后我们可以通过下面的代码去调用 <code>Super</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">goku := &amp;Saiyan&#123;<span class="string">&quot;Goku&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">goku.Super()</span><br><span class="line">fmt.Println(goku.Power) <span class="comment">// 将会打印出 19001</span></span><br></pre></td></tr></table></figure>



<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>结构体没有构造器。但是，你可以创建一个返回所期望类型的实例的函数（类似于工厂）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSaiyan</span><span class="params">(name <span class="keyword">string</span>, power <span class="keyword">int</span>)</span> *<span class="title">Saiyan</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Saiyan&#123;</span><br><span class="line">    Name: name,</span><br><span class="line">    Power: power,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模式以错误的方式惹恼了很多开发人员。一方面，这里有一点轻微的语法变化；另一方面，它确实感觉有点不那么明显。</p>
<p>我们的工厂不必返回一个指针；下面的形式是完全有效的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSaiyan</span><span class="params">(name <span class="keyword">string</span>, power <span class="keyword">int</span>)</span> <span class="title">Saiyan</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Saiyan&#123;</span><br><span class="line">    Name: name,</span><br><span class="line">    Power: power,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="结构体的字段"><a href="#结构体的字段" class="headerlink" title="结构体的字段"></a>结构体的字段</h2><p>到目前为止的例子中，<code>Saiyan</code> 有两个字段 <code>Name</code> 和 <code>Power</code>，其类型分别为 <code>string</code> 和 <code>int</code>。字段可以是任何类型 – 包括其他结构体类型以及目前我们还没有提及的 array，maps，interfaces 和 functions 等类型。</p>
<p>例如，我们可以扩展 <code>Saiyan</code> 的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Saiyan <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Power <span class="keyword">int</span></span><br><span class="line">  Father *Saiyan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们通过下面的方式初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gohan := &amp;Saiyan&#123;</span><br><span class="line">  Name: <span class="string">&quot;Gohan&quot;</span>,</span><br><span class="line">  Power: <span class="number">1000</span>,</span><br><span class="line">  Father: &amp;Saiyan &#123;</span><br><span class="line">    Name: <span class="string">&quot;Goku&quot;</span>,</span><br><span class="line">    Power: <span class="number">9001</span>,</span><br><span class="line">    Father: <span class="literal">nil</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="New"><a href="#New" class="headerlink" title="New"></a>New</h2><p>尽管缺少构造器，Go 语言却有一个内置的 <code>new</code> 函数，使用它来分配类型所需要的内存。 <code>new(X)</code> 的结果与 <code>&amp;X&#123;&#125;</code> 相同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">goku := <span class="built_in">new</span>(Saiyan)</span><br><span class="line"><span class="comment">// same as</span></span><br><span class="line">goku := &amp;Saiyan&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用取决于你，但是你会发现大多数人更偏爱后一种写法无论是否有字段需要初始化，因为这看起来更具可读性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">goku := <span class="built_in">new</span>(Saiyan)</span><br><span class="line">goku.name = <span class="string">&quot;goku&quot;</span></span><br><span class="line">goku.power = <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vs</span></span><br><span class="line"></span><br><span class="line">goku := &amp;Saiyan &#123;</span><br><span class="line">  Name: <span class="string">&quot;goku&quot;</span>,</span><br><span class="line">  Power: <span class="number">9000</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论你选择哪一种，如果你遵循上述的工厂模式，就可以保护剩余的代码而不必知道或担心内存分配细节</p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>Go 支持组合， 这是将一个结构包含进另一个结构的行为。在某些语言中，这种行为叫做 特质 或者 混合。 没有明确的组合机制的语言总是可以做到这一点。在 Java 中， 可以使用 <em>继承</em> 来扩展结构。但是在脚本中并没有这种选项， 混合将会被写成如下形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Saiyan</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Saiyan 中包含着 person 对象</span></span><br><span class="line">  <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将请求转发到 person 中</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.person.getName();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可能会非常繁琐。<code>Person</code> 的每个方法都需要在 <code>Saiyan</code> 中重复。Go 避免了这种复杂性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">Introduce</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Hi, I&#x27;m %s\n&quot;</span>, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Saiyan <span class="keyword">struct</span> &#123;</span><br><span class="line">  *Person</span><br><span class="line">  Power <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用它</span></span><br><span class="line">goku := &amp;Saiyan&#123;</span><br><span class="line">  Person: &amp;Person&#123;<span class="string">&quot;Goku&quot;</span>&#125;,</span><br><span class="line">  Power: <span class="number">9001</span>,</span><br><span class="line">&#125;</span><br><span class="line">goku.Introduce()</span><br></pre></td></tr></table></figure>

<p><code>Saiyan</code>  结构体有一个 <code>Person</code> 类型的字段。由于我们没有显示地给它一个字段名，所以我们可以隐式地访问组合类型的字段和函数。然而，Go 编译器确实给了它一个字段，下面这样完全有效：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goku := &amp;Saiyan&#123;</span><br><span class="line">  Person: &amp;Person&#123;<span class="string">&quot;Goku&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(goku.Name)</span><br><span class="line">fmt.Println(goku.Person.Name)</span><br></pre></td></tr></table></figure>

<p>上面两个都打印 「Goku」。</p>
<p>组合比继承更好吗？许多人认为它是一种更好的组织代码的方式。当使用继承的时候，你的类和超类紧密耦合在一起，你最终专注于结构而不是行为。</p>
<h2 id="指针类型和值类型"><a href="#指针类型和值类型" class="headerlink" title="指针类型和值类型"></a>指针类型和值类型</h2><p>当你写 Go 代码的时候，很自然就会去问自己 <em>应该是值还是指向值的指针呢？</em> 这儿有两个好消息，首先，无论我们讨论下面哪一项，答案都是一样的：</p>
<ul>
<li>局部变量赋值</li>
<li> 结构体指针</li>
<li>函数返回值</li>
<li>函数参数</li>
<li>方法接收器</li>
</ul>
<p>第二，如果你不确定，那就用指针咯。</p>
<p>正如我们已经看到的，传值是一个使数据不可变的好方法（函数中改变它不会反映到调用代码中）。有时，这是你想要的行为，但是通常情况下，不是这样的。</p>
<p>即使你不打算改变数据，也要考虑创建大型结构体副本的成本。相反，你可能有一些小的结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">  X <span class="keyword">int</span></span><br><span class="line">  Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，复制结构的成本能够通过直接访问 <code>X</code> 和 <code>Y</code> 来抵消，而没有其它任何间接操作。</p>
<p>还有，这些案例都是很微妙的，除非你迭代成千上万个这样的指针，否则你不会注意到差异。</p>
<h2 id="继续之前-1"><a href="#继续之前-1" class="headerlink" title="继续之前"></a>继续之前</h2><p>从实际的角度看，这章介绍了结构体，如何使一个结构体的实例成为函数的接收者，以及添加指针到现有的 Go 类型系统知识中。下面的章节将建立在我们已经了解了什么是结构体以及其内部工作原理之上。</p>
<h1 id="第三章-·-映射、数组和切片"><a href="#第三章-·-映射、数组和切片" class="headerlink" title="第三章 · 映射、数组和切片"></a>第三章 · 映射、数组和切片</h1><p>至此，我们已经学了一部分简单的类型和结构。现在，让我们开始学习 Arrays （数组）, Slices （切片） 和 Maps （映射） 吧。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>如果你学过 Python , Ruby , Perl , JavaScript 或者 PHP （或者更多其它的语言），那么你肯定习惯 <em>动态数组</em> 编程啦。这些数组的长度可以在添加数据的时候自行调整的。在 Go 中，像其它大部分语言一样，数据的长度是固定的。我们在声明一个数组时需要指定它的长度，一旦指定了长度，那么它的长度值是不可以改变的了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scores [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">scores[<span class="number">0</span>] = <span class="number">339</span></span><br></pre></td></tr></table></figure>

<p>上面的数组最多可以容纳 10 个元素，索引是从 <code>scores[0]</code> 到 <code>scores[9]</code> 。试图访问超过界限的索引系统将会抛出编译或运行时错误。</p>
<p>我们可以在初始化数组的时候指定值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">9001</span>, <span class="number">9333</span>, <span class="number">212</span>, <span class="number">33</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用 <code>len</code> 函数来获取数组的长度。<code>range</code> 函数在遍历迭代的时候使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> scores &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组非常高效但是很死板。很多时候，我们在事前并不知道数组的长多是多少。针对这个情况，slices （切片） 出来了。</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>在Go语言中，我们很少直接使用数组。取而代之的是使用切片。切片是轻量的包含并表示数组的一部分的结构。 这里有几种创建切片的方式，我们来看看什么情况下使用它们。首先在数组的基础之上进行一点点变化:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">293</span>,<span class="number">4</span>,<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>

<p>和数组申明不同的是，我们的切片没有在方括号中定义长度。为了理解两者的不同，我们来看看另一种使用<code>make</code>来创建切片的方式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>我们使用 <code>make</code> 关键字代替 <code>new</code>， 是因为创建一个切片不仅是只分配一段内存（这个是 <code>new</code>关键字的功能）。具体来讲，我们必须要为一个底层数组分配一段内存，同时也要初始化这个切片。在上面的代码中，我们初始化了一个长度是 10 ，容量是 10 的切片。长度是切片的长度，容量是底层数组的长度。在使用 <code>make</code> 创建切片时，我们可以分别的指定切片的长度和容量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码创建了一个长度是 0 ，容量是 10 的切片。（如果你仔细观察的话，你会注意到 <code>make</code> 和 <code>len</code> <em>被</em>重载了。Go 的一些特性没有暴露出来给开发者使用，这也许会让你感到沮丧。）</p>
<p>为了更好的理解切片的长度和容量之间的关系，我们来看下面的的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">  scores[<span class="number">7</span>] = <span class="number">9033</span></span><br><span class="line">  fmt.Println(scores)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们上面的这个例子不能运行，为什么呢？因为切片的长度是 0 。没错，底层数组可以放 10 个元素，但是我们需要显式的扩展切片，才能访问到底层数组的元素。一种扩展切片的方式是通过 <code>append</code>的关键字来实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">  scores = <span class="built_in">append</span>(scores, <span class="number">5</span>)</span><br><span class="line">  fmt.Println(scores) <span class="comment">// prints [5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是那并没有改变原始代码的意图。追加一个值到长度为0的切片中将会设置第一个元素。无论什么原因，我们崩溃的代码想去设置索引为7的元素值。为了实现这个，我们可以重新切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">  scores = scores[<span class="number">0</span>:<span class="number">8</span>]</span><br><span class="line">  scores[<span class="number">7</span>] = <span class="number">9033</span></span><br><span class="line">  fmt.Println(scores)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以调整的切片大小最大范围是多少呢？达到它的容量，这个例子中，是10。你可能在想 <em>这实际上并没有解决数组固定长度的问题</em>。但是 <code>append</code> 是相当特别的。如果底层数组满了，它将创建一个更大的数组并且复制所有原切片中的值（这个就很像动态语言 PHP，Python，Ruby，JavaScript 的工作方式）。这就是为什么上面的例子中我们必须重新将 <code>append</code> 返回的值赋值给 <code>scores</code> 变量：<code>append</code> 可能在原有底层数组空间不足的情况下创建了新值。</p>
<p>如果我告诉你 Go 使用 2x 算法来增加数组长度，你猜下面将会打印什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">  c := <span class="built_in">cap</span>(scores)</span><br><span class="line">  fmt.Println(c)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">25</span>; i++ &#123;</span><br><span class="line">    scores = <span class="built_in">append</span>(scores, i)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果容量改变了</span></span><br><span class="line">    <span class="comment">// Go 必须增加数组长度来容纳新的数据</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span>(scores) != c &#123;</span><br><span class="line">      c = <span class="built_in">cap</span>(scores)</span><br><span class="line">      fmt.Println(c)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始 <code>scores</code> 的容量是5。为了存储25个值，它必须扩展三次容量，分别是 10，20，最终是40。</p>
<p>最后一个例子，考虑这个：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">  scores = <span class="built_in">append</span>(scores, <span class="number">9332</span>)</span><br><span class="line">  fmt.Println(scores)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里输出是 <code>[0, 0, 0, 0, 0, 9332]</code>，可能你觉得是<code>[9332, 0, 0, 0, 0]</code>？对一个用户而言，这可能逻辑上是正确的。然而，对于一个编译器，你告诉他的是追加一个值到一个已经有5个值的切片。</p>
<p>最终，这有四种方式初始化一个切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names := []<span class="keyword">string</span>&#123;<span class="string">&quot;leto&quot;</span>, <span class="string">&quot;jessica&quot;</span>, <span class="string">&quot;paul&quot;</span>&#125;</span><br><span class="line">checks := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> names []<span class="keyword">string</span></span><br><span class="line">scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>什么时候该用哪个呢？第一个不用过多解释。当你事先知道数组中的值的时候，你可以使用这个方式。</p>
<p>当你想要写入切片具体的索引时，第二个方法很有用，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extractPowers</span><span class="params">(saiyans []*Saiyans)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  powers := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(saiyans))</span><br><span class="line">  <span class="keyword">for</span> index, saiyan := <span class="keyword">range</span> saiyans &#123;</span><br><span class="line">    powers[index] = saiyan.Power</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> powers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三个版本是指向空的切片，用于当元素数量未知时与 <code>append</code> 连接。</p>
<p>最后一个版本是让我们声明一个初始的容量。如果我们大概知道元素的数量将是很有用的。</p>
<p>即使当你知道大小的时候，<code>append</code> 也可以使用，取决于个人偏好：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extractPowers</span><span class="params">(saiyans []*Saiyans)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  powers := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(saiyans))</span><br><span class="line">  <span class="keyword">for</span> _, saiyan := <span class="keyword">range</span> saiyans &#123;</span><br><span class="line">    powers = <span class="built_in">append</span>(powers, saiyan.Power)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> powers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片作为数组的包装是一个很强大的概念。许多语言有切片数组的概念。JavaScript 和 Ruby 数组都有一个  <code>slice</code> 方法。Ruby 中你可以使用 <code>[START..END]</code> 获取一个切片，或者 Python 中可以通过 <code>[START:END]</code> 实现。然而，在这些语言中，一个切片实际上是复制了原始值的新数组。如果我们使用 Ruby，下面这段代码的输出是什么呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scores = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">slice = scores[<span class="number">2.</span><span class="number">.4</span>]</span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">999</span></span><br><span class="line">puts scores</span><br></pre></td></tr></table></figure>

<p>答案是  <code>[1, 2, 3, 4, 5]</code> 。那是因为 <code>slice</code> 是一个新数组，并且复制了原有的值。现在，考虑 Go 中的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scores := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">slice := scores[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">999</span></span><br><span class="line">fmt.Println(scores)</span><br></pre></td></tr></table></figure>

<p>输出是  <code>[1, 2, 999, 4, 5]</code>。</p>
<p>这改变了你编码的方式。例如，许多函数采用一个位置参数。JavaScript 中，如果你想去找到字符串中前五个字符后面的第一个空格（当然，在Go中切片也可以用于字符串），我们会这样写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">haystack = <span class="string">&quot;the spice must flow&quot;</span>;</span><br><span class="line">console.log(haystack.indexOf(<span class="string">&quot; &quot;</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<p>在 Go 中，我们这样使用切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Index(haystack[<span class="number">5</span>:], <span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以从上面的例子中看到，<code>[X:]</code> 是 <em>从 X 到结尾</em> 的简写，然而 <code>[:X]</code> 是 <em>从开始到 X 的简写</em>。不像其他的语言，Go 不支持负数索引。如果我们想要切片中除了最后一个元素的所有值，可以这样写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">scores = scores[:<span class="built_in">len</span>(scores)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>上面是从未排序的切片中移除元素的有效方法的开始：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scores := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  scores = removeAtIndex(scores, <span class="number">2</span>)</span><br><span class="line">  fmt.Println(scores) <span class="comment">// [1 2 5 4]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会保持顺序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeAtIndex</span><span class="params">(source []<span class="keyword">int</span>, index <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  lastIndex := <span class="built_in">len</span>(source) - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 交换最后一个值和想去移除的值</span></span><br><span class="line">  source[index], source[lastIndex] = source[lastIndex], source[index]</span><br><span class="line">  <span class="keyword">return</span> source[:lastIndex]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们已经了解了切片，我们再看另一个通用的内建函数：<code>copy</code>。正常情况下，将值从一个数组复制到另一个数组的方法有5个参数，<code>source</code>， <code>sourceStart</code>，<code>count</code>,，<code>destination</code>  和 <code>destinationStart</code>。使用切片，我们仅仅需要两个：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">  <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    scores[i] = <span class="keyword">int</span>(rand.Int31n(<span class="number">1000</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  sort.Ints(scores)</span><br><span class="line"></span><br><span class="line">  worst := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">  <span class="built_in">copy</span>(worst, scores[:<span class="number">5</span>])</span><br><span class="line">  fmt.Println(worst)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>花点时间试试上面的代码，并尝试改动。去看看如果你这么做  <code>copy(worst[2:4], scores[:5])</code> 或者复制多于或少于 <code>5</code> 个值给 <code>worst</code> 会发什么？</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>Go语言中的映射，就好比其他语言中的hash表或者字典。它们的工作方式就是：定义键和值，并且可以获取，设置和删除其中的值。</p>
<p>映射和切片一样，使用 <code>make</code> 方法来创建。让我们来看看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  lookup := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">  lookup[<span class="string">&quot;goku&quot;</span>] = <span class="number">9001</span></span><br><span class="line">  power, exists := lookup[<span class="string">&quot;vegeta&quot;</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prints 0, false</span></span><br><span class="line">  <span class="comment">// 0 is the default value for an integer</span></span><br><span class="line">  fmt.Println(power, exists)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用 <code>len</code>方法类获取映射的键的数量。使用<code>delete</code>方法来删除一个键对应的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// returns 1</span></span><br><span class="line">total := <span class="built_in">len</span>(lookup)</span><br><span class="line"></span><br><span class="line"><span class="comment">// has no return, can be called on a non-existing key</span></span><br><span class="line"><span class="built_in">delete</span>(lookup, <span class="string">&quot;goku&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>映射是动态变化的。然而我们可以通过传递第二个参数到 <code>make</code>方法来设置一个初始大小：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lookup := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>如果你事先知道映射会有多少键值，定义一个初始大小将会帮助改善性能。</p>
<p>当你需要将映射作为结构体字段的时候，你可以这样定义它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Saiyan <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Friends <span class="keyword">map</span>[<span class="keyword">string</span>]*Saiyan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始上述结构体的一种方式是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goku := &amp;Saiyan&#123;</span><br><span class="line">  Name: <span class="string">&quot;Goku&quot;</span>,</span><br><span class="line">  Friends: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Saiyan),</span><br><span class="line">&#125;</span><br><span class="line">goku.Friends[<span class="string">&quot;krillin&quot;</span>] = ... <span class="comment">//加载或者创建 Krillin</span></span><br></pre></td></tr></table></figure>

<p>Go 还有一种定义和初始化值的方式。像 <code>make</code>，这种特定用于映射和数组。我们可以定义为复合方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lookup := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">  <span class="string">&quot;goku&quot;</span>: <span class="number">9001</span>,</span><br><span class="line">  <span class="string">&quot;gohan&quot;</span>: <span class="number">2044</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用 <code>for</code> 组合 <code>range</code> 关键字迭代映射：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> lookup &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代映射是没有顺序的。每次迭代查找将会随机返回键值对。</p>
<h2 id="指针和值"><a href="#指针和值" class="headerlink" title="指针和值"></a>指针和值</h2><p>第二章我们讨论了到底是传值还是传指针。现在我们有相同的问题在映射和数组上，到底该使用他们哪个？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]Saiyan, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">b := <span class="built_in">make</span>([]*Saiyan, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>许多开发者认为应该传递 <code>b</code> 或者返回它在一个函数中会更加高效。然而，传递/返回的是切片的副本，但是切片本身就是一个引用。所以传递返回切片本身，没有什么区别。</p>
<p>当你改变切片或者映射值的时候，你将看到不同。这一点上，和我们在第二章看到的逻辑相同。所以决定使用指针数组还是值数组归结为你如何使用单个值，而不是你用数组还是映射。</p>
<h2 id="继续之前-2"><a href="#继续之前-2" class="headerlink" title="继续之前"></a>继续之前</h2><p>Go 中数组和映射的工作方式类似于其他语言。如果你习惯了使用动态数组，这可能就有点小的调整，但是 <code>append</code> 应该能解决你大多的不适应。如果我们超越数组的表面语法，将会发现切片。切片功能强大，并且他们对代码的清晰度产生了巨大的影响。</p>
<p>还有一些边缘情况没有覆盖到，不过你不太可能遇到他们。即使遇到了，希望我们在这里建立的基础帮助你理解正在发生的事情。</p>
<h1 id="第四章-·-代码组织和接口"><a href="#第四章-·-代码组织和接口" class="headerlink" title="第四章 · 代码组织和接口"></a>第四章 · 代码组织和接口</h1><p>现在来看一下如何组织我们的代码。</p>
<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>为了组织复杂的库和系统代码，我们需要学习关于包的知识。在 Go 语言中，包名遵循 Go 项目的目录结构。如果我们建立一个购物系统，我们可能以 “shopping” 包名作为一个开始，然后把所有源代码文件放到 <code>$GOPATH/src/shopping/</code> 目录中。</p>
<p>我们不会去想把所有东西都放在这个文件夹中。例如，我们可能想单独把数据库逻辑放在它自己的目录中。为了实现这个，我们创建一个子目录 <code>$GOPATH/src/shopping/db</code> 。子目录中文件的包名就是 <code>db</code>，但是为了从另一个包访问它，包括 <code>shopping</code> 包，我们需要导入 <code>shopping/db</code>。</p>
<p>换句话说，当你想去命名一个包的时候，可以通过 <code>package</code> 关键字，提供一个值，而不是完整的层次结构（例如：「shopping」或者 「db」）。当你想去导入一个包的时候，你需要指定完整路径。</p>
<p>接下来，我们去尝试下。在你的 Go 的工作目录 <code>src</code> 文件夹下（我们已经在<em>基础</em>那一章节中介绍了），创建一个新的文件夹叫做 <code>shopping</code> ，然后在 <code>shopping</code> 文件夹下创建一个 <code>db</code> 文件夹。</p>
<p>在 <code>shopping/db</code> 文件夹下，创建一个叫做 <code>db.go</code> 的文件，然后在 <code>db.go</code> 文件中添加如下的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">  Price <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadItem</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">Item</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Item&#123;</span><br><span class="line">    Price: <span class="number">9.001</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意包名和文件夹名是一样的。而且很明显我们实际并没有连接数据库。这里使用这个例子只是为了展示如何组织代码。</p>
<p>现在，创建在主目录 <code>shopping</code> 下创建一个叫 <code>pricecheck.go</code> 的文件。它的内容是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shopping</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;shopping/db&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PriceCheck</span><span class="params">(itemId <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  item := db.LoadItem(itemId)</span><br><span class="line">  <span class="keyword">if</span> item == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> item.Price, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很有可能认为导入  <code>shopping/db</code>  有点特别，因为我们已经在 <code>shopping</code> 包/目录中。实际上，我们正在导入 <code>$GOPATH/src/shopping/db</code>，这意味着只要你在你的工作区间  <code>src/test</code> 目录中有一个名为 <code>db</code>  的包，你就可以轻松导入它。</p>
<p>你正在构建一个包，除了我们看到的你不再需要任何东西。为了构建一个可执行程序，你仍然需要 <code>main</code> 包。我比较喜欢的方式是在 <code>shopping</code> 目录下创建一个 <code>main</code> 子目录，然后再创建一个叫 <code>main.go</code> 的文件，下面是它的内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;shopping&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(shopping.PriceCheck(<span class="number">4343</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，你可以进入你的 <code>shopping</code>  项目运行代码，输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main&#x2F;main.go</span><br></pre></td></tr></table></figure>

<h3 id="循环导入"><a href="#循环导入" class="headerlink" title="循环导入"></a>循环导入</h3><p>当你编写更复杂的系统的时，你必然会遇到循环导入。例如，当 <code>A</code> 包导入 <code>B</code> 包，<code>B</code> 包又导入 <code>A</code> 包（间接或者直接导入）。这是编译器不能允许的。</p>
<p>让我们改变我们的 <code>shopping</code> 结构以复现这个错误。</p>
<p>将  <code>Item</code> 定义从 <code>shopping/db/db.go</code> 移到 <code>shopping/pricecheck.go</code>。你的 <code>pricecheck.go</code> 文件像下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shopping</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;shopping/db&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">  Price <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PriceCheck</span><span class="params">(itemId <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  item := db.LoadItem(itemId)</span><br><span class="line">  <span class="keyword">if</span> item == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> item.Price, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你尝试运行代码，你会从 <code>db/db.go</code> 得到两个关于 <code>Item</code>  未定义的错误。这看起来是说  <code>Item</code> 不存在  <code>db</code> 包中。它已经被移动到 <code>shopping</code> 包中，我们需要将 <code>shopping/db/db.go</code> 改变成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;shopping&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadItem</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">shopping</span>.<span class="title">Item</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;shopping.Item&#123;</span><br><span class="line">    Price: <span class="number">9.001</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在但你尝试运行代码的时候，你将会得到 <em>不允许循环导入</em> 的错误。我们可以通过引入另一个包含共享结构体的包来解决这个问题。你的目录现在看起来像这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$GOPATH&#x2F;src</span><br><span class="line">  - shopping</span><br><span class="line">    pricecheck.go</span><br><span class="line">    - db</span><br><span class="line">      db.go</span><br><span class="line">    - models</span><br><span class="line">      item.go</span><br><span class="line">    - main</span><br><span class="line">      main.go</span><br></pre></td></tr></table></figure>

<p><code>pricecheck.go</code> 将仍然导入 <code>shopping/db</code>，但是 <code>db.go</code> 现在导入  <code>shopping/models</code> 而不是 <code>shopping</code>，因此打破了循环。因为我们将共享的  <code>Item</code> 结构体移动到  <code>shopping/models/item.go</code>，我们现在需要去改变  <code>shopping/db/db.go</code> 从 <code>models</code> 包中引用  <code>Item</code>  结构体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;shopping/models&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadItem</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">models</span>.<span class="title">Item</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;models.Item&#123;</span><br><span class="line">    Price: <span class="number">9.001</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你经常需要共享某些代码，不止 <code>models</code>，所以你可能有其他类似叫做 <code>utilities</code> 的目录，这些共享包的重要原则是他们不从 <code>shopping</code> 包或者任何子包中导入任何东西。在后面的章节中，我们将介绍可以帮助我们解决这些类型依赖关系的接口。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>Go 用了一个简单的规则去定义什么类型和函数可以包外可见。如果类型或者函数名称以一个大写字母开始，它就具有了包外可见性。如果以一个小写字母开始，它就不可以。</p>
<p>这也可以应用到结构体字段。如果一个字段名以一个小写字母开始，只有包内的代码可以访问他们。</p>
<p>例如，我们的 <code>items.go</code> 文件中有个这样的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewItem</span><span class="params">()</span> *<span class="title">Item</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以通过  <code>models.NewItem()</code> 这样被调用。但是如果函数命名为 <code>newItem</code>，我们将不能从不同的包访问它了。</p>
<p>去试试更改 <code>shopping</code> 代码中的函数，类型以及字段的名称。例如，如果你将 <code>Item</code> 的 <code>Price</code>  字段命名为 <code>price</code>，你应该会获得一个错误。</p>
<h3 id="包管理-1"><a href="#包管理-1" class="headerlink" title="包管理"></a>包管理</h3><p>我们用来 <code>build</code> 和 <code>run</code> 的 <code>go</code> 命令有一个 <code>get</code> 子命令，用于获取第三方库。<code>go get</code> 支持除了这个例子中的各种协议，我们可以从 Github 中获取一个库，意味着，你需要在你的电脑中安装 <code>git</code>。</p>
<p>假设你已经安装了 Git，在 shell 中输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;mattn&#x2F;go-sqlite3</span><br></pre></td></tr></table></figure>

<p><code>go get</code> 获取远端的文件并把它们存储在你的工作区间中。去看看你的 <code>$GOPATH/src</code> 目录，你会发现除了我们创建的 <code>shopping</code>  项目之外，还有一个 <code>github.com</code> 目录，在里面，你会看到一个包含了 <code>go-sqlite3</code> 目录的  <code>mattn</code> 目录。</p>
<p>我们刚才只是讨论了如何导入我们工作区间的包。为了导入新安装的 <code>go-sqlite3</code> 包，我们要这样导入：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/mattn/go-sqlite3&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我知道这看起来像一个 URL，实际上，它只是希望导入在 <code>$GOPATH/src/github.com/mattn/go-sqlite3</code> 找到的 <code>go-sqlite3</code> 包。</p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p><code>go get</code>  还有一些其他的技巧。如果我们在一个项目内使用 <code>go get</code>，它将浏览所有文件，查找 <code>imports</code> 的第三方库然后下载他们。某种程度上，我们的源代码变成了  <code>Gemfile</code> 或者  <code>package.json</code>。</p>
<p>如果你调用  <code>go get -u</code> ，它将更新所有包（或者你可以通过 <code>go get -u FULL_PACKAGE_NAME</code> 更新一个具体的包）。</p>
<p>最后，你可能发现了 <code>go get</code> 的不足。一方面，这儿没有办法指定一个版本。他总是指向 <code>master/head/trunk/default</code>。这是一个较大的问题如果你有两个项目需要同一个库的不同版本。</p>
<p>为了解决这个问题，你可以使用一个第三方的依赖管理工具。他们仍然很年轻，但 <a target="_blank" rel="noopener" href="https://github.com/nitrous-io/goop">goop</a> 和 <a target="_blank" rel="noopener" href="https://github.com/tools/godep">godep</a> 是可信的。更多完整的列表在 <a target="_blank" rel="noopener" href="https://code.google.com/p/go-wiki/wiki/PackageManagementTools">go-wiki</a>。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是定义了合约但并没有实现的类型。举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">interface</span> &#123;</span><br><span class="line">  Log(message <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那这样做有什么作用呢？其实，接口有助于将代码与特定的实现进行分离。例如，我们可能有各种类型的日志记录器：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SqlLogger <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">type</span> ConsoleLogger <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">type</span> FileLogger <span class="keyword">struct</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>针对接口而不是具体实现的编程会使我们很轻松的修改（或者测试）任何代码都不会产生影响。</p>
<p>你会怎么用？就像任何其它类型一样，它结构可以这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">  logger Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者是一个函数参数（或者返回值）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(logger Logger)</span></span> &#123;</span><br><span class="line">  logger.Log(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在像 C# 或者 Java 这类语言中，当类实现接口时，我们必须显式的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ConsoleLogger : Logger &#123;</span><br><span class="line">  public void Logger(message <span class="keyword">string</span>) &#123;</span><br><span class="line">    Console.WriteLine(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Go 中，下面的情况是隐式发生的。如果你的结构体有一个函数名为 <code>Log</code> 且它有一个 <code>string</code> 类型的参数并没有返回值，那么这个结构体被视为 <code>Logger</code> 。这减少了使用接口的冗长：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConsoleLogger <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l ConsoleLogger)</span> <span class="title">Log</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 倾向于使用<strong>小</strong>且<strong>专注</strong>的接口。Go 的标准库基本上由接口组成。像 <code>io</code> 包有一些常用的接口诸如 <code>io.Reader</code> ， <code>io.Writer</code> ， <code>io.Closer</code> 等。如果你编写的函数只需要一个能调用 <code>Close()</code> 的参数，那么你应该接受一个 <code>io.Closer</code> 而不是像 <code>io</code> 这样的父类型。<br>接口可以成为其他接口的一部分，也就是说接口也可以与其他接口组成新的接口。例如， <code>io.ReadCLoser</code> 的接口是由 <code>io.Reader</code> 接口和 <code>io.Closer</code> 接口组成的。</p>
<p>最后，接口通常用于避免循环导入。由于它们没有具体的实现，因此它们的依赖是有限的。</p>
<h2 id="继续之前-3"><a href="#继续之前-3" class="headerlink" title="继续之前"></a>继续之前</h2><p>最后，如何围绕 Go 的工作区间构建你的代码，你只有在写了几个非测试的项目之后才会适应。最重要的是记着包名和目录结构之间的紧密关系（不仅仅在一个项目之内，而是整个工作区间）。</p>
<p>Go 处理类型可见性也是简单有效，而且也是一致的。有一些我们没看过的东西，比如常量和全局变量，但是放心，他们的可见性仍有相同的命名规则决定。</p>
<p>最后，如果你初次接触接口，你可能需要花点时间理解他们。然而，当你第一次看到一个期望类似  <code>io.Reader</code> 的函数时，你会发现自己很感谢作者没有要求他或者她需要的东西。</p>
<h1 id="第五章-·-花絮"><a href="#第五章-·-花絮" class="headerlink" title="第五章 · 花絮"></a>第五章 · 花絮</h1><p>这章中，我们将讨论 Go 功能杂记，放在其他地方都不太合适。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>Go 首选错误处理方式是返回值，而不是异常。考虑 <code>strconv.Atoi</code> 函数，它将接受一个字符串然后将它转换为一个整数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  n, err := strconv.Atoi(os.Args[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;not a valid number&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以创建你自己的错误类型。唯一的要求是你必须实现内建 <code>error</code> 接口的契约：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">  Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更一般地，我们可以通过导入 <code>error</code> 包然后使用它的 <code>New</code> 函数创建我们自己的错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(count <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> count &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;Invalid count&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 标准库中有一个使用 error 变量的通用模式。例如， <code>io</code> 包中有一个 <code>EOF</code> 变量它是这样定义的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EOF = errors.New(<span class="string">&quot;EOF&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这是一个包级别的变量（被定义在函数之外），可以被其他包访问（首字母大写）。各种函数可以返回这个错误，例如，当我们从一个文件或者 STDIN 读取时。如果它具有上下文意义，那么您应该使用此错误。作为调用者，我们可以这样使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> input <span class="keyword">int</span></span><br><span class="line">  _, err := fmt.Scan(&amp;input)</span><br><span class="line">  <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;no more input!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为最后一点，Go 确实有  <code>panic</code>  和  <code>recover</code>  函数。 <code>panic</code>  就像抛出异常，而 <code>recover</code> 就像 <code>catch</code>，它们很少使用。</p>
<h2 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h2><p>尽管 Go 有一个垃圾回收器，一些资源仍然需要我们显示地释放他们。例如，我们需要在使用完文件之后  <code>Close()</code>  他们。这种代码总是很危险。一方面来说，当我们在写一个函数的时候，很容易忘记关闭我们声明了 10 行的东西。另一方面，一个函数可能有多个返回点。Go 给出的解决方案是使用 <code>defer</code> 关键字：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file, err := os.Open(<span class="string">&quot;a_file_to_read&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  <span class="comment">// 读取文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你尝试运行上面的代码，你将会得到错误（文件不存在）。这里只是演示 <code>defer</code> 如何工作。无论什么情况，在函数返回之后（本例中为 <code>main()</code> ），<code>defer</code> 将被执行。这使您可以在初始化的位置附近释放资源并处理多个返回点。</p>
<h2 id="go语言风格"><a href="#go语言风格" class="headerlink" title="go语言风格"></a>go语言风格</h2><p>大多数 Go 程序遵循相同的格式化规则，换句话说，一个 tab 键用于缩进，左括号和他们的声明语句在同一行。</p>
<p>我知道，你可能有自己的风格，并且想坚持它。这也是我长期以来所做的事情，但我很高兴我最终放弃了。一个大原因是  <code>go fmt</code> 命令。它易于使用而且具有权威性（所以就没有人争论无意义的偏好）。</p>
<p>当你在一个项目内的时候，你可以运用格式化规则到这个项目及其所有子目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go fmt .&#x2F;...</span><br></pre></td></tr></table></figure>

<p>试一试，它不仅缩进你的代码，也对齐了声明的字段和按字母书序导入。</p>
<h2 id="初始化的-if"><a href="#初始化的-if" class="headerlink" title="初始化的 if"></a>初始化的 if</h2><p>Go 对 <code>if</code> 语句做了稍微修改，支持在条件语句被求值之前先进行初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x := <span class="number">10</span>; count &gt; x &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个比较蠢的例子，更现实的是，你可能会像下面这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := process(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有意思的是，虽然 <code>err</code> 不能在 <code>if</code> 语句之外使用，但他可以在任何  <code>else if</code>  或者  <code>else</code> 之内使用。</p>
<h2 id="空接口和转化"><a href="#空接口和转化" class="headerlink" title="空接口和转化"></a>空接口和转化</h2><p>在大多数面向对象的语言中，经常有一个内建的叫 <code>object</code> 的基类，是所有其他类的超类。Go 没有继承，也没有这样一个超类。不过他确实有一个没有任何方法的空接口： <code>interface&#123;&#125;</code>。因为空接口没有方法，可以说所有类型都实现了空接口，并且由于空接口是隐式实现的，因此每种类型都满足空接口契约。</p>
<p> 如果我们像，我们可以定义如下签名的 <code>add</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了将一个接口变量转化为一个显式的类型，又可以用 <code>.(TYPE)</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> a.(<span class="keyword">int</span>) + b.(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>提醒，如果底层类型不是 <code>int</code>，上面的结果将是 error。</p>
<p>你也可以访问强大的类型转换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> a.(<span class="keyword">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;a is now an int and equals %d\n&quot;</span>, a)</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">bool</span>, <span class="keyword">string</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你将会看到，使用空接口可能超出了你的期望。但是虽然它将让代码看起来不那么好看，来回转换代码有时看起来也很丑陋并且危险，但在一个静态语言中，它是唯一的选择。</p>
<h2 id="字符串和字节数组"><a href="#字符串和字节数组" class="headerlink" title="字符串和字节数组"></a>字符串和字节数组</h2><p>字符串和字节数组是紧密相关的。我们可以轻松地在他们之间转换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stra := <span class="string">&quot;the spice must flow&quot;</span></span><br><span class="line">byts := []<span class="keyword">byte</span>(stra)</span><br><span class="line">strb := <span class="keyword">string</span>(byts)</span><br></pre></td></tr></table></figure>

<p>实际上，这种转换方式在各种类型之间是通用的。一些函数显示地需要一个  <code>int32</code> 或者  <code>int64</code> 或者它们的无符号部分。你可能发现你必须这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64</span>(count)</span><br></pre></td></tr></table></figure>

<p>然而，当它涉及到字节和字符串时，这可能是你经常做的事情。一定记着当你使用 <code>[]byte(X)</code> 或者 <code>string(X)</code> 时，你实际上创建了数据的副本。这是必要的，因为字符串是不可变的。</p>
<p>那些由 Unicode 码点 <code>runes</code> 构成的字符串，如果你获取字符串的长度，你可能不能得到你期望的。下面的结果是3：</p>
<pre><code>fmt.Println(len(&quot;椒&quot;))
</code></pre>
<p>如果你用 <code>range</code> 迭代一个字符串，你将得到 runes，而不是字节。当然，当你将字符串转换为 <code>[]byte</code> 类型时，你将得到正确的数据。 </p>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>函数是一种类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Add <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<p>它可以用在任何地方 – 作为字段类型，参数或者返回值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Add <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(process(<span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(adder Add)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> adder(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样使用函数会帮助我们从具实现中解耦代码，更像在使用接口实现。</p>
<h2 id="继续之前-4"><a href="#继续之前-4" class="headerlink" title="继续之前"></a>继续之前</h2><p>我们研究了使用 Go 编程的各个方面，最值得注意的是，我们看到了错误的处理行为以及如何释放连接和打开的文件资源。许多人不喜欢 Go 的错误处理方法。这感觉像是倒退了一步。 有时，我同意。然而，我也发现这会让代码更容易理解。 <code>defer</code> 是一种不寻常但是实用的资源管理方法。事实上，它不仅限于资源管理。您可以将  <code>defer</code> 用于任何目的， 比如函数退出时的日志记录。</p>
<p>当然，我们还没有看到 Go 提供的所有花絮，但在你解决遇到的任何问题时你应该感到足够舒服。</p>
<h1 id="第六章-·-并发"><a href="#第六章-·-并发" class="headerlink" title="第六章 · 并发"></a>第六章 · 并发</h1><p>Go 通常被描述为一种并发友好的语言。 原因是它提供了两种强大机制的简单语法： <strong>协程</strong> 和 <strong>通道</strong></p>
<h2 id="Go协程"><a href="#Go协程" class="headerlink" title="Go协程"></a>Go协程</h2><p> <strong>协程</strong> 类似于一个线程，但是由 Go 而不是操作系统预定。在 <strong>协程</strong> 中运行的代码可以与其他代码同时运行。我们来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">  <span class="keyword">go</span> process()</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">10</span>) <span class="comment">// this is bad, don&#x27;t do this!</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;processing&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一些有趣的事情， 但最重要的是我们如何开始一个 <strong>协程</strong> 。 我们只需使用 <code>go</code> 关键字，然后使用我们想要执行的函数。如果我们只想运行一部分代码， 如上所述， 我们可以使用匿名函数。需要注意的是，匿名函数不只是可以在 <strong>协程</strong> 中使用，其他地方也可以。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;processing&quot;</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p> <strong>协程</strong> 易于创建且开销很小。最终多个 <strong>协程</strong> 将会在同一个底层的操作系统线程上运行。这通常也称为 M:N 线程模型，因为我们有 M 个应用线程（ <strong>协程</strong> ）运行在 N 个操作系统线程上。结果就是，一个 <strong>协程</strong> 的开销和系统线程比起来相对很低（几KB）。在现代的硬件上，有可能拥有数百万个 <strong>协程</strong> 。</p>
<p>此外，这里还隐藏了映射和调度的复杂性。我们只需要说 <em>这段代码需要同时并发执行</em> 然后让 Go 自己去实现它。</p>
<p>如果我们回到我们的例子中，你将会注意到我们使用 <code>Sleep</code> 让程序等了几毫秒。这是因为主进程在退出前 <strong>协程</strong> 才会有机会去执行（主进程在退出前不会等待全部 <strong>协程</strong> 执行完毕）。要解决这个问题，我们需要协调我们的代码。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>创建一个协程是微不足道的， 它们开销很小我们可以启动很多； 但是，需要协调并发代码。为了解决这个问题， Go 提供了 <code>通道</code>。 在我们学习 <code>通道</code> 之前，我认为了解并发编程的基础知识非常重要。</p>
<p>编写并发代码要求您特别注意在哪里读取和写入一个值。 在某些方面， 例如没有垃圾回收的语言 – 它需要您从一个新的角度去考虑您的数据，始终警惕着可能存在的危险。 例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> incr()</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">()</span></span> &#123;</span><br><span class="line">  counter++</span><br><span class="line">  fmt.Println(counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你觉得将会输出什么呢？</p>
<p>如果你认为输出的是 <code>1, 2, ... 20</code> 这既不对也没错。如果你运行了以上的代码确实可能得到这个输出。可是，这个操作就很让人懵逼的。 啥？因为我们可能有多个 (这个情况下两个) 协程 同时写入一个相同变量 <code>counter</code> 。或者，同样糟糕的是，一个协程要读取  <code>counter</code> 时，另一个协程正在写入。</p>
<p>这个真的很危险吗？当然啦！ <code>counter++</code> 看起来可能是一行很简单的代码，但它是实际上被拆分为多个汇编语句 – 确切的性质依赖于你跑程序的平台。如果你运行这个例子，你将经常看到那些数字是以一种乱七八糟的顺序打印的，亦或数字是重复的/丢失的。别着急还会有更糟糕的情况， 比方说系统崩溃或者访问并增加任意区块的数据！</p>
<p>从变量中读取变量是唯一安全的并发处理变量的方式。 你可以有想要多少就多少的读取者， 但是写操作必须要得同步。 有太多的方法可以做到这个了，包括使用一些依赖于特殊的 CPU 指令集的真原子操作。然而, 常用的操作还是使用互斥量（译者注：mutex）:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  counter = <span class="number">0</span></span><br><span class="line">  lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> incr()</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">()</span></span> &#123;</span><br><span class="line">  lock.Lock()</span><br><span class="line">  <span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">  counter++</span><br><span class="line">  fmt.Println(counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>互斥量序列化会锁住锁下的代码访问。因为默认的的 <code>sync.Mutex</code> 是未锁定状态，这儿我们就得先定义  <code>lock sync.Mutex</code>。</p>
<p>这操作是不看着超简单？ 这个例子是具有欺骗性的。当我们进行并发编程时会产生一系列严重的 Bug。 首先，并不是经常能很明显知道什么代码需要保护。使用这样粗糙的锁操作（覆盖着大量代码的锁操作）确实很诱人，这就违背了我们当初进行并发编程的初心了。 我们肯定是需要个优雅的锁操作； 否则，我们最终会把多条快速通道走成单车道的。</p>
<p>另外一个问题是与死锁有关。 使用单个锁时，这没有问题，但是如果你在代码中使用两个或者更多的锁，很容易出现一种危险的情况，当协程A拥有锁 <strong>lockA **，想去访问锁 **lockB **，同时协程B拥有锁 **lockB</strong> 并需要访问锁 <strong>lockA</strong> 。</p>
<p>实际上我们使用一个锁时也有可能发生死锁的问题，就是当我们忘记释放它时。 但是这和多个锁引起的死锁行为相比起来，这并不像多锁死锁那样危险（因为这<em>真的</em> 很难发现），当你试着运行下面的代码时，您可以看见发生了什么：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; lock.Lock() &#125;()</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">  lock.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到现在为止还有很多并发编程我们没有看到过。 首先，有一个常见的锁叫读写互斥锁。它主要提供了两种锁功能: 一个锁定读取和一个锁定写入。它的区别是允许多个同时读取，同时确保写入是独占的。在 Go 中， <code>sync.RWMutex</code> 就是这种锁。另外 <code>sync.Mutex</code> 结构不但提供了<code>Lock</code> 和 <code>Unlock</code> 方法 ，也提供了<code>RLock</code> 和 <code>RUnlock</code> 方法；其中 <code>R</code> 代表 <em>Read</em>.。虽然读写锁很常用，它也给开发人员带来了额外的负担：我们不但要关注我们正在访问的数据，还要注意如何访问。</p>
<p>此外，部分并发编程不只是通过为数不多的代码按顺序的访问变量； 它也需要协调多个协程。 例如，休眠10毫秒并不是一个特别优雅的解决方案。如果一个协程消耗的时间需要超过10毫秒怎么办？如果协程消耗更少的时间而我们浪费周期怎么办？又或者可以等待协程运行完毕， 我们想另外一个协程 <em>嗨， 我有新的数据需要你处理</em>?</p>
<p>这些事在没有 <code>通道</code> 的情况下都是可以完成的。当然对于更简单的情况，我相信你应该 <strong>应该</strong> 使用基本的功能比如 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code>， 但正如我们将会在下一节中看到的那样， <code>通道</code> 旨在让并发编程更简洁和不容易出错。</p>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>并发编程的最大调整源于数据的共享。如果你的协程间不存在数据共享，你完全没必要担心同步问题。但是并非所有系统都是如此简单。现实中，许多系统考虑了相反的目的：跨多个请求共享数据。内存缓存和数据库就是最好的例证。这种情况已经成为一个日趋增长的现实。</p>
<p>通道在共享不相关数据的情况下，让并发编程变得更健壮。通道是协程之间用于传递数据的共享管道。换而言之，一个协程可以通过一个通道向另外一个协程传递数据。因此，在任意时间点，只有一个协程可以访问数据。</p>
<p>一个通道，和其他任何变量一样，都有一个类型。这个类型是在通道中传递的数据的类型。例如，创建一个通道用于传递一个整数，我们要这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>这个通道的类型是 <code>chan int</code>。因此，要将通道传递给函数，我们的函数签名看起来是这个样子的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>通道只支持两个操作：接收和发送。可以这样往通道发送一个数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANNEL &lt;- DATA</span><br></pre></td></tr></table></figure>

<p>这样从通道接收数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VAR :&#x3D; &lt;-CHANNEL</span><br></pre></td></tr></table></figure>

<p>箭头预示着数据流向。当发送的时候，数据流向通道。接收的时候，数据流出通道。</p>
<p>在我们开始第一个例子之前还需要知道的是，接收和发送操作是阻塞的。也就是，当我们从一个通道接收的时候， goroutine 将会直到数据可用才会继续执行。类似地，当我们往通道发送数据的时候，goroutine 会等到数据接收到之后才会继续执行。</p>
<p>考虑这样一个系统，我们希望在各个 goroutine 中处理即将到来的数据。这是一个很平常的需求。如果我们在接收数据的 goroutine 上进行数据密集型处理，那么我们可能导致客户端超时。首先，我们先实现我们的 worker。这可能是一个简单的函数，但是我们让它成为结构的一部分，因此我们之前没有看到这样的 goroutines：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">  id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span> <span class="title">process</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    data := &lt;-c</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d got %d\n&quot;</span>, w.id, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的 worker 是简单的。他一直等到数据可用然后处理它。尽职尽责，它一直在一个循环中做这个，永远等待更多的数据去处理。</p>
<p>为了去用这个，第一件事情是启动一些 workers：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">  worker := &amp;Worker&#123;id: i&#125;</span><br><span class="line">  <span class="keyword">go</span> worker.process(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，给这些 worker 一些活干：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  c &lt;- rand.Int()</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个完整的可运行代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">  <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    worker := &amp;Worker&#123;id: i&#125;</span><br><span class="line">    <span class="keyword">go</span> worker.process(c)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    c &lt;- rand.Int()</span><br><span class="line">    time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">  id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">process</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    data := &lt;-c</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d got %d\n&quot;</span>, w.id, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不知道哪个 worker 将得到什么数据。但我们能确保的是 Go 保证了发送到通道的数据只会被一个接收器接收。</p>
<p>记着，唯一的共享状态时通道，我们可以安全地同时从它接收和发送数据。通道提供了所有我们需要的同步代码保证，在任何时间只有一个 goroutine 可以访问特定的数据。</p>
<h3 id="缓冲通道"><a href="#缓冲通道" class="headerlink" title="缓冲通道"></a>缓冲通道</h3><p>上面给出的代码中，如果有超过能处理的数据到来会发什么？你可以通过更改 worker 接收到数据之后的暂停时间来模拟这个。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  data := &lt;-c</span><br><span class="line">  fmt.Printf(<span class="string">&quot;worker %d got %d\n&quot;</span>, w.id, data)</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的主代码中发生的是，接收用户数据的代码（刚刚使用随机数生成器模拟的）是阻塞，因为没有接收器可用。</p>
<p>在某些情况下，你可能需要担保数据被处理掉，这个时候就需要开始阻塞客户端。在某些情况下，你可能会降低这种担保。这有几种常用的策略实现它。第一个就是缓冲数据。如果没有worker可用，我们想去临时存储数据在某些队列中。通道内建这种缓冲容量，当我们使用 <code>make</code> 创建通道的时候，可以设置通道的长度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>你可以对此更改进行更改，但你会注意到处理仍然不稳定。缓冲通道不会增加容量，他们只提供待处理工作的队列，以及处理突然飙升的任务量的好方法。在我们的示例中，我们不断推送比 worker 可以处理的数据更多的数据。</p>
<p>然而，我们实际上可以通过查看通道的 <code>len</code> 来理解缓冲通道是什么。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  c &lt;- rand.Int()</span><br><span class="line">  fmt.Println(<span class="built_in">len</span>(c))</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以看到通道长度一直增加直到满了，这个时候往我们的通道发送数据将再一次阻塞。</p>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>即使有缓冲，在某些时候我们需要开始删除消息。我们不能为了让 worker 轻松而耗尽所有内存。为了实现这个，我们使用 Go 的 <code>select</code>：</p>
<p>语法上，<code>select</code> 看起来有一点像 switch。使用它，我们提供当通道不能发送数据的时候处理代码。首先，让我们移除通道缓冲来看看  <code>select</code> 如何工作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>接下来，改变我们的 <code>for</code> 循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> c &lt;- rand.Int():</span><br><span class="line">    <span class="comment">// 可选的代码在这里</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 这里可以留空以静默删除数据</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;dropped&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将每秒推送20条消息，但是我们的 worker 每秒仅仅能处理10条。也就是说，一般的消息，将被丢掉。</p>
<p>这只是我们能使用 <code>select</code> 实现的一个开始。<code>select</code> 的主要目的是管理多个通道，<code>select</code> 将阻塞直到第一个通道可用。如果没有通道可用，如果提供了 <code>default</code> ，那么他就会被执行。如果多个通道都可用了，随机挑选一个。</p>
<p>很难用一个简单的例子来证明这个行为，因为它是一个相当高级的功能。下一节可能有助于证明这个。</p>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>我们看过了缓冲消息以及简单地将他们丢弃。另一个通用的选择是去超时。我们将阻塞一段时间，但不会永远。这在 Go 中也是很容易实现的。虽然，语法很难遵循，但是这样一个简洁有用的功能我不能将它排除在外。</p>
<p>为了阻塞最长时间，我们可以用 <code>time.After</code> 函数。我们来一起看看它并试着超越魔法。为了去用这个，我们的发送器将变成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> c &lt;- rand.Int():</span><br><span class="line">  <span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">100</span>):</span><br><span class="line">    fmt.Println(<span class="string">&quot;timed out&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>time.After</code> 返回了一个通道，所以我们在 <code>select</code> 中使用它。这个通道可以在指定时间之后被写入。就这样，没有其他魔法了。如果你比较好奇，这里有一个 <code>after</code> 的实现，看起来大概就是这个样子咯：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">after</span><span class="params">(d time.Duration)</span> <span class="title">chan</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(d)</span><br><span class="line">    c &lt;- <span class="literal">true</span></span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到我们的 <code>select</code>，还有两个东西可以试试。首先，如果添加回 <code>default</code> 会发生什么？能猜到吗？试试它。如果你不确定，记着如果没有可用的通道，<code>default</code> 将会立即触发。</p>
<p>还有，<code>time.After</code> 是一个 <code>chan time.Time</code> 类型的通道。上面的例子中，我们仅仅是简单地丢弃掉了发送到通道的值。如果你想要，你可以接受它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> t := &lt;-time.After(time.Millisecond * <span class="number">100</span>):</span><br><span class="line">  fmt.Println(<span class="string">&quot;timed out at&quot;</span>, t)</span><br></pre></td></tr></table></figure>

<p>注意力重新回到我们的 <code>select</code>，可以看到我们发送给 <code>c</code> 但是却从 <code>time.After</code> 接收。无论我们从哪里接收，发送给谁，或者任何通道的组合，<code>select</code> 工作方式是相同的：</p>
<ul>
<li>第一个可用的通道被选择。</li>
<li>如果多个通道可用，随机选择一个。</li>
<li>如果没有通道可用，default 情况将被执行。</li>
<li>如果没有 default，select 将会阻塞。</li>
</ul>
<p>最后，在 <code>for</code> 中看到一个 <code>select</code> 是很常见的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> data := &lt;-c:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d got %d\n&quot;</span>, w.id, data)</span><br><span class="line">  <span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">10</span>):</span><br><span class="line">    fmt.Println(<span class="string">&quot;Break time&quot;</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="继续之前-5"><a href="#继续之前-5" class="headerlink" title="继续之前"></a>继续之前</h2><p>如果你是并发编程的新手，那么看起来似乎都是压倒性的。 它绝对需要非常多的关注。Go旨在让它变得更容易。</p>
<p>Goroutines 有效的抽象了我们需要并发执行的代码。通道帮助消除数据共享时共享数据可能发生的一些严重错误。这不仅可以消除错误， 还可以改变并发编程的方式。你只用考虑通过信息传递实现并发编程，而不是危险的代码区域。</p>
<p>话虽如此，我仍然广泛使用 <code>sync</code> 和 <code>sync / atomic</code> 包中的各种同步原语。我觉得比较重要的是通过使用这两种方式比较舒适。我建议你首先关注通道，但是当你遇到一个需要短暂锁的简单示例时，请考虑使用互斥锁或读写互斥锁。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我最近听说 Go 被描述为一个<em>枯燥</em>的语言。枯燥是因为很容易去学，很容易写，以及最重要的，易读。或许，我确实认为这个实现不太好，毕竟，我<em>确实</em>花了三章讨论类型和如何声明变量。</p>
<p>如果你有静态类型语言的工作经历，我们所看到的内容仅仅只是一个复习。Go 使得指针可用性增强，并且切片是数组的包装，对于经验丰富的 Java 或 C＃开发人员来说可能并不算是压倒性优势。</p>
<p>如果你曾经大多在使用动态语言，你可能会感到有点不同。它是一个值得学习的东西。其中最重要的是声明和各种初始化的语法。尽管我是 Go 的粉丝，Go 尽管也在简单性方面取得了一些进展，但它并不简单。不过，它归纳为一些基本的规则（比如你只能声明变量一次以及 <code>:=</code> 确实声明了变量）以及基本理解（比如 <code>new(X)</code>  或者 <code>&amp;X&#123;&#125;</code> 仅仅只是分配内存，但是切片，映射以及通道需要更多的初始化，所以用 <code>make</code>）。</p>
<p>除了这些，Go 给了我们简单但有效的方式组织我们的代码。接口，基于返回的错误处理，用于资源管理的 <code>defer</code>以及实现组合的简单方式。</p>
<p>最后但也最重要的是内置并发支持。关于 <strong>协程</strong> ，除了有效和简单（无论如何简单易用）之外，几乎没有什么可说的了。这是一个很好的抽象。 <strong>通道</strong> 更为复杂。我一直认为在使用高级包装器之前先理解最基本使用方法。我认为不通过 <strong>通道</strong> 学习并发编程是很有用的。但是，对我来说，我觉得 <strong>通道</strong> 的实现方式不像一个简单的抽象。它们几乎都是自己的基本构件。我这样说是因为它们改变了你编写和思考并发编程的方式。 鉴于并发编程有多么困难，这绝对是一件好事。 </p>
<p>以及实现组合的简单方式。</p>
<p>最后但也最重要的是内置并发支持。关于 <strong>协程</strong> ，除了有效和简单（无论如何简单易用）之外，几乎没有什么可说的了。这是一个很好的抽象。 <strong>通道</strong> 更为复杂。我一直认为在使用高级包装器之前先理解最基本使用方法。我认为不通过 <strong>通道</strong> 学习并发编程是很有用的。但是，对我来说，我觉得 <strong>通道</strong> 的实现方式不像一个简单的抽象。它们几乎都是自己的基本构件。我这样说是因为它们改变了你编写和思考并发编程的方式。 鉴于并发编程有多么困难，这绝对是一件好事。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-03-18T19:00:26.000Z" title="3/18/2019, 7:00:26 PM">2019-03-18</time>发表</span><span class="level-item"><time dateTime="2021-06-10T02:08:47.727Z" title="6/10/2021, 2:08:47 AM">2021-06-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></span><span class="level-item">4 分钟读完 (大约615个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/18/Golang-transaction-%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/">Golang transaction 事务使用的正确姿势</a></h1><div class="content"><h2 id="第一种写法"><a href="#第一种写法" class="headerlink" title="第一种写法"></a>第一种写法</h2><p>这种写法非常朴实，程序流程也非常明确，但是事务处理与程序流程嵌入太深，容易遗漏，造成严重的问题</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    tx, err := db.Begin()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            tx.Rollback()</span><br><span class="line">            <span class="built_in">panic</span>(p)  <span class="comment">// re-throw panic after Rollback</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        tx.Rollback()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        tx.Rollback()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    err = tx.Commit()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二种写法"><a href="#第二种写法" class="headerlink" title="第二种写法"></a>第二种写法</h2><p>下面这种写法把事务处理从程序流程抽离了出来，不容易遗漏，但是作用域是整个函数，程序流程不是很清晰</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    tx, err := db.Begin()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            tx.Rollback()</span><br><span class="line">            <span class="built_in">panic</span>(p) <span class="comment">// re-throw panic after Rollback</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            tx.Rollback()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = tx.Commit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第三种写法"><a href="#第三种写法" class="headerlink" title="第三种写法"></a>第三种写法</h2><p>写法三是对写法二的进一步封装，写法高级一点，缺点同上</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Transact</span><span class="params">(db *sql.DB, txFunc <span class="keyword">func</span>(*sql.Tx)</span> <span class="title">error</span>) <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    tx, err := db.Begin()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            tx.Rollback()</span><br><span class="line">            <span class="built_in">panic</span>(p) <span class="comment">// re-throw panic after Rollback</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            tx.Rollback()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = tx.Commit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    err = txFunc(tx)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Transact(db, <span class="function"><span class="keyword">func</span> <span class="params">(tx *sql.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _, err := tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _, err := tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="我的写法"><a href="#我的写法" class="headerlink" title="我的写法"></a>我的写法</h2><p>经过总结和实验，我采用了下面这种写法，defer tx.Rollback() 使得事务回滚始终得到执行。 当 tx.Commit() 执行后，tx.Rollback() 起到关闭事务的作用， 当程序因为某个错误中止，tx.Rollback() 起到回滚事务，同事关闭事务的作用。</p>
<h3 id="普通场景"><a href="#普通场景" class="headerlink" title="普通场景"></a>普通场景</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">  tx, _ := db.Begin()</span><br><span class="line">  <span class="keyword">defer</span> tx.Rollback()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  err = tx.Commit()</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环场景"><a href="#循环场景" class="headerlink" title="循环场景"></a>循环场景</h3><p>(1) 小事务 每次循环提交一次 在循环内部使用这种写法的时候，defer 不能使用，所以要把事务部分抽离到独立的函数当中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    tx, _ := db.Begin()</span><br><span class="line">    <span class="keyword">defer</span> tx.Rollback()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    err = tx.Commit()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := DoSomething(); err != <span class="literal">nil</span>&#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2) 大事务 批量提交 大事务的场景和普通场景是一样的，没有任何区别</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    tx, _ := db.Begin()</span><br><span class="line">    <span class="keyword">defer</span> tx.Rollback()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _, err = tx.Exec(...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = tx.Commit()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接:<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16184238/database-sql-tx-detecting-commit-or-rollback">https://stackoverflow.com/questions/16184238/database-sql-tx-detecting-commit-or-rollback</a><br>原文地址：<br><a target="_blank" rel="noopener" href="http://hopehook.com/2017/08/21/golang_transaction/">http://hopehook.com/2017/08/21/golang_transaction/</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-03-15T10:56:22.000Z" title="3/15/2019, 10:56:22 AM">2019-03-15</time>发表</span><span class="level-item"><time dateTime="2021-06-10T02:08:47.731Z" title="6/10/2021, 2:08:47 AM">2021-06-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></span><span class="level-item">4 分钟读完 (大约636个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/15/go-mod-%E7%9A%84%E4%BD%BF%E7%94%A8/">go mod 的使用</a></h1><div class="content"><p>从Go1.11开始，golang官方支持了新的依赖管理工具<code>go mod</code>。</p>
<h2 id="命令行说明"><a href="#命令行说明" class="headerlink" title="命令行说明"></a>命令行说明</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ go mod</span><br><span class="line">Go mod provides access to operations on modules.</span><br><span class="line"></span><br><span class="line">Note that support for modules is built into all the go commands,</span><br><span class="line">not just &#x27;go mod&#x27;. For example, day-to-day adding, removing, upgrading,</span><br><span class="line">and downgrading of dependencies should be done using &#x27;go get&#x27;.</span><br><span class="line">See &#x27;go help modules&#x27; for an overview of module functionality.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">	go mod &lt;command&gt; [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">	download    download modules to local cache</span><br><span class="line">	edit        edit go.mod from tools or scripts</span><br><span class="line">	graph       print module requirement graph</span><br><span class="line">	init        initialize new module in current directory</span><br><span class="line">	tidy        add missing and remove unused modules</span><br><span class="line">	vendor      make vendored copy of dependencies</span><br><span class="line">	verify      verify dependencies have expected content</span><br><span class="line">	why         explain why packages or modules are needed</span><br><span class="line"></span><br><span class="line">Use &quot;go help mod &lt;command&gt;&quot; for more information about a command.</span><br></pre></td></tr></table></figure>
<ul>
<li>go mod download: 下载依赖的module到本地cache</li>
<li>go mod edit: 编辑go.mod</li>
<li>go mod graph: 打印模块依赖图</li>
<li>go mod init: 在当前目录下初始化go.mod(就是会新建一个go.mod文件)</li>
<li>go mod tidy: 整理依赖关系，会添加丢失的module，删除不需要的module</li>
<li>go mod vender: 将依赖复制到vendor下</li>
<li>go mod verify: 校验依赖</li>
<li>go mod why: 解释为什么需要依赖</li>
</ul>
<h2 id="在新项目中使用"><a href="#在新项目中使用" class="headerlink" title="在新项目中使用"></a>在新项目中使用</h2><p>使用go mod并不要求你的项目源码放到$GOPATH下，所以你的新项目可以放到任意你喜欢的路径。在项目根目录下执行<code>go mod init</code>，会生成一个go.mod文件。然后你可以在其中增加你的依赖，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module github.com&#x2F;gaoyoubo&#x2F;xxx</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">	github.com&#x2F;go-sql-driver&#x2F;mysql v1.4.1</span><br><span class="line">        .... 你的依赖类似这样，添加到这里，一行一条。</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>然后执行<code>go mod download</code>，将依赖下载到本地。这些依赖并不是下载到你的项目目录下，而是会下载到<code>$GOPATH/pkg/mod</code>目录下，这样所有使用go mod的项目都可以共用。</p>
<h2 id="在旧项目中使用"><a href="#在旧项目中使用" class="headerlink" title="在旧项目中使用"></a>在旧项目中使用</h2><p>在旧项目中使用非常简单，只需要一下两个步骤：</p>
<ul>
<li><code>go mod init</code>: 在项目根目录下执行该命令，会在项目根目录下生成一个<code>go.mod</code>文件。</li>
<li><code>go mod tidy</code>: 在项目根目录下执行该命令，go mod会自动分析你当前项目所需要的依赖，并且将他们下载下来。</li>
</ul>
<h2 id="如何升级依赖"><a href="#如何升级依赖" class="headerlink" title="如何升级依赖"></a>如何升级依赖</h2><p>运行 <code>go get -u</code> 将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号y是次要版本号)<br>运行 <code>go get -u=patch</code> 将会升级到最新的修订版本<br>运行 <code>go get package@version</code> 将会升级到指定的版本</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-03-11T10:45:07.000Z" title="3/11/2019, 10:45:07 AM">2019-03-11</time>发表</span><span class="level-item"><time dateTime="2021-06-10T02:08:47.727Z" title="6/10/2021, 2:08:47 AM">2021-06-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></span><span class="level-item">4 分钟读完 (大约540个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/11/Golang%E5%92%8CJava%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E8%B0%83%E6%9F%A5/">Golang和Java构建工具调查</a></h1><div class="content"><p>Github：<a target="_blank" rel="noopener" href="https://github.com/blindpirate/report-of-build-tools-for-java-and-golang">https://github.com/blindpirate/report-of-build-tools-for-java-and-golang</a></p>
<h1 id="A-Survey-on-Build-Tools-of-Golang-and-Java"><a href="#A-Survey-on-Build-Tools-of-Golang-and-Java" class="headerlink" title="A Survey on Build Tools of Golang and Java"></a>A Survey on Build Tools of Golang and Java</h1><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In January 2017, the usage of build tools in <a target="_blank" rel="noopener" href="http://github-rank.com/star?language=Java">Github’s top 1000 Java repositories</a> is as follows:</p>
<table>
<thead>
<tr>
<th>Tool Name</th>
<th align="center">Reference Count</th>
</tr>
</thead>
<tbody><tr>
<td>Gradle</td>
<td align="center">627</td>
</tr>
<tr>
<td>Maven</td>
<td align="center">264</td>
</tr>
<tr>
<td>Ant</td>
<td align="center">52</td>
</tr>
<tr>
<td>Npm</td>
<td align="center">4</td>
</tr>
<tr>
<td>Bazel</td>
<td align="center">3</td>
</tr>
<tr>
<td>Make</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>And the trending over the past 8 years is:</p>
<p><img src="/images/2019/03/11/c6a8a010-43a7-11e9-a68f-4fc47d059a0e.png" alt="trending"></p>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><ul>
<li>Clone top 1000 Java repositories to local disk</li>
<li>Analyze the repositories by identity files:</li>
</ul>
<table>
<thead>
<tr>
<th>Tool Name</th>
<th align="center">Identity Files</th>
</tr>
</thead>
<tbody><tr>
<td>Gradle</td>
<td align="center">build.gradle</td>
</tr>
<tr>
<td>Maven</td>
<td align="center">pom.xml</td>
</tr>
<tr>
<td>Ant</td>
<td align="center">build.xml</td>
</tr>
<tr>
<td>Npm</td>
<td align="center">package.json</td>
</tr>
<tr>
<td>Bazel</td>
<td align="center">BUILD</td>
</tr>
<tr>
<td>Make</td>
<td align="center">Makefile/makefile</td>
</tr>
</tbody></table>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><ul>
<li>Make sure <a target="_blank" rel="noopener" href="https://git-scm.com/">Git</a>/<a target="_blank" rel="noopener" href="http://www.groovy-lang.org/download.html">Groovy 2.4+</a>/<a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">JDK 1.7+</a> are installed.</li>
<li>Run <code>groovy GithubTopRankCrawler.groovy -l java -d &lt;path to store the 1000 repos&gt;</code> to clone all repositories locally. </li>
<li>Run <code>groovy JavaBuildToolScanner.groovy -d &lt;path to store the 1000 repos&gt;</code> to analyze these repos.</li>
</ul>
<h1 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h1><h2 id="Conclusion-1"><a href="#Conclusion-1" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>There are various package management tools for golang as listed <a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/PackageManagementTools">here</a>. But which one is the most popular? </p>
<p>The usage of package manage tools in <a target="_blank" rel="noopener" href="http://github-rank.com/star?language=Go">Github’s top 1000 Go repositories</a> is as follows:</p>
<table>
<thead>
<tr>
<th>Tool Name</th>
<th align="center">Url</th>
<th align="center">Reference Count (Feb 2017)</th>
<th align="center">Reference Count (Nov 2017)</th>
</tr>
</thead>
<tbody><tr>
<td>Makefile</td>
<td align="center"><a href="">Makefile</a></td>
<td align="center">199</td>
<td align="center">181</td>
</tr>
<tr>
<td>dep</td>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/golang/dep">dep</a></td>
<td align="center">N/A</td>
<td align="center">94</td>
</tr>
<tr>
<td>godep</td>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/tools/godep">godep</a></td>
<td align="center">119</td>
<td align="center">90</td>
</tr>
<tr>
<td>govendor</td>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/kardianos/govendor">govendor</a></td>
<td align="center">65</td>
<td align="center">84</td>
</tr>
<tr>
<td>glide</td>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/Masterminds/glide">glide</a></td>
<td align="center">64</td>
<td align="center">77</td>
</tr>
<tr>
<td>gvt</td>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/FiloSottile/gvt">gvt</a></td>
<td align="center">25</td>
<td align="center">16</td>
</tr>
<tr>
<td>trash</td>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/rancher/trash">trash</a></td>
<td align="center">7</td>
<td align="center">13</td>
</tr>
<tr>
<td>submodule</td>
<td align="center"><a href="">submodule</a></td>
<td align="center">8</td>
<td align="center">6</td>
</tr>
<tr>
<td>gpm/johnny-deps</td>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/pote/gpm">gpm</a> <a target="_blank" rel="noopener" href="https://github.com/VividCortex/johnny-deps">johnny-deps</a></td>
<td align="center">7</td>
<td align="center">6</td>
</tr>
<tr>
<td>glock</td>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/robfig/glock">glock</a></td>
<td align="center">5</td>
<td align="center">4</td>
</tr>
<tr>
<td>gom</td>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/mattn/gom">gom</a></td>
<td align="center">4</td>
<td align="center">2</td>
</tr>
<tr>
<td>gopack</td>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/d2fn/gopack">gopack</a></td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td>gopm</td>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/gpmgo/gopm">gopm</a></td>
<td align="center">3</td>
<td align="center">1</td>
</tr>
<tr>
<td>goop</td>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/nitrous-io/goop">goop</a></td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td>gvend</td>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/govend/govend">gvend</a></td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/dep">dep</a> had a first release in May 2017, did not exist for first stats.</p>
<p>Technically, <code>make</code> is not a package management tool, here it is just for comparison.</p>
<p>Submodule refers to a set of tools which use <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-submodule">git submodule</a> to manage dependencies such as <a target="_blank" rel="noopener" href="https://github.com/kovetskiy/manul">manul</a> and <a target="_blank" rel="noopener" href="https://github.com/dpw/vendetta">Vendetta</a> and so on.</p>
<h2 id="Algorithm-1"><a href="#Algorithm-1" class="headerlink" title="Algorithm"></a>Algorithm</h2><ul>
<li>Clone top 1000 Go repositories to local disk</li>
<li>Analyze the repositories by identity files:</li>
</ul>
<table>
<thead>
<tr>
<th>Tool Name</th>
<th align="center">Identity Files</th>
</tr>
</thead>
<tbody><tr>
<td>godep</td>
<td align="center">Godeps/Godeps.json</td>
</tr>
<tr>
<td>govendor</td>
<td align="center">vendor/vendor.json</td>
</tr>
<tr>
<td>gopm</td>
<td align="center">.gopmfile</td>
</tr>
<tr>
<td>gvt</td>
<td align="center">vendor/manifest</td>
</tr>
<tr>
<td>gvend</td>
<td align="center">vendor.yml</td>
</tr>
<tr>
<td>glide</td>
<td align="center">glide.yaml or glide.lock</td>
</tr>
<tr>
<td>trash</td>
<td align="center">vendor.conf</td>
</tr>
<tr>
<td>gom</td>
<td align="center">Gomfile</td>
</tr>
<tr>
<td>bunch</td>
<td align="center">bunchfile</td>
</tr>
<tr>
<td>goop</td>
<td align="center">Goopfile</td>
</tr>
<tr>
<td>goat</td>
<td align="center">.go.yaml</td>
</tr>
<tr>
<td>glock</td>
<td align="center">GLOCKFILE</td>
</tr>
<tr>
<td>gobs</td>
<td align="center">goproject.json</td>
</tr>
<tr>
<td>gopack</td>
<td align="center">gopack.config</td>
</tr>
<tr>
<td>nut</td>
<td align="center">Nut.toml</td>
</tr>
<tr>
<td>gpm/johnny-deps</td>
<td align="center">Godeps</td>
</tr>
<tr>
<td>Makefile</td>
<td align="center">makefile or Makefile</td>
</tr>
<tr>
<td>submodule</td>
<td align="center">.gitmodules</td>
</tr>
</tbody></table>
<h2 id="How-1"><a href="#How-1" class="headerlink" title="How"></a>How</h2><ul>
<li>Make sure <a target="_blank" rel="noopener" href="https://git-scm.com/">Git</a>/<a target="_blank" rel="noopener" href="http://www.groovy-lang.org/download.html">Groovy 2.4+</a>/<a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">JDK 1.7+</a> are installed.</li>
<li>Run <code>groovy GithubTopRankCrawler.groovy -l go -d &lt;path to store the 1000 repos&gt;</code> to clone all repositories locally. You can use <code>-s</code> to do the shallow clone and decrease disk usage.</li>
<li>Run <code>groovy GoBuildToolScanner.groovy &lt;path to store the 1000 repos&gt;</code> to analyze these repos.</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-12-21T11:27:33.000Z" title="12/21/2018, 11:27:33 AM">2018-12-21</time>发表</span><span class="level-item"><time dateTime="2021-06-10T02:08:47.731Z" title="6/10/2021, 2:08:47 AM">2021-06-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></span><span class="level-item">1 分钟读完 (大约141个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/12/21/IDE-Goland-DEBUG%E6%8A%A5%E9%94%99/">IDE Goland DEBUG报错</a></h1><div class="content"><p>在升级GO版本到1.11后发现Goland的Debug报错，错误信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">could not launch process: decoding dwarf section info at offset 0x0: too short</span><br></pre></td></tr></table></figure>
<p>原因是Goland的dlv不是新版本，导致不能debug调试。</p>
<p>解决办法：</p>
<ol>
<li>更新dlv：go get -u github.com/derekparker/delve/cmd/dlv</li>
<li>修改goland配置，Help-&gt;Edit Custom Properties中增加新版dlv的路径配置：dlv.path=$GOPATH/bin/dlv</li>
<li>重启Goland，再次使用debug调试工具，就没有问题了。</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/43014884/mac-osx-jetbrains-gogland-delve-debugging-meet-could-not-launch-process-could/43014980#43014980">https://stackoverflow.com/questions/43014884/mac-osx-jetbrains-gogland-delve-debugging-meet-could-not-launch-process-could/43014980#43014980</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2017-11-28T11:44:00.000Z" title="11/28/2017, 11:44:00 AM">2017-11-28</time>发表</span><span class="level-item"><time dateTime="2021-06-10T02:08:47.727Z" title="6/10/2021, 2:08:47 AM">2021-06-10</time>更新</span><span class="level-item"> 雾非雾的情思 </span><span class="level-item">几秒读完 (大约34个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/11/28/Go%E7%94%9F%E6%88%90csv%E6%96%87%E4%BB%B6/">Go生成csv文件</a></h1><div class="content"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/csv&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f, err := os.Create(<span class="string">&quot;test.csv&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	w := csv.NewWriter(f)</span><br><span class="line">	data := [][]<span class="keyword">string</span>&#123;</span><br><span class="line">		&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;11&quot;</span>, <span class="string">&quot;11&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;2&quot;</span>, <span class="string">&quot;22&quot;</span>, <span class="string">&quot;22&quot;</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	w.WriteAll(data)</span><br><span class="line">	w.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2017-06-14T00:00:00.000Z" title="6/14/2017, 12:00:00 AM">2017-06-14</time>发表</span><span class="level-item"><time dateTime="2021-06-10T02:08:47.727Z" title="6/10/2021, 2:08:47 AM">2021-06-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></span><span class="level-item">2 分钟读完 (大约290个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/06/14/Go%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/">Go语言第二次实战应用</a></h1><div class="content"><p>使用场景，由于历史原因造成redis计数不准确，需要将数据从数据库中count一次，然后同步到redis。</p>
<h3 id="使用到的包"><a href="#使用到的包" class="headerlink" title="使用到的包"></a>使用到的包</h3><ul>
<li>github.com/go-sql-driver/mysql</li>
<li>github.com/go-redis/redis</li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-redis/redis&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// redis 客户端</span></span><br><span class="line"><span class="keyword">var</span> client *redis.Client</span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    dbUrl = <span class="string">&quot;username:password@tcp(localhost:3306)/dianping_new_db?charset=utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化redis客户端</span></span><br><span class="line">    client = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">        Addr:     <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">        Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">        DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">    &#125;)</span><br><span class="line">    db, _ = sql.Open(<span class="string">&quot;mysql&quot;</span>, dbUrl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dianpingMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">    dianpingMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    listById(<span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>, dianpingId <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        _, ok := dianpingMap[dianpingId]</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count := getCount(dianpingId)</span><br><span class="line"></span><br><span class="line">        redisKey := <span class="string">&quot;dianping-count-&quot;</span> + dianpingId</span><br><span class="line">        client.HSet(redisKey, <span class="string">&quot;replyCount&quot;</span>, count)</span><br><span class="line"></span><br><span class="line">        dianpingMap[dianpingId] = dianpingId</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">&quot;id&quot;</span>, id, <span class="string">&quot;dianpingId&quot;</span>, dianpingId, <span class="string">&quot;count&quot;</span>, count)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    client.Close()</span><br><span class="line">    db.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>, dianpingId <span class="keyword">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listById</span><span class="params">(handler Handler)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cursor = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sql := <span class="string">&quot;select id, dianping_id from t_dianping_reply &quot;</span></span><br><span class="line">        <span class="keyword">if</span> cursor &gt; <span class="number">0</span> &#123;</span><br><span class="line">            sql += <span class="string">&quot; where id &gt; &quot;</span> + strconv.Itoa(cursor)</span><br><span class="line">        &#125;</span><br><span class="line">        sql += <span class="string">&quot; order by id asc limit 10 &quot;</span></span><br><span class="line"></span><br><span class="line">        rows, err := db.Query(sql)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">                <span class="keyword">var</span> id, dianpingId <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">                rows.Scan(&amp;id, &amp;dianpingId)</span><br><span class="line"></span><br><span class="line">                handler(id, dianpingId)</span><br><span class="line"></span><br><span class="line">                cursor, _ = strconv.Atoi(id)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rows.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCount</span><span class="params">(dianpingId <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    rows, err := db.Query(<span class="string">&quot;select count(*) from t_dianping_reply where dianping_id = ? and status = 0&quot;</span>, dianpingId)</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> rows.Next() &#123;</span><br><span class="line">        rows.Scan(&amp;count)</span><br><span class="line">    &#125;</span><br><span class="line">    rows.Close()</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2017-06-03T00:00:00.000Z" title="6/3/2017, 12:00:00 AM">2017-06-03</time>发表</span><span class="level-item"><time dateTime="2021-06-10T02:08:47.727Z" title="6/10/2021, 2:08:47 AM">2021-06-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></span><span class="level-item">2 分钟读完 (大约282个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/06/03/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/">Go语言的第一次实战应用</a></h1><div class="content"><p>最近开始在熟悉Go语言，正巧产品同学需要分析一些数据，数据是放在ElasticSearch中的，打算使用Go语言来进行分析。<br>Go语言的优势就是对linux兼容很好，可以直接成linux上的可执行文件，无需其他任何环境的支持。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    elastic <span class="string">&quot;gopkg.in/olivere/elastic.v3&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    url = <span class="string">&quot;http://xxx.xxx.xxx.xxx:9200&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id         <span class="keyword">int</span></span><br><span class="line">    MucangId   <span class="keyword">string</span></span><br><span class="line">    Message    <span class="keyword">string</span></span><br><span class="line">    CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    errorLog := log.New(os.Stdout, <span class="string">&quot;es &quot;</span>, log.LstdFlags)</span><br><span class="line"></span><br><span class="line">    client, err := elastic.NewClient(elastic.SetURL(url), elastic.SetErrorLog(errorLog))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cursor <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(strconv.Itoa(cursor))</span><br><span class="line"></span><br><span class="line">        boolQuery := elastic.NewBoolQuery().Filter(</span><br><span class="line">            elastic.NewTermQuery(<span class="string">&quot;appinfoId&quot;</span>, <span class="number">1</span>),</span><br><span class="line">            elastic.NewRangeQuery(<span class="string">&quot;createTime&quot;</span>).Gt(<span class="string">&quot;2017-05-22 00:00:00 +0800&quot;</span>),</span><br><span class="line">            elastic.NewMatchPhraseQuery(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;向你求助&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cursor &gt; <span class="number">0</span> &#123;</span><br><span class="line">            boolQuery.Filter(elastic.NewRangeQuery(<span class="string">&quot;id&quot;</span>).Gt(cursor))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        searchResult, err := client.Search().</span><br><span class="line">            Index(<span class="string">&quot;push-record&quot;</span>).</span><br><span class="line">            Type(<span class="string">&quot;message&quot;</span>).</span><br><span class="line">            Query(boolQuery).</span><br><span class="line">            Sort(<span class="string">&quot;id&quot;</span>, <span class="literal">true</span>).</span><br><span class="line">            From(<span class="number">0</span>).Size(<span class="number">100</span>).</span><br><span class="line">            Pretty(<span class="literal">true</span>).</span><br><span class="line">            Do()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> searchResult.Hits.TotalHits &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _, hit := <span class="keyword">range</span> searchResult.Hits.Hits &#123;</span><br><span class="line">                <span class="keyword">var</span> msg Message</span><br><span class="line">                json.Unmarshal(*hit.Source, &amp;msg)</span><br><span class="line"></span><br><span class="line">                cursor = msg.Id</span><br><span class="line"></span><br><span class="line">                b, _ := json.Marshal(hit.Source)</span><br><span class="line">                <span class="built_in">append</span>(<span class="string">&quot;/home/gaoyoubo/push.log&quot;</span>, <span class="keyword">string</span>(b))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(path <span class="keyword">string</span>, content <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    file, _ := os.OpenFile(path, os.O_RDWR|os.O_CREATE|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line">    content = strings.Join([]<span class="keyword">string</span>&#123;content, <span class="string">&quot;\n&quot;</span>&#125;, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    buf := []<span class="keyword">byte</span>(content)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    file.Write(buf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2017-06-02T00:00:00.000Z" title="6/2/2017, 12:00:00 AM">2017-06-02</time>发表</span><span class="level-item"><time dateTime="2021-06-10T02:08:47.727Z" title="6/10/2021, 2:08:47 AM">2021-06-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></span><span class="level-item">几秒读完 (大约23个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/06/02/Go%E8%AF%AD%E8%A8%80%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/">Go语言在mac下编译Linux可执行文件</a></h1><div class="content"><p>进入源码目录，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build </span><br></pre></td></tr></table></figure></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="http://file.mspring.org/images/blog/avatar.jpg" alt="雾非雾的情思"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">雾非雾的情思</p><p class="is-size-6 is-block">爱折腾的老码农！</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Wuhan, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">150</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">29</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/gaoyoubo" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/gaoyoubo"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"><span class="level-start"><span class="level-item">碎碎念</span></span><span class="level-end"><span class="level-item tag">39</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/"><span class="level-start"><span class="level-item">程序员</span></span><span class="level-end"><span class="level-item tag">86</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-10T10:08:18.000Z">2021-06-10</time></p><p class="title"><a href="/2021/06/10/%E6%89%B9%E9%87%8F%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/">批量拉取代码</a></p><p class="categories"><a href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-22T14:04:19.000Z">2021-03-22</time></p><p class="title"><a href="/2021/03/22/MacOS%E5%AE%89%E8%A3%85PHP/">MacOS安装PHP</a></p><p class="categories"><a href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-01-22T22:13:31.000Z">2021-01-22</time></p><p class="title"><a href="/2021/01/22/%E7%BE%A4%E8%BE%89QNAP%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/">群辉QNAP使用备忘</a></p><p class="categories"><a href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/">碎碎念</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-01-19T16:53:42.000Z">2021-01-19</time></p><p class="title"><a href="/2021/01/19/mac-iterm2-rz%E4%B8%8Esz%E7%9A%84%E5%8A%9F%E8%83%BD/">mac iterm2 rz与sz的功能</a></p><p class="categories"><a href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-25T11:18:00.000Z">2020-11-25</time></p><p class="title"><a href="/2020/11/25/Mac%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">Mac使用过程中的问题汇总</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">六月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">十二月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/11/"><span class="level-start"><span class="level-item">十一月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/09/"><span class="level-start"><span class="level-item">九月 2017</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/07/"><span class="level-start"><span class="level-item">七月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/06/"><span class="level-start"><span class="level-item">六月 2017</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/04/"><span class="level-start"><span class="level-item">四月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/03/"><span class="level-start"><span class="level-item">三月 2017</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/11/"><span class="level-start"><span class="level-item">十一月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/04/"><span class="level-start"><span class="level-item">四月 2016</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/03/"><span class="level-start"><span class="level-item">三月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/02/"><span class="level-start"><span class="level-item">二月 2016</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/07/"><span class="level-start"><span class="level-item">七月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/05/"><span class="level-start"><span class="level-item">五月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/04/"><span class="level-start"><span class="level-item">四月 2015</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/03/"><span class="level-start"><span class="level-item">三月 2015</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/02/"><span class="level-start"><span class="level-item">二月 2015</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/10/"><span class="level-start"><span class="level-item">十月 2014</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/08/"><span class="level-start"><span class="level-item">八月 2014</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/06/"><span class="level-start"><span class="level-item">六月 2014</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/05/"><span class="level-start"><span class="level-item">五月 2014</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/03/"><span class="level-start"><span class="level-item">三月 2014</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/01/"><span class="level-start"><span class="level-item">一月 2014</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2013/12/"><span class="level-start"><span class="level-item">十二月 2013</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2013/10/"><span class="level-start"><span class="level-item">十月 2013</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2013/09/"><span class="level-start"><span class="level-item">九月 2013</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ElasticSearch/"><span class="tag">ElasticSearch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Electron/"><span class="tag">Electron</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hadoop/"><span class="tag">Hadoop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HexoClient/"><span class="tag">HexoClient</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaCV/"><span class="tag">JavaCV</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nginx/"><span class="tag">Nginx</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ffmpeg/"><span class="tag">ffmpeg</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mac/"><span class="tag">mac</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mariadb/"><span class="tag">mariadb</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/markdown/"><span class="tag">markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ocr/"><span class="tag">ocr</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/php/"><span class="tag">php</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shadowsocks/"><span class="tag">shadowsocks</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/springboot/"><span class="tag">springboot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tesseract/"><span class="tag">tesseract</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"><span class="tag">推荐系统</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"><span class="tag">碎碎念</span><span class="tag">38</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"><span class="tag">程序员</span><span class="tag">44</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="http://file.mspring.org/images/blog/avatar.jpg" alt="雾非雾的情思" height="28"></a><p class="is-size-7"><span>&copy; 2021 雾非雾的情思</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Github" href="https://github.com/gaoyoubo"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>